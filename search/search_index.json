{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Installation Using Composer $ composer require laminas/laminas-cache Learn Usage in a laminas-mvc application","title":"Home"},{"location":"#installation","text":"","title":"Installation"},{"location":"#learn","text":"Usage in a laminas-mvc application","title":"Learn"},{"location":"v2/basic-usage/","text":"Basic Usage Standalone If this component is used without laminas-mvc or mezzio , a PSR-11 container to fetch services, adapters, plugins, etc. is needed. The easiest way would be to use laminas-config-aggregator along with laminas-servicemanager . use Laminas\\Cache\\ConfigProvider; use Laminas\\Cache\\Service\\StorageAdapterFactoryInterface; use Laminas\\Cache\\Storage\\Adapter\\Memory; use Laminas\\ConfigAggregator\\ConfigAggregator; use Laminas\\ServiceManager\\ServiceManager; $config = (new ConfigAggregator([ ConfigProvider::class, ]))-&gt;getMergedConfig(); $dependencies = $config['dependencies']; $container = new ServiceManager($dependencies); /** @var StorageAdapterFactoryInterface $storageFactory */ $storageFactory = $container-&gt;get(StorageAdapterFactoryInterface::class); $storage = $storageFactory-&gt;create(Memory::class); $storage-&gt;setItem('foo', 'bar');","title":"Basic Usage"},{"location":"v2/basic-usage/#basic-usage","text":"","title":"Basic Usage"},{"location":"v2/basic-usage/#standalone","text":"If this component is used without laminas-mvc or mezzio , a PSR-11 container to fetch services, adapters, plugins, etc. is needed. The easiest way would be to use laminas-config-aggregator along with laminas-servicemanager . use Laminas\\Cache\\ConfigProvider; use Laminas\\Cache\\Service\\StorageAdapterFactoryInterface; use Laminas\\Cache\\Storage\\Adapter\\Memory; use Laminas\\ConfigAggregator\\ConfigAggregator; use Laminas\\ServiceManager\\ServiceManager; $config = (new ConfigAggregator([ ConfigProvider::class, ]))-&gt;getMergedConfig(); $dependencies = $config['dependencies']; $container = new ServiceManager($dependencies); /** @var StorageAdapterFactoryInterface $storageFactory */ $storageFactory = $container-&gt;get(StorageAdapterFactoryInterface::class); $storage = $storageFactory-&gt;create(Memory::class); $storage-&gt;setItem('foo', 'bar');","title":"Standalone"},{"location":"v2/installation/","text":"Avoid Unused Cache Adapters Are Being Installed Only necessary in 2.10+ Starting with 3.0.0, no storage adapter is required by this component and thus, each project has to specify the storage adapters which are required by the project. When migrated to 3.0.0, the replace section is not needed anymore. With laminas-cache v2.10.0, we introduced satellite packages for all cache adapters. In case, there is no need for several adapters in your project, you can use composer to ensure these adapters are not being installed. To make this happen, you have to specify a replace property within the composer.json of your project. Example composer.json with Only Memory Adapter Being Installed { \"name\": \"vendor/project\", \"description\": \"\", \"type\": \"project\", \"require\": { \"laminas/laminas-cache\": \"^2.10\", \"laminas/laminas-cache-storage-adapter-memory\": \"^1.0\" }, \"replace\": { \"laminas/laminas-cache-storage-adapter-apc\": \"*\", \"laminas/laminas-cache-storage-adapter-apcu\": \"*\", \"laminas/laminas-cache-storage-adapter-blackhole\": \"*\", \"laminas/laminas-cache-storage-adapter-dba\": \"*\", \"laminas/laminas-cache-storage-adapter-ext-mongodb\": \"*\", \"laminas/laminas-cache-storage-adapter-filesystem\": \"*\", \"laminas/laminas-cache-storage-adapter-memcache\": \"*\", \"laminas/laminas-cache-storage-adapter-memcached\": \"*\", \"laminas/laminas-cache-storage-adapter-mongodb\": \"*\", \"laminas/laminas-cache-storage-adapter-redis\": \"*\", \"laminas/laminas-cache-storage-adapter-session\": \"*\", \"laminas/laminas-cache-storage-adapter-wincache\": \"*\", \"laminas/laminas-cache-storage-adapter-xcache\": \"*\", \"laminas/laminas-cache-storage-adapter-zend-server\": \"*\" } } When using composer install on this, only the laminas/laminas-cache-storage-adapter-memory is being installed. Loading composer repositories with package information Installing dependencies (including require-dev) from lock file Package operations: 10 installs, 0 updates, 0 removals - Installing psr/simple-cache (1.0.1): Loading from cache - Installing psr/cache (1.0.1): Loading from cache - Installing laminas/laminas-zendframework-bridge (1.2.0): Loading from cache - Installing laminas/laminas-stdlib (3.3.1): Loading from cache - Installing psr/container (1.1.1): Loading from cache - Installing container-interop/container-interop (1.2.0): Loading from cache - Installing laminas/laminas-servicemanager (3.6.4): Loading from cache - Installing laminas/laminas-eventmanager (3.3.1): Loading from cache - Installing laminas/laminas-cache-storage-adapter-memory (1.0.1): Loading from cache - Installing laminas/laminas-cache (2.10.1): Loading from cache Package container-interop/container-interop is abandoned, you should avoid using it. Use psr/container instead. Generating autoload files 6 packages you are using are looking for funding. Use the `composer fund` command to find out more!","title":"Installation"},{"location":"v2/installation/#avoid-unused-cache-adapters-are-being-installed","text":"","title":"Avoid Unused Cache Adapters Are Being Installed"},{"location":"v2/psr16/","text":"PSR-16 Available since version 2.8.0 PSR-16 provides a simplified approach to cache access that does not involve cache pools, tags, deferment, etc.; it can be thought of as a key/value storage approach to caching. laminas-cache provides PSR-16 support via the class Laminas\\Cache\\Psr\\SimpleCache\\SimpleCacheDecorator . This class implements PSR-16's Psr\\SimpleCache\\CacheInterface , and composes a Laminas\\Cache\\Storage\\StorageInterface instance to which it proxies all operations. Instantiation is as follows: use Laminas\\Cache\\Psr\\SimpleCache\\SimpleCacheDecorator; use Laminas\\Cache\\Service\\StorageAdapterFactoryInterface; use Psr\\Container\\ContainerInterface; /** @var ContainerInterface $container */ $container = null; // can be any configured PSR-11 container $storageFactory = $container-&gt;get(StorageAdapterFactoryInterface::class); $storage = $storageFactory-&gt;create('apc'); $cache = new SimpleCacheDecorator($storage); Once you have a SimpleCacheDecorator instance, you can perform operations per that specification: // Use has() to determine whether to fetch the value or calculate it: $value = $cache-&gt;has('someKey') ? $cache-&gt;get('someKey') : calculateValue(); if (! $cache-&gt;has('someKey')) { $cache-&gt;set('someKey', $value); } // Or use a default value: $value = $cache-&gt;get('someKey', $defaultValue); When setting values, whether single values or multiple, you can also optionally provide a Time To Live (TTL) value. This proxies to the underlying storage instance's options, temporarily resetting its TTL value for the duration of the operation. TTL values may be expressed as integers (in which case they represent seconds) or DateInterval instances. As examples: $cache-&gt;set('someKey', $value, 30); // set TTL to 30s $cache-&gt;set('someKey', $value, new DateInterval('P1D')); // set TTL to 1 day $cache-&gt;setMultiple([ 'key1' =&gt; $value1, 'key2' =&gt; $value2, ], 3600); // set TTL to 1 hour $cache-&gt;setMultiple([ 'key1' =&gt; $value1, 'key2' =&gt; $value2, ], new DateInterval('P6H')); // set TTL to 6 hours For more details on what methods are exposed, consult the CacheInterface specification . Serialization PSR-16 has strict requirements around serialization of values. This is done to ensure that if you swap one PSR-16 adapter for another, the new one will be able to return the same values that the original adapter saved to the cache. Not all cache backends support the same data types, however. laminas-cache provides a plugin, Laminas\\Cache\\Storage\\Plugin\\Serializer , that you can attach to adapters in order to ensure data is serialized to a string when saving to the cache, and deserialized to native PHP types on retrieval. The following adapters require this plugin in order to work with the SimpleCacheDecorator : Dba Filesystem Memcache MongoDB Redis XCache We provide a number of examples of attaching plugins to storage adapters in the plugins chapter . Generally, it will be one of: use Laminas\\Cache\\Service\\StorageAdapterFactoryInterface; use Laminas\\Cache\\Storage\\Plugin\\Serializer; use Psr\\Container\\ContainerInterface; // Manual attachment after you have an instance: $cache-&gt;addPlugin(new Serializer()); // Via configuration: /** @var ContainerInterface $container */ $container = null; // can be any configured PSR-11 container $storageFactory = $container-&gt;get(StorageAdapterFactoryInterface::class); $cache = $storageFactory-&gt;create( 'filesystem', [], [ ['name' =&gt; 'serializer'], ] ); Deleting Items and Exceptions PSR-16 states that the delete() and deleteMultiple() methods should return false if an error occured when deleting the key(s) provided, but true otherwise. Generally, laminas-cache storage adapters comply with this. However, it is possible to configure your adapter such that you may get a false positive result from these methods. When an exception is raised and caught during key removal by an adapter, the adapter triggers an event with a Laminas\\Cache\\Storage\\ExceptionEvent . Plugins can react to these, and even manipulate the event instance. One such plugin, Laminas\\Cache\\Storage\\Plugin\\ExceptionHandler , has a configuration option, throw_exceptions that, when boolean false , will prevent raising the exception. In such cases, adapters will typically return a boolean false anyways, but custom, third-party adapters may not. Additionally, if you add a custom plugin that listens to removal event exceptions and modifies the return value and/or disables throwing the exception, a false positive return value could occur. As such, we recommend that if you wish to use laminas-cache to provide a PSR-16 adapter, you audit the plugins you use with your adapter to ensure that you will get consistent, correct behavior for delete() and deleteMultiple() operations.","title":"PSR-16"},{"location":"v2/psr16/#psr-16","text":"Available since version 2.8.0 PSR-16 provides a simplified approach to cache access that does not involve cache pools, tags, deferment, etc.; it can be thought of as a key/value storage approach to caching. laminas-cache provides PSR-16 support via the class Laminas\\Cache\\Psr\\SimpleCache\\SimpleCacheDecorator . This class implements PSR-16's Psr\\SimpleCache\\CacheInterface , and composes a Laminas\\Cache\\Storage\\StorageInterface instance to which it proxies all operations. Instantiation is as follows: use Laminas\\Cache\\Psr\\SimpleCache\\SimpleCacheDecorator; use Laminas\\Cache\\Service\\StorageAdapterFactoryInterface; use Psr\\Container\\ContainerInterface; /** @var ContainerInterface $container */ $container = null; // can be any configured PSR-11 container $storageFactory = $container-&gt;get(StorageAdapterFactoryInterface::class); $storage = $storageFactory-&gt;create('apc'); $cache = new SimpleCacheDecorator($storage); Once you have a SimpleCacheDecorator instance, you can perform operations per that specification: // Use has() to determine whether to fetch the value or calculate it: $value = $cache-&gt;has('someKey') ? $cache-&gt;get('someKey') : calculateValue(); if (! $cache-&gt;has('someKey')) { $cache-&gt;set('someKey', $value); } // Or use a default value: $value = $cache-&gt;get('someKey', $defaultValue); When setting values, whether single values or multiple, you can also optionally provide a Time To Live (TTL) value. This proxies to the underlying storage instance's options, temporarily resetting its TTL value for the duration of the operation. TTL values may be expressed as integers (in which case they represent seconds) or DateInterval instances. As examples: $cache-&gt;set('someKey', $value, 30); // set TTL to 30s $cache-&gt;set('someKey', $value, new DateInterval('P1D')); // set TTL to 1 day $cache-&gt;setMultiple([ 'key1' =&gt; $value1, 'key2' =&gt; $value2, ], 3600); // set TTL to 1 hour $cache-&gt;setMultiple([ 'key1' =&gt; $value1, 'key2' =&gt; $value2, ], new DateInterval('P6H')); // set TTL to 6 hours For more details on what methods are exposed, consult the CacheInterface specification .","title":"PSR-16"},{"location":"v2/psr16/#serialization","text":"PSR-16 has strict requirements around serialization of values. This is done to ensure that if you swap one PSR-16 adapter for another, the new one will be able to return the same values that the original adapter saved to the cache. Not all cache backends support the same data types, however. laminas-cache provides a plugin, Laminas\\Cache\\Storage\\Plugin\\Serializer , that you can attach to adapters in order to ensure data is serialized to a string when saving to the cache, and deserialized to native PHP types on retrieval. The following adapters require this plugin in order to work with the SimpleCacheDecorator : Dba Filesystem Memcache MongoDB Redis XCache We provide a number of examples of attaching plugins to storage adapters in the plugins chapter . Generally, it will be one of: use Laminas\\Cache\\Service\\StorageAdapterFactoryInterface; use Laminas\\Cache\\Storage\\Plugin\\Serializer; use Psr\\Container\\ContainerInterface; // Manual attachment after you have an instance: $cache-&gt;addPlugin(new Serializer()); // Via configuration: /** @var ContainerInterface $container */ $container = null; // can be any configured PSR-11 container $storageFactory = $container-&gt;get(StorageAdapterFactoryInterface::class); $cache = $storageFactory-&gt;create( 'filesystem', [], [ ['name' =&gt; 'serializer'], ] );","title":"Serialization"},{"location":"v2/psr16/#deleting-items-and-exceptions","text":"PSR-16 states that the delete() and deleteMultiple() methods should return false if an error occured when deleting the key(s) provided, but true otherwise. Generally, laminas-cache storage adapters comply with this. However, it is possible to configure your adapter such that you may get a false positive result from these methods. When an exception is raised and caught during key removal by an adapter, the adapter triggers an event with a Laminas\\Cache\\Storage\\ExceptionEvent . Plugins can react to these, and even manipulate the event instance. One such plugin, Laminas\\Cache\\Storage\\Plugin\\ExceptionHandler , has a configuration option, throw_exceptions that, when boolean false , will prevent raising the exception. In such cases, adapters will typically return a boolean false anyways, but custom, third-party adapters may not. Additionally, if you add a custom plugin that listens to removal event exceptions and modifies the return value and/or disables throwing the exception, a false positive return value could occur. As such, we recommend that if you wish to use laminas-cache to provide a PSR-16 adapter, you audit the plugins you use with your adapter to ensure that you will get consistent, correct behavior for delete() and deleteMultiple() operations.","title":"Deleting Items and Exceptions"},{"location":"v2/psr6/","text":"PSR-6 Available since version 2.8.0 Overview The Laminas\\Cache\\Psr\\CacheItemPool\\CacheItemPoolDecorator provides a PSR-6 compliant wrapper for supported storage adapters. PSR-6 specifies a common interface to cache storage, enabling developers to switch between implementations without having to worry about any behind-the-scenes differences between them. Quick Start To use the pool, instantiate your storage as normal, then pass it to the CacheItemPoolDecorator . use Laminas\\Cache\\Psr\\CacheItemPool\\CacheItemPoolDecorator;use Laminas\\Cache\\Service\\StorageAdapterFactoryInterface;use Psr\\Container\\ContainerInterface; /** @var ContainerInterface $container */ $container = null; // can be any configured PSR-11 container $storageFactory = $container-&gt;get(StorageAdapterFactoryInterface::class); $storage = $storageFactory-&gt;create('apc'); $pool = new CacheItemPoolDecorator($storage); // attempt to get an item from cache $item = $pool-&gt;getItem('foo'); // check whether item was found if (! $item-&gt;isHit()) { // ... // perform expensive operation to calculate $value for 'foo' // ... $item-&gt;set($value); $pool-&gt;save($item); } // use the value of the item echo $item-&gt;get(); Note that you will always get back a CacheItem object, whether it was found in cache or not: this is so false -y values like an empty string, null , or false can be stored. Always check isHit() to determine if the item was found. Supported Adapters The PSR-6 specification requires that the underlying storage support time-to-live (TTL), which is set when the item is saved. For this reason the following adapters cannot be used: Dba , Filesystem , Memory and Session . The XCache adapter calculates TTLs based on the request time, not the time the item is actually persisted, which means that it also cannot be used. In addition adapters must support the Laminas\\Cache\\FlushableInterface . All the current Laminas\\Cache\\Storage\\Adapter s fulfil this requirement. Attempting to use an unsupported adapter will throw an exception implementing Psr\\Cache\\CacheException . The Laminas\\Cache\\Psr\\CacheItemPool\\CacheItemPoolDecorator adapter doesn't support driver deferred saves, so cache items are saved on destruct or on explicit commit() call. Quirks APC You cannot set the apc.use_request_time ini setting with the APC adapter: the specification requires that all TTL values are calculated from when the item is actually saved to storage. If this is set when you instantiate the pool it will throw an exception implementing Psr\\Cache\\CacheException . Changing the setting after you have instantiated the pool will result in non-standard behaviour. Logging Errors The specification states : While caching is often an important part of application performance, it should never be a critical part of application functionality. Thus, an error in a cache system SHOULD NOT result in application failure. Once you've got your pool instance, almost all exceptions thrown by the storage will be caught and ignored. The only storage exceptions that bubble up implement Psr\\Cache\\InvalidArgumentException and are typically caused by invalid key errors. To be PSR-6 compliant, cache keys must not contain the following characters: {}()/\\@: . However different storage adapters may have further restrictions. Check the documentation for your particular adapter to be sure. We strongly recommend tracking exceptions caught from storage, either by logging them or recording them in some other way. Doing so is as simple as adding an ExceptionHandler plugin . Say you have a PSR-3 compliant logger called $logger : use Laminas\\Cache\\Psr\\CacheItemPool\\CacheItemPoolDecorator; use Laminas\\Cache\\Service\\StorageAdapterFactoryInterface; use Psr\\Container\\ContainerInterface; $cacheLogger = function (\\Exception $e) use ($logger) { $message = sprintf( '[CACHE] %s:%s %s \"%s\"', $exception-&gt;getFile(), $exception-&gt;getLine(), $exception-&gt;getCode(), $exception-&gt;getMessage() ); $logger-&gt;error($message); }; /** @var ContainerInterface $container */ $container = null; // can be any configured PSR-11 container $storageFactory = $container-&gt;get(StorageAdapterFactoryInterface::class); $storage = $storageFactory-&gt;create( 'apc', [], [ [ 'name' =&gt; 'exceptionhandler', 'options' =&gt; [ 'exception_callback' =&gt; $cacheLogger, 'throw_exceptions' =&gt; true, ], ], ] ); $pool = new CacheItemPoolDecorator($storage); Note that throw_exceptions should always be true (the default) or you will not get the correct return values from calls on the pool such as save() . Supported Data Types As per the specification , the following data types can be stored in cache: string , integer , float , boolean , null , array , object and be returned as a value with exactly the same type. Not all adapters can natively store all these types. For instance, Redis stores booleans and integers as a string. Where this is the case all values will be automatically run through serialize() on save and unserialize() on get: you do not need to use a Laminas\\Cache\\Storage\\Plugin\\Serializer plugin.","title":"PSR-6"},{"location":"v2/psr6/#psr-6","text":"Available since version 2.8.0","title":"PSR-6"},{"location":"v2/psr6/#overview","text":"The Laminas\\Cache\\Psr\\CacheItemPool\\CacheItemPoolDecorator provides a PSR-6 compliant wrapper for supported storage adapters. PSR-6 specifies a common interface to cache storage, enabling developers to switch between implementations without having to worry about any behind-the-scenes differences between them.","title":"Overview"},{"location":"v2/psr6/#quick-start","text":"To use the pool, instantiate your storage as normal, then pass it to the CacheItemPoolDecorator . use Laminas\\Cache\\Psr\\CacheItemPool\\CacheItemPoolDecorator;use Laminas\\Cache\\Service\\StorageAdapterFactoryInterface;use Psr\\Container\\ContainerInterface; /** @var ContainerInterface $container */ $container = null; // can be any configured PSR-11 container $storageFactory = $container-&gt;get(StorageAdapterFactoryInterface::class); $storage = $storageFactory-&gt;create('apc'); $pool = new CacheItemPoolDecorator($storage); // attempt to get an item from cache $item = $pool-&gt;getItem('foo'); // check whether item was found if (! $item-&gt;isHit()) { // ... // perform expensive operation to calculate $value for 'foo' // ... $item-&gt;set($value); $pool-&gt;save($item); } // use the value of the item echo $item-&gt;get(); Note that you will always get back a CacheItem object, whether it was found in cache or not: this is so false -y values like an empty string, null , or false can be stored. Always check isHit() to determine if the item was found.","title":"Quick Start"},{"location":"v2/psr6/#supported-adapters","text":"The PSR-6 specification requires that the underlying storage support time-to-live (TTL), which is set when the item is saved. For this reason the following adapters cannot be used: Dba , Filesystem , Memory and Session . The XCache adapter calculates TTLs based on the request time, not the time the item is actually persisted, which means that it also cannot be used. In addition adapters must support the Laminas\\Cache\\FlushableInterface . All the current Laminas\\Cache\\Storage\\Adapter s fulfil this requirement. Attempting to use an unsupported adapter will throw an exception implementing Psr\\Cache\\CacheException . The Laminas\\Cache\\Psr\\CacheItemPool\\CacheItemPoolDecorator adapter doesn't support driver deferred saves, so cache items are saved on destruct or on explicit commit() call.","title":"Supported Adapters"},{"location":"v2/psr6/#logging-errors","text":"The specification states : While caching is often an important part of application performance, it should never be a critical part of application functionality. Thus, an error in a cache system SHOULD NOT result in application failure. Once you've got your pool instance, almost all exceptions thrown by the storage will be caught and ignored. The only storage exceptions that bubble up implement Psr\\Cache\\InvalidArgumentException and are typically caused by invalid key errors. To be PSR-6 compliant, cache keys must not contain the following characters: {}()/\\@: . However different storage adapters may have further restrictions. Check the documentation for your particular adapter to be sure. We strongly recommend tracking exceptions caught from storage, either by logging them or recording them in some other way. Doing so is as simple as adding an ExceptionHandler plugin . Say you have a PSR-3 compliant logger called $logger : use Laminas\\Cache\\Psr\\CacheItemPool\\CacheItemPoolDecorator; use Laminas\\Cache\\Service\\StorageAdapterFactoryInterface; use Psr\\Container\\ContainerInterface; $cacheLogger = function (\\Exception $e) use ($logger) { $message = sprintf( '[CACHE] %s:%s %s \"%s\"', $exception-&gt;getFile(), $exception-&gt;getLine(), $exception-&gt;getCode(), $exception-&gt;getMessage() ); $logger-&gt;error($message); }; /** @var ContainerInterface $container */ $container = null; // can be any configured PSR-11 container $storageFactory = $container-&gt;get(StorageAdapterFactoryInterface::class); $storage = $storageFactory-&gt;create( 'apc', [], [ [ 'name' =&gt; 'exceptionhandler', 'options' =&gt; [ 'exception_callback' =&gt; $cacheLogger, 'throw_exceptions' =&gt; true, ], ], ] ); $pool = new CacheItemPoolDecorator($storage); Note that throw_exceptions should always be true (the default) or you will not get the correct return values from calls on the pool such as save() .","title":"Logging Errors"},{"location":"v2/psr6/#supported-data-types","text":"As per the specification , the following data types can be stored in cache: string , integer , float , boolean , null , array , object and be returned as a value with exactly the same type. Not all adapters can natively store all these types. For instance, Redis stores booleans and integers as a string. Where this is the case all values will be automatically run through serialize() on save and unserialize() on get: you do not need to use a Laminas\\Cache\\Storage\\Plugin\\Serializer plugin.","title":"Supported Data Types"},{"location":"v2/pattern/callback-cache/","text":"CallbackCache The callback cache pattern caches the results of arbitrary PHP callables. Quick Start use Laminas\\Cache\\Pattern\\CallbackCache; use Laminas\\Cache\\Pattern\\PatternOptions; // Or the equivalent manual instantiation: $callbackCache = new CallbackCache( $storage, new PatternOptions([ 'cache_output' =&gt; true, ]) ); Storage Adapter The $storage adapter can be any adapter which implements the StorageInterface . Check out the Pattern Quick Start -Section for a standard adapter which can be used here. Configuration Options Option Data Type Default Value Description storage string\\|array\\|Laminas\\Cache\\Storage\\StorageInterface none deprecated Adapter used for reading and writing cached data. cache_output bool true Whether or not to cache callback output. Examples Instantiating the Callback Cache Pattern use Laminas\\Cache\\Pattern\\CallbackCache; $callbackCache = new CallbackCache($storage); Available Methods In addition to the methods defined in the PatternInterface and the StorageCapableInterface , this implementation provides the following methods. namespace Laminas\\Cache\\Pattern; use Laminas\\Cache\\Exception; class CallbackCache extends AbstractStorageCapablePattern { /** * Call the specified callback or get the result from cache * * @param callable $callback A valid callback * @param array $args Callback arguments * @return mixed Result * @throws Exception\\RuntimeException if invalid cached data * @throws \\Exception */ public function call($callback, array $args = []); /** * Intercept method overloading; proxies to call() * * @param string $function Function name to call * @param array $args Function arguments * @return mixed * @throws Exception\\RuntimeException * @throws \\Exception */ public function __call($function, array $args); /** * Generate a unique key in base of a key representing the callback part * and a key representing the arguments part. * * @param callable $callback A valid callback * @param array $args Callback arguments * @return string * @throws Exception\\RuntimeException * @throws Exception\\InvalidArgumentException */ public function generateKey($callback, array $args = []); }","title":"CallbackCache"},{"location":"v2/pattern/callback-cache/#callbackcache","text":"The callback cache pattern caches the results of arbitrary PHP callables.","title":"CallbackCache"},{"location":"v2/pattern/callback-cache/#quick-start","text":"use Laminas\\Cache\\Pattern\\CallbackCache; use Laminas\\Cache\\Pattern\\PatternOptions; // Or the equivalent manual instantiation: $callbackCache = new CallbackCache( $storage, new PatternOptions([ 'cache_output' =&gt; true, ]) );","title":"Quick Start"},{"location":"v2/pattern/callback-cache/#configuration-options","text":"Option Data Type Default Value Description storage string\\|array\\|Laminas\\Cache\\Storage\\StorageInterface none deprecated Adapter used for reading and writing cached data. cache_output bool true Whether or not to cache callback output.","title":"Configuration Options"},{"location":"v2/pattern/callback-cache/#examples","text":"","title":"Examples"},{"location":"v2/pattern/callback-cache/#available-methods","text":"In addition to the methods defined in the PatternInterface and the StorageCapableInterface , this implementation provides the following methods. namespace Laminas\\Cache\\Pattern; use Laminas\\Cache\\Exception; class CallbackCache extends AbstractStorageCapablePattern { /** * Call the specified callback or get the result from cache * * @param callable $callback A valid callback * @param array $args Callback arguments * @return mixed Result * @throws Exception\\RuntimeException if invalid cached data * @throws \\Exception */ public function call($callback, array $args = []); /** * Intercept method overloading; proxies to call() * * @param string $function Function name to call * @param array $args Function arguments * @return mixed * @throws Exception\\RuntimeException * @throws \\Exception */ public function __call($function, array $args); /** * Generate a unique key in base of a key representing the callback part * and a key representing the arguments part. * * @param callable $callback A valid callback * @param array $args Callback arguments * @return string * @throws Exception\\RuntimeException * @throws Exception\\InvalidArgumentException */ public function generateKey($callback, array $args = []); }","title":"Available Methods"},{"location":"v2/pattern/capture-cache/","text":"CaptureCache The CaptureCache pattern is useful for generating static resources to return via HTTP request. When used in such a fashion, the web server needs to be configured to run a PHP script generating the requested resource so that subsequent requests for the same resource can be shipped without calling PHP again. This pattern comes with basic logic for managing generated resources. Quick Start For use with an Apache 404 handler extend the Apache configuration, e.g. .htdocs : ErrorDocument 404 /index.php And add the cache to the related application script, e.g. index.php : use Laminas\\Cache\\Pattern\\CaptureCache; use Laminas\\Cache\\Pattern\\PatternOptions; $capture = new CaptureCache( new PatternOptions([ 'public_dir' =&gt; __DIR__, ]) ); // Start capturing all output, excluding headers, and write to the public // directory: $capture-&gt;start(); // Don't forget to change the HTTP response code header('Status: 200', true, 200); // do stuff to dynamically generate output Configuration Options Option Data Type Default Value Description public_dir string none Location of the public web root directory in which to write output. index_filename string \"index.html\" The name of the index file if only a directory was requested. file_locking bool true Whether or not to lock output files when writing. file_permission int\\|false 0600 ( false on Windows) Default permissions for generated output files. dir_permission int\\|false 0700 ( false on Windows) Default permissions for generated output directories. umask int\\|false false Whether or not to umask generated output files / directories. Examples Scaling Images in the Web Root Using the following Apache 404 configuration: # .htdocs ErrorDocument 404 /index.php Use the following script: // index.php use Laminas\\Cache\\Pattern\\CaptureCache; use Laminas\\Cache\\Pattern\\PatternOptions; $capture = new CaptureCache( new PatternOptions([ 'public_dir' =&gt; __DIR__, ]) ); Available Methods In addition to the methods exposed in PatternInterface , this implementation exposes the following methods. namespace Laminas\\Cache\\Pattern; use Laminas\\Cache\\Exception; class CaptureCache extends AbstractPattern { /** * Start the cache. * * @param string $pageId Page identifier * @return void */ public function start($pageId = null); /** * Write a page to the requested path. * * @param string $content * @param null|string $pageId * @throws Exception\\LogicException */ public function set($content, $pageId = null); /** * Retrieve a generated page from the cache. * * @param null|string $pageId * @return string|null * @throws Exception\\LogicException * @throws Exception\\RuntimeException */ public function get($pageId = null); /** * Check if a cache exists for the given page. * * @param null|string $pageId * @throws Exception\\LogicException * @return bool */ public function has($pageId = null); /** * Remove a page from the cache. * * @param null|string $pageId * @throws Exception\\LogicException * @throws Exception\\RuntimeException * @return bool */ public function remove($pageId = null); /** * Clear cached pages that match the specified glob pattern. * * @param string $pattern * @throws Exception\\LogicException */ public function clearByGlob($pattern = '**'); /** * Returns the generated file name. * * @param null|string $pageId * @return string */ public function getFilename($pageId = null); }","title":"CaptureCache"},{"location":"v2/pattern/capture-cache/#capturecache","text":"The CaptureCache pattern is useful for generating static resources to return via HTTP request. When used in such a fashion, the web server needs to be configured to run a PHP script generating the requested resource so that subsequent requests for the same resource can be shipped without calling PHP again. This pattern comes with basic logic for managing generated resources.","title":"CaptureCache"},{"location":"v2/pattern/capture-cache/#quick-start","text":"For use with an Apache 404 handler extend the Apache configuration, e.g. .htdocs : ErrorDocument 404 /index.php And add the cache to the related application script, e.g. index.php : use Laminas\\Cache\\Pattern\\CaptureCache; use Laminas\\Cache\\Pattern\\PatternOptions; $capture = new CaptureCache( new PatternOptions([ 'public_dir' =&gt; __DIR__, ]) ); // Start capturing all output, excluding headers, and write to the public // directory: $capture-&gt;start(); // Don't forget to change the HTTP response code header('Status: 200', true, 200); // do stuff to dynamically generate output","title":"Quick Start"},{"location":"v2/pattern/capture-cache/#configuration-options","text":"Option Data Type Default Value Description public_dir string none Location of the public web root directory in which to write output. index_filename string \"index.html\" The name of the index file if only a directory was requested. file_locking bool true Whether or not to lock output files when writing. file_permission int\\|false 0600 ( false on Windows) Default permissions for generated output files. dir_permission int\\|false 0700 ( false on Windows) Default permissions for generated output directories. umask int\\|false false Whether or not to umask generated output files / directories.","title":"Configuration Options"},{"location":"v2/pattern/capture-cache/#examples","text":"","title":"Examples"},{"location":"v2/pattern/capture-cache/#available-methods","text":"In addition to the methods exposed in PatternInterface , this implementation exposes the following methods. namespace Laminas\\Cache\\Pattern; use Laminas\\Cache\\Exception; class CaptureCache extends AbstractPattern { /** * Start the cache. * * @param string $pageId Page identifier * @return void */ public function start($pageId = null); /** * Write a page to the requested path. * * @param string $content * @param null|string $pageId * @throws Exception\\LogicException */ public function set($content, $pageId = null); /** * Retrieve a generated page from the cache. * * @param null|string $pageId * @return string|null * @throws Exception\\LogicException * @throws Exception\\RuntimeException */ public function get($pageId = null); /** * Check if a cache exists for the given page. * * @param null|string $pageId * @throws Exception\\LogicException * @return bool */ public function has($pageId = null); /** * Remove a page from the cache. * * @param null|string $pageId * @throws Exception\\LogicException * @throws Exception\\RuntimeException * @return bool */ public function remove($pageId = null); /** * Clear cached pages that match the specified glob pattern. * * @param string $pattern * @throws Exception\\LogicException */ public function clearByGlob($pattern = '**'); /** * Returns the generated file name. * * @param null|string $pageId * @return string */ public function getFilename($pageId = null); }","title":"Available Methods"},{"location":"v2/pattern/intro/","text":"Introduction Cache patterns are configurable objects that solve known performance bottlenecks. Each should be used only in the specific situations they are designed to address. For example, you can use the CallbackCache , ObjectCache , or ClassCache patterns to cache method and function calls; to cache output generation, the OutputCache pattern could assist. All cache patterns implement Laminas\\Cache\\Pattern\\PatternInterface , and most extend the abstract class Laminas\\Cache\\Pattern\\AbstractPattern , which provides common logic. Configuration is provided via the Laminas\\Cache\\Pattern\\PatternOptions class, which can be instantiated with an associative array of options passed to the constructor. To configure a pattern object, you can provide a Laminas\\Cache\\Pattern\\PatternOptions instance to the setOptions() method, or provide your options (either as an associative array or PatternOptions instance) to the second argument of the factory. It's also possible to use a single instance of Laminas\\Cache\\Pattern\\PatternOptions and pass it to multiple pattern objects. Quick Start Pattern objects can be created by instantiating one of the Laminas\\Cache\\Pattern\\*Cache classes. Standard Storage Adapter for Documentation A cache adapter needs a storage adapter. To be able to follow the examples in the documentation, the adapter for the filesystem or the BlackHole adapter can be used, for example. $storage = new Laminas\\Cache\\Storage\\Adapter\\Filesystem(); // or $storage = new Laminas\\Cache\\Storage\\Adapter\\BlackHole(); use Laminas\\Cache\\Pattern\\CallbackCache; use Laminas\\Cache\\Pattern\\PatternOptions; $callbackCache = new CallbackCache( $storage, new PatternOptions() ); Available Methods The following methods are implemented by every cache pattern. Please read documentation of specific patterns to get more information. namespace Laminas\\Cache\\Pattern; interface PatternInterface { /** * Get all pattern options * * @return PatternOptions */ public function getOptions(); } There are cache patterns which depend on a storage. In this case, these adapters implement the StorageCapableInterface : namespace Laminas\\Cache\\Pattern; use Laminas\\Cache\\Storage\\StorageInterface; interface StorageCapableInterface extends PatternInterface { public function getStorage(): ?StorageInterface; }","title":"Introduction"},{"location":"v2/pattern/intro/#introduction","text":"Cache patterns are configurable objects that solve known performance bottlenecks. Each should be used only in the specific situations they are designed to address. For example, you can use the CallbackCache , ObjectCache , or ClassCache patterns to cache method and function calls; to cache output generation, the OutputCache pattern could assist. All cache patterns implement Laminas\\Cache\\Pattern\\PatternInterface , and most extend the abstract class Laminas\\Cache\\Pattern\\AbstractPattern , which provides common logic. Configuration is provided via the Laminas\\Cache\\Pattern\\PatternOptions class, which can be instantiated with an associative array of options passed to the constructor. To configure a pattern object, you can provide a Laminas\\Cache\\Pattern\\PatternOptions instance to the setOptions() method, or provide your options (either as an associative array or PatternOptions instance) to the second argument of the factory. It's also possible to use a single instance of Laminas\\Cache\\Pattern\\PatternOptions and pass it to multiple pattern objects.","title":"Introduction"},{"location":"v2/pattern/intro/#quick-start","text":"Pattern objects can be created by instantiating one of the Laminas\\Cache\\Pattern\\*Cache classes.","title":"Quick Start"},{"location":"v2/pattern/intro/#available-methods","text":"The following methods are implemented by every cache pattern. Please read documentation of specific patterns to get more information. namespace Laminas\\Cache\\Pattern; interface PatternInterface { /** * Get all pattern options * * @return PatternOptions */ public function getOptions(); } There are cache patterns which depend on a storage. In this case, these adapters implement the StorageCapableInterface : namespace Laminas\\Cache\\Pattern; use Laminas\\Cache\\Storage\\StorageInterface; interface StorageCapableInterface extends PatternInterface { public function getStorage(): ?StorageInterface; }","title":"Available Methods"},{"location":"v2/pattern/object-cache/","text":"ObjectCache The ObjectCache pattern is an extension to the CallbackCache pattern. It has the same methods, but instead caches output from any instance method calls or public properties. Quick Start use Laminas\\Cache\\Pattern\\ObjectCache; use Laminas\\Cache\\Pattern\\PatternOptions; use stdClass; $object = new stdClass(); $objectCache = new ObjectCache( $storage, new PatternOptions([ 'object' =&gt; $object, ]) ); Storage Adapter The $storage adapter can be any adapter which implements the StorageInterface . Check out the Pattern Quick Start -Section for a standard adapter which can be used here. Configuration Options Option Data Type Default Value Description storage string\\|array\\|Laminas\\Cache\\Storage\\StorageInterface none deprecated Adapter used for reading and writing cached data. object object none The object for which to cache method calls. object_key null\\|string Class name of object Hopefully unique! cache_output bool true Whether or not to cache method output. cache_by_default bool true Cache all method calls by default. object_cache_methods array [] List of methods to cache (if cache_by_default is disabled). object_non_cache_methods array [] List of methods to blacklist (if cache_by_default is enabled). object_cache_magic_properties bool false Whether or not to cache properties exposed by method overloading. Examples Caching a Filter use Laminas\\Cache\\Pattern\\ObjectCache; use Laminas\\Cache\\Pattern\\PatternOptions; $filter = new \\Laminas\\Filter\\RealPath(); $cachedFilter = new ObjectCache( $storage, new PatternOptions([ 'object' =&gt; $filter, 'object_key' =&gt; 'RealpathFilter', // The realpath filter doesn't output anything // so the output don't need to be caught and cached 'cache_output' =&gt; false, ]) ); $path = $cachedFilter-&gt;call(\"filter\", ['/www/var/path/../../mypath']); // OR $path = $cachedFilter-&gt;filter('/www/var/path/../../mypath'); Available Methods In addition to the methods defined in PatternInterface and the StorageCapableInterface , this implementation defines the following methods. namespace Laminas\\Cache\\Pattern; use Laminas\\Cache\\Exception; class ObjectCache extends CallbackCache { /** * Call and cache a class method * * @param string $method Method name to call * @param array $args Method arguments * @return mixed * @throws Exception\\RuntimeException * @throws \\Exception */ public function call($method, array $args = []); /** * Method overloading: proxies to call(). * * @param string $method Method name to call * @param array $args Method arguments * @return mixed * @throws Exception\\RuntimeException * @throws \\Exception */ public function __call($method, array $args); /** * Generate a unique key in base of a key representing the callback part * and a key representing the arguments part. * * @param string $method The method * @param array $args Callback arguments * @return string * @throws Exception\\RuntimeException */ public function generateKey($method, array $args = []); /** * Property overloading: write data to a named property. * * NOTE: * Magic properties will be cached too if the option cacheMagicProperties * is enabled and the property doesn't exist in real. If so it calls __set * and removes cached data of previous __get and __isset calls. * * @param string $name * @param mixed $value * @return void * @see http://php.net/manual/language.oop5.overloading.php#language.oop5.overloading.members */ public function __set($name, $value); /** * Property overloading: read data from a named property. * * NOTE: * Magic properties will be cached too if the option cacheMagicProperties * is enabled and the property doesn't exist in real. If so it calls __get. * * @param string $name * @return mixed * @see http://php.net/manual/language.oop5.overloading.php#language.oop5.overloading.members */ public function __get($name); /** * Property overloading: check if a named property exists. * * NOTE: * Magic properties will be cached too if the option cacheMagicProperties * is enabled and the property doesn't exist in real. If so it calls __get. * * @param string $name * @return bool * @see http://php.net/manual/language.oop5.overloading.php#language.oop5.overloading.members */ public function __isset($name); /** * Property overloading: unset a named property. * * NOTE: * Magic properties will be cached too if the option cacheMagicProperties * is enabled and the property doesn't exist in real. If so it removes * previous cached __isset and __get calls. * * @param string $name * @return void * @see http://php.net/manual/language.oop5.overloading.php#language.oop5.overloading.members */ public function __unset($name); /** * Handle casting to string * * @return string * @see http://php.net/manual/language.oop5.magic.php#language.oop5.magic.tostring */ public function __toString(); /** * Intercept and cache invokable usage. * * @return mixed * @see http://php.net/manual/language.oop5.magic.php#language.oop5.magic.invoke */ public function __invoke(); }","title":"ObjectCache"},{"location":"v2/pattern/object-cache/#objectcache","text":"The ObjectCache pattern is an extension to the CallbackCache pattern. It has the same methods, but instead caches output from any instance method calls or public properties.","title":"ObjectCache"},{"location":"v2/pattern/object-cache/#quick-start","text":"use Laminas\\Cache\\Pattern\\ObjectCache; use Laminas\\Cache\\Pattern\\PatternOptions; use stdClass; $object = new stdClass(); $objectCache = new ObjectCache( $storage, new PatternOptions([ 'object' =&gt; $object, ]) );","title":"Quick Start"},{"location":"v2/pattern/object-cache/#configuration-options","text":"Option Data Type Default Value Description storage string\\|array\\|Laminas\\Cache\\Storage\\StorageInterface none deprecated Adapter used for reading and writing cached data. object object none The object for which to cache method calls. object_key null\\|string Class name of object Hopefully unique! cache_output bool true Whether or not to cache method output. cache_by_default bool true Cache all method calls by default. object_cache_methods array [] List of methods to cache (if cache_by_default is disabled). object_non_cache_methods array [] List of methods to blacklist (if cache_by_default is enabled). object_cache_magic_properties bool false Whether or not to cache properties exposed by method overloading.","title":"Configuration Options"},{"location":"v2/pattern/object-cache/#examples","text":"","title":"Examples"},{"location":"v2/pattern/object-cache/#available-methods","text":"In addition to the methods defined in PatternInterface and the StorageCapableInterface , this implementation defines the following methods. namespace Laminas\\Cache\\Pattern; use Laminas\\Cache\\Exception; class ObjectCache extends CallbackCache { /** * Call and cache a class method * * @param string $method Method name to call * @param array $args Method arguments * @return mixed * @throws Exception\\RuntimeException * @throws \\Exception */ public function call($method, array $args = []); /** * Method overloading: proxies to call(). * * @param string $method Method name to call * @param array $args Method arguments * @return mixed * @throws Exception\\RuntimeException * @throws \\Exception */ public function __call($method, array $args); /** * Generate a unique key in base of a key representing the callback part * and a key representing the arguments part. * * @param string $method The method * @param array $args Callback arguments * @return string * @throws Exception\\RuntimeException */ public function generateKey($method, array $args = []); /** * Property overloading: write data to a named property. * * NOTE: * Magic properties will be cached too if the option cacheMagicProperties * is enabled and the property doesn't exist in real. If so it calls __set * and removes cached data of previous __get and __isset calls. * * @param string $name * @param mixed $value * @return void * @see http://php.net/manual/language.oop5.overloading.php#language.oop5.overloading.members */ public function __set($name, $value); /** * Property overloading: read data from a named property. * * NOTE: * Magic properties will be cached too if the option cacheMagicProperties * is enabled and the property doesn't exist in real. If so it calls __get. * * @param string $name * @return mixed * @see http://php.net/manual/language.oop5.overloading.php#language.oop5.overloading.members */ public function __get($name); /** * Property overloading: check if a named property exists. * * NOTE: * Magic properties will be cached too if the option cacheMagicProperties * is enabled and the property doesn't exist in real. If so it calls __get. * * @param string $name * @return bool * @see http://php.net/manual/language.oop5.overloading.php#language.oop5.overloading.members */ public function __isset($name); /** * Property overloading: unset a named property. * * NOTE: * Magic properties will be cached too if the option cacheMagicProperties * is enabled and the property doesn't exist in real. If so it removes * previous cached __isset and __get calls. * * @param string $name * @return void * @see http://php.net/manual/language.oop5.overloading.php#language.oop5.overloading.members */ public function __unset($name); /** * Handle casting to string * * @return string * @see http://php.net/manual/language.oop5.magic.php#language.oop5.magic.tostring */ public function __toString(); /** * Intercept and cache invokable usage. * * @return mixed * @see http://php.net/manual/language.oop5.magic.php#language.oop5.magic.invoke */ public function __invoke(); }","title":"Available Methods"},{"location":"v2/pattern/output-cache/","text":"OutputCache The OutputCache pattern caches output between calls to start() and end() . Quick Start use Laminas\\Cache\\Pattern\\OutputCache; use Laminas\\Cache\\Pattern\\PatternOptions; $outputCache = new OutputCache( $storage, new PatternOptions() ); Storage Adapter The $storage adapter can be any adapter which implements the StorageInterface . Check out the Pattern Quick Start -Section for a standard adapter which can be used here. Configuration Options Option Data Type Default Value Description storage string\\|array\\|Laminas\\Cache\\Storage\\StorageInterface none deprecated Adapter used for reading and writing cached data. Examples Caching a View Script use Laminas\\Cache\\Pattern\\OutputCache; use Laminas\\Cache\\Pattern\\PatternOptions; $outputCache = new OutputCache( $storage, new PatternOptions() ); $outputCache-&gt;start('mySimpleViewScript'); include '/path/to/view/script.phtml'; $outputCache-&gt;end(); Available Methods In addition to the methods defined in PatternInterface and StorageCapableInterface , this implementation defines the following methods. namespace Laminas\\Cache\\Pattern; use Laminas\\Cache\\Exception; class OutputCache extends AbstractStorageCapablePattern { /** * If there is a cached item with the given key, display its data, and * return true. Otherwise, start buffering output until end() is called, or * the script ends. * * @param string $key Key * @throws Exception\\MissingKeyException if key is missing * @return bool */ public function start($key); /** * Stop buffering output, write buffered data to the cache using the key * provided to start(), and display the buffer. * * @throws Exception\\RuntimeException if output cache not started or buffering not active * @return bool TRUE on success, FALSE on failure writing to cache */ public function end(); }","title":"OutputCache"},{"location":"v2/pattern/output-cache/#outputcache","text":"The OutputCache pattern caches output between calls to start() and end() .","title":"OutputCache"},{"location":"v2/pattern/output-cache/#quick-start","text":"use Laminas\\Cache\\Pattern\\OutputCache; use Laminas\\Cache\\Pattern\\PatternOptions; $outputCache = new OutputCache( $storage, new PatternOptions() );","title":"Quick Start"},{"location":"v2/pattern/output-cache/#configuration-options","text":"Option Data Type Default Value Description storage string\\|array\\|Laminas\\Cache\\Storage\\StorageInterface none deprecated Adapter used for reading and writing cached data.","title":"Configuration Options"},{"location":"v2/pattern/output-cache/#examples","text":"","title":"Examples"},{"location":"v2/pattern/output-cache/#available-methods","text":"In addition to the methods defined in PatternInterface and StorageCapableInterface , this implementation defines the following methods. namespace Laminas\\Cache\\Pattern; use Laminas\\Cache\\Exception; class OutputCache extends AbstractStorageCapablePattern { /** * If there is a cached item with the given key, display its data, and * return true. Otherwise, start buffering output until end() is called, or * the script ends. * * @param string $key Key * @throws Exception\\MissingKeyException if key is missing * @return bool */ public function start($key); /** * Stop buffering output, write buffered data to the cache using the key * provided to start(), and display the buffer. * * @throws Exception\\RuntimeException if output cache not started or buffering not active * @return bool TRUE on success, FALSE on failure writing to cache */ public function end(); }","title":"Available Methods"},{"location":"v2/storage/adapter/","text":"Adapters Storage adapters are wrappers for real storage resources such as memory or the filesystem, using the well known adapter pattern. They come with tons of methods to read, write, and modify stored items, and to get information about stored items and the storage. All adapters implement Laminas\\Cache\\Storage\\StorageInterface , and most extend Laminas\\Cache\\Storage\\Adapter\\AbstractAdapter , which provides a foundation of common logic. Configuration is handled by either Laminas\\Cache\\Storage\\Adapter\\AdapterOptions , or an adapter-specific options class if it exists. You may pass the options instance to the class at instantiation, via the setOptions() method, or, alternately, pass an associative array of options in either place (internally, these are then passed to an options class instance). Alternately, you can pass associative array to the Laminas\\Cache\\Service\\StorageAdapterFactoryInterface::create method. Quick Start Caching adapters can either be created from the provided Laminas\\Cache\\Service\\StorageAdapterFactoryInterface , or by instantiating one of the Laminas\\Cache\\Storage\\Adapter\\* classes. To make life easier, the Laminas\\Cache\\Service\\StorageAdapterFactoryInterface comes with a create() method to create an adapter and all requested plugins at once. use Laminas\\Cache\\Service\\StorageAdapterFactoryInterface; use Laminas\\Cache\\Service\\StoragePluginFactoryInterface; use Psr\\Container\\ContainerInterface; /** @var ContainerInterface $container */ $container = null; // can be any configured PSR-11 container /** @var StorageAdapterFactoryInterface $storageFactory */ $storageFactory = $container-&gt;get(StorageAdapterFactoryInterface::class); // Via factory: $cache = $storageFactory-&gt;create( 'apc', ['ttl' =&gt; 3600], [ [ 'name' =&gt; 'exception_handler', 'options' =&gt; [ 'throw_exceptions' =&gt; false, ], ], ] ); // Via array configuration: $cache = $storageFactory-&gt;createFromArrayConfiguration([ 'adapter' =&gt; 'apc', 'options' =&gt; ['ttl' =&gt; 3600], 'plugins' =&gt; [ [ 'name' =&gt; 'exception_handler', 'options' =&gt; [ 'throw_exceptions' =&gt; false, ], ], ], ]); // Alternately, create the adapter and plugin separately: $cache = $storageFactory-&gt;create('apc', ['ttl' =&gt; 3600]); $pluginFactory = $container-&gt;get(StoragePluginFactoryInterface::class); $plugin = $pluginFactory-&gt;create('exception_handler', [ 'throw_exceptions' =&gt; false, ]); $cache-&gt;addPlugin($plugin); // Or do it completely manually: $cache = new Laminas\\Cache\\Storage\\Adapter\\Apc(); $cache-&gt;getOptions()-&gt;setTtl(3600); $plugin = new Laminas\\Cache\\Storage\\Plugin\\ExceptionHandler(); $plugin-&gt;getOptions()-&gt;setThrowExceptions(false); $cache-&gt;addPlugin($plugin); Many Methods throw Exceptions Because many caching operations throw an exception on error, you need to catch them. You can do so manually, or you can use the plugin Laminas\\Cache\\Storage\\Plugin\\ExceptionHandler with throw_exceptions set to false to automatically catch them. You can also define an exception_callback to log exceptions. Basic Configuration Options The following configuration options are defined by Laminas\\Cache\\Storage\\Adapter\\AdapterOptions and are available for every supported adapter. Adapter-specific configuration options are described on adapter level below. Option Data Type Default Value Description ttl integer 0 Time to live namespace string “laminascache” The “namespace” in which cache items will live key_pattern null | string|null` Pattern against which to validate cache keys readable boolean true Enable/Disable reading data from cache writable boolean true Enable/Disable writing data to cache StorageInterface Laminas\\Cache\\Storage\\StorageInterface is the basic interface implemented by all storage adapters. namespace Laminas\\Cache\\Storage; use Traversable; interface StorageInterface { /** * Set options. * * @param array|Traversable|Adapter\\AdapterOptions $options * @return StorageInterface Fluent interface */ public function setOptions($options); /** * Get options * * @return Adapter\\AdapterOptions */ public function getOptions(); /* reading */ /** * Get an item. * * @param string $key * @param bool $success * @param mixed $casToken * @return mixed Data on success, null on failure * @throws \\Laminas\\Cache\\Exception\\ExceptionInterface */ public function getItem($key, &amp; $success = null, &amp; $casToken = null); /** * Get multiple items. * * @param array $keys * @return array Associative array of keys and values * @throws \\Laminas\\Cache\\Exception\\ExceptionInterface */ public function getItems(array $keys); /** * Test if an item exists. * * @param string $key * @return bool * @throws \\Laminas\\Cache\\Exception\\ExceptionInterface */ public function hasItem($key); /** * Test multiple items. * * @param array $keys * @return array Array of found keys * @throws \\Laminas\\Cache\\Exception\\ExceptionInterface */ public function hasItems(array $keys); /** * Get metadata of an item. * * @param string $key * @return array|bool Metadata on success, false on failure * @throws \\Laminas\\Cache\\Exception\\ExceptionInterface */ public function getMetadata($key); /** * Get multiple metadata * * @param array $keys * @return array Associative array of keys and metadata * @throws \\Laminas\\Cache\\Exception\\ExceptionInterface */ public function getMetadatas(array $keys); /* writing */ /** * Store an item. * * @param string $key * @param mixed $value * @return bool * @throws \\Laminas\\Cache\\Exception\\ExceptionInterface */ public function setItem($key, $value); /** * Store multiple items. * * @param array $keyValuePairs * @return array Array of not stored keys * @throws \\Laminas\\Cache\\Exception\\ExceptionInterface */ public function setItems(array $keyValuePairs); /** * Add an item. * * @param string $key * @param mixed $value * @return bool * @throws \\Laminas\\Cache\\Exception\\ExceptionInterface */ public function addItem($key, $value); /** * Add multiple items. * * @param array $keyValuePairs * @return array Array of not stored keys * @throws \\Laminas\\Cache\\Exception\\ExceptionInterface */ public function addItems(array $keyValuePairs); /** * Replace an existing item. * * @param string $key * @param mixed $value * @return bool * @throws \\Laminas\\Cache\\Exception\\ExceptionInterface */ public function replaceItem($key, $value); /** * Replace multiple existing items. * * @param array $keyValuePairs * @return array Array of not stored keys * @throws \\Laminas\\Cache\\Exception\\ExceptionInterface */ public function replaceItems(array $keyValuePairs); /** * Set an item only if token matches * * It uses the token received from getItem() to check if the item has * changed before overwriting it. * * @param mixed $token * @param string $key * @param mixed $value * @return bool * @throws \\Laminas\\Cache\\Exception\\ExceptionInterface * @see getItem() * @see setItem() */ public function checkAndSetItem($token, $key, $value); /** * Reset lifetime of an item * * @param string $key * @return bool * @throws \\Laminas\\Cache\\Exception\\ExceptionInterface */ public function touchItem($key); /** * Reset lifetime of multiple items. * * @param array $keys * @return array Array of not updated keys * @throws \\Laminas\\Cache\\Exception\\ExceptionInterface */ public function touchItems(array $keys); /** * Remove an item. * * @param string $key * @return bool * @throws \\Laminas\\Cache\\Exception\\ExceptionInterface */ public function removeItem($key); /** * Remove multiple items. * * @param array $keys * @return array Array of not removed keys * @throws \\Laminas\\Cache\\Exception\\ExceptionInterface */ public function removeItems(array $keys); /** * Increment an item. * * @param string $key * @param int $value * @return int|bool The new value on success, false on failure * @throws \\Laminas\\Cache\\Exception\\ExceptionInterface */ public function incrementItem($key, $value); /** * Increment multiple items. * * @param array $keyValuePairs * @return array Associative array of keys and new values * @throws \\Laminas\\Cache\\Exception\\ExceptionInterface */ public function incrementItems(array $keyValuePairs); /** * Decrement an item. * * @param string $key * @param int $value * @return int|bool The new value on success, false on failure * @throws \\Laminas\\Cache\\Exception\\ExceptionInterface */ public function decrementItem($key, $value); /** * Decrement multiple items. * * @param array $keyValuePairs * @return array Associative array of keys and new values * @throws \\Laminas\\Cache\\Exception\\ExceptionInterface */ public function decrementItems(array $keyValuePairs); /* status */ /** * Capabilities of this storage * * @return Capabilities */ public function getCapabilities(); } AvailableSpaceCapableInterface Laminas\\Cache\\Storage\\AvailableSpaceCapableInterface implements a method to allow retrieving the current available space remaining in storage. namespace Laminas\\Cache\\Storage; interface AvailableSpaceCapableInterface { /** * Get available space in bytes * * @return int|float */ public function getAvailableSpace(); } TotalSpaceCapableInterface Laminas\\Cache\\Storage\\TotalSpaceCapableInterface implements a method to allow retrieving the total storage space. namespace Laminas\\Cache\\Storage; interface TotalSpaceCapableInterface { /** * Get total space in bytes * * @return int|float */ public function getTotalSpace(); } ClearByNamespaceInterface Laminas\\Cache\\Storage\\ClearByNamespaceInterface implements a method to allow clearing all cached items within a given namespace. namespace Laminas\\Cache\\Storage; interface ClearByNamespaceInterface { /** * Remove items of given namespace * * @param string $namespace * @return bool */ public function clearByNamespace($namespace); } ClearByPrefixInterface Laminas\\Cache\\Storage\\ClearByPrefixInterface implements a method to allow clearing all cached items that have a given prefix (within the currently configured namespace). namespace Laminas\\Cache\\Storage; interface ClearByPrefixInterface { /** * Remove items matching given prefix * * @param string $prefix * @return bool */ public function clearByPrefix($prefix); } ClearExpiredInterface Laminas\\Cache\\Storage\\ClearExpiredInterface implements a method to allow clearing all expired items (within the current configured namespace). namespace Laminas\\Cache\\Storage; interface ClearExpiredInterface { /** * Remove expired items * * @return bool */ public function clearExpired(); } FlushableInterface Laminas\\Cache\\Storage\\FlushableInterface implements a method for flushing the entire cache storage. namespace Laminas\\Cache\\Storage; interface FlushableInterface { /** * Flush the whole storage * * @return bool */ public function flush(); } IterableInterface Laminas\\Cache\\Storage\\IterableInterface implements a method for retrieving an iterator of all items in storage. It extends IteratorAggregate , so it's possible to directly iterate over the storage implementations that implement this interface using foreach . namespace Laminas\\Cache\\Storage; use IteratorAggregate; /** * * @method IteratorInterface getIterator() Get the storage iterator */ interface IterableInterface extends IteratorAggregate { /** * @return \\Traversable */ public function getIterator(); } OptimizableInterface Laminas\\Cache\\Storage\\OptimizableInterface implements a method for running optimization processes on the storage adapter. namespace Laminas\\Cache\\Storage; interface OptimizableInterface { /** * Optimize the storage * * @return bool */ public function optimize(); } TaggableInterface Laminas\\Cache\\Storage\\TaggableInterface implements methods for tagging items, and cleaning (expiring) items matching tags. namespace Laminas\\Cache\\Storage; interface TaggableInterface { /** * Set tags to an item by given key. * An empty array will remove all tags. * * @param string $key * @param string[] $tags * @return bool */ public function setTags($key, array $tags); /** * Get tags of an item by given key * * @param string $key * @return string[]|FALSE */ public function getTags($key); /** * Remove items matching given tags. * * If $disjunction only one of the given tags must match * else all given tags must match. * * @param string[] $tags * @param bool $disjunction * @return bool */ public function clearByTags(array $tags, $disjunction = false); } Apc Adapter Laminas\\Cache\\Storage\\Adapter\\Apc stores cache items in shared memory through the PHP extension APC (Alternative PHP Cache). This adapter implements the following interfaces: Laminas\\Cache\\Storage\\StorageInterface Laminas\\Cache\\Storage\\AvailableSpaceCapableInterface Laminas\\Cache\\Storage\\ClearByNamespaceInterface Laminas\\Cache\\Storage\\ClearByPrefixInterface Laminas\\Cache\\Storage\\FlushableInterface Laminas\\Cache\\Storage\\IterableInterface Laminas\\Cache\\Storage\\TotalSpaceCapableInterface Capabilities Capability Value supportedDatatypes null , bool , int , float , string , array (serialized), object (serialized) supportedMetadata internal_key, atime, ctime, mtime, rtime, size, hits, ttl minTtl 1 maxTtl 0 staticTtl true ttlPrecision 1 useRequestTime value of apc.use_request_time from php.ini lockOnExpire 0 maxKeyLength 5182 namespaceIsPrefix true namespaceSeparator Option value of namespace_separator Adapter Specific Options Name Data Type Default Value Description namespace_separator string \":\" A separator for the namespace and prefix. BlackHole Adapter Laminas\\Cache\\Storage\\Adapter\\BlackHole does not store any cache items. This adapter is useful to bypass caching behavior. This might be the case in development mode or unit testing. This adapter implements the following interfaces: Laminas\\Cache\\Storage\\StorageInterface Laminas\\Cache\\Storage\\AvailableSpaceCapableInterface Laminas\\Cache\\Storage\\ClearByNamespaceInterface Laminas\\Cache\\Storage\\ClearByPrefixInterface Laminas\\Cache\\Storage\\ClearExpiredInterface Laminas\\Cache\\Storage\\FlushableInterface Laminas\\Cache\\Storage\\IterableInterface Laminas\\Cache\\Storage\\OptimizableInterface Laminas\\Cache\\Storage\\TaggableInterface Laminas\\Cache\\Storage\\TotalSpaceCapableInterface Capabilities Capability Value supportedDatatypes null , bool , int , float , string , array , object supportedMetadata none minTtl 0 or 1, depending on psr option. maxTtl 0 staticTtl false or true , depending on psr option ttlPrecision 1 useRequestTime false lockOnExpire 0 maxKeyLength -1 namespaceIsPrefix true namespaceSeparator none Adapter Specific Options Name Data Type Default Value Description psr bool false Flag to specify whether the adapter should be compatible with CacheItemPoolDecorator or SimpleCacheDecorator Deprecation Notice The psr option was introduce to provide non-BC compatible way to use the BlackHole adapter with the PSR-6 and PSR-16 decorator. Ignore this option if this adapter is not used in combination with these decorators. This option is already flagged as internal and thus will be removed in laminas/laminas-cache-storage-adapter-blackhole 2.0. Dba Adapter Laminas\\Cache\\Storage\\Adapter\\Dba stores cache items into dbm -like databases using the PHP extension dba . This adapter implements the following interfaces: Laminas\\Cache\\Storage\\StorageInterface Laminas\\Cache\\Storage\\AvailableSpaceCapableInterface Laminas\\Cache\\Storage\\ClearByNamespaceInterface Laminas\\Cache\\Storage\\ClearByPrefixInterface Laminas\\Cache\\Storage\\FlushableInterface Laminas\\Cache\\Storage\\IterableInterface Laminas\\Cache\\Storage\\OptimizableInterface Laminas\\Cache\\Storage\\TotalSpaceCapableInterface Capabilities Capability Value supportedDatatypes string , null =&gt; string , boolean =&gt; string , integer =&gt; string , double =&gt; string supportedMetadata none minTtl 0 maxKeyLength 0 namespaceIsPrefix true namespaceSeparator Option value of namespace_separator Adapter Specific Options Name Data Type Default Value Description namespace_separator string \":\" A separator for the namespace and prefix. pathname string \"\" Pathname to the database file. mode string \"c\" The mode with which to open the database; please read dba_open for more information. handler string \"flatfile\" The name of the handler which shall be used for accessing the database. This adapter doesn't support automatic expiry Because this adapter doesn't support automatic expiry, it's very important to clean outdated items periodically! Filesystem Adapter Laminas\\Cache\\Storage\\Adapter\\Filesystem stores cache items on the filesystem. This adapter implements the following interfaces: Laminas\\Cache\\Storage\\StorageInterface Laminas\\Cache\\Storage\\AvailableSpaceCapableInterface Laminas\\Cache\\Storage\\ClearByNamespaceInterface Laminas\\Cache\\Storage\\ClearByPrefixInterface Laminas\\Cache\\Storage\\ClearExpiredInterface Laminas\\Cache\\Storage\\FlushableInterface Laminas\\Cache\\Storage\\IterableInterface Laminas\\Cache\\Storage\\OptimizableInterface Laminas\\Cache\\Storage\\TaggableInterface Laminas\\Cache\\Storage\\TotalSpaceCapableInterface Capabilities Capability Value supportedDatatypes string , null =&gt; string , boolean =&gt; string , integer =&gt; string , double =&gt; string supportedMetadata mtime, filespec, atime, ctime minTtl 1 maxTtl 0 staticTtl false ttlPrecision 1 useRequestTime false lockOnExpire 0 maxKeyLength 251 namespaceIsPrefix true namespaceSeparator Option value of namespace_separator Adapter Specific Options Name Data Type Default Value Description namespace_separator string \":\" A separator for the namespace and prefix cache_dir string \"\" Directory to store cache files. clear_stat_cache boolean true Call clearstatcache() enabled? dir_level integer 1 Defines how much sub-directories should be created. dir_permission integer false 0700 Set explicit permission on creating new directories. file_locking boolean true Lock files on writing. file_permission integer false 0600 Set explicit permission on creating new files. key_pattern string /^[a-z0-9_\\+\\-]*$/Di Validate key against pattern. no_atime boolean true Don’t get ‘fileatime’ as ‘atime’ on metadata. no_ctime boolean true Don’t get ‘filectime’ as ‘ctime’ on metadata. umask integer\\|false false Use umask to set file and directory permissions. suffix string dat Suffix for cache files tag_suffix string tag Suffix for tag files Note: the suffix and tag_suffix options will be escaped in order to be safe for glob operations. Memcached Adapter Laminas\\Cache\\Storage\\Adapter\\Memcached stores cache items over the memcached protocol, using the PHP extension memcached , based on Libmemcached . This adapter implements the following interfaces: Laminas\\Cache\\Storage\\StorageInterface Laminas\\Cache\\Storage\\AvailableSpaceCapableInterface Laminas\\Cache\\Storage\\FlushableInterface Laminas\\Cache\\Storage\\TotalSpaceCapableInterface Capabilities Capability Value supportedDatatypes null , boolean , integer , double , string , array (serialized), object (serialized) supportedMetadata none minTtl 1 maxTtl 0 staticTtl true ttlPrecision 1 useRequestTime false lockOnExpire 0 maxKeyLength 255 namespaceIsPrefix true namespaceSeparator none Adapter Specific Options Name Data Type Default Value Description servers array [] List of servers in the format [] = [string host, integer port] lib_options array [] Associative array of Libmemcached options where the array key is the option name (without the prefix OPT_ ) or the constant value. The array value is the option value. Please read the memcached setOption() page for more information Redis Adapter Laminas\\Cache\\Storage\\Adapter\\Redis stores cache items over the Redis protocol using the PHP extension PhpRedis . This adapter implements the following interfaces: Laminas\\Cache\\Storage\\ClearByNamespaceInterface Laminas\\Cache\\Storage\\ClearByPrefixInterface Laminas\\Cache\\Storage\\FlushableInterface Laminas\\Cache\\Storage\\TotalSpaceCapableInterface Capabilities Capability Value supportedDatatypes string , array (serialized), object (serialized) supportedMetadata ttl (Redis v2+) minTtl 1 maxTtl 0 staticTtl true ttlPrecision 1 useRequestTime false lockOnExpire 0 maxKeyLength 512000000 (in Redis v3+, 255 otherwise) namespaceIsPrefix true namespaceSeparator none Adapter Specific Options Name Data Type Default Value Description database integer 0 Set database identifier. lib_options array [] Associative array of Redis options where the array key is the option name. namespace_separator string \":\" A separator for the namespace and prefix. password string \"\" Set password. persistent_id string Set persistent id (name of the connection, leave blank to not use a persistent connection). resource_manager string \"\" Set the Redis resource manager to use server string\\|array \"\" See below. server can be described as any of the following: Uri /path/to/sock.sock Associative array: ['host' =&gt; &lt;host&gt;[, 'port' =&gt; &lt;port&gt;[, 'timeout' =&gt; &lt;timeout&gt;]]] List: [&lt;host&gt;[, &lt;port&gt;, [, &lt;timeout&gt;]]] RedisCluster Adapter Laminas\\Cache\\Storage\\Adapter\\RedisCluster stores cache items over the Redis cluster protocol using the PHP extension PhpRedis . This adapter implements the following interfaces: Laminas\\Cache\\Storage\\ClearByNamespaceInterface Laminas\\Cache\\Storage\\ClearByPrefixInterface Laminas\\Cache\\Storage\\FlushableInterface Capabilities Capability Value supportedDatatypes string , array (serialized), object (serialized) supportedMetadata ttl (Redis v2+) minTtl 1 maxTtl 0 staticTtl true ttlPrecision 1 useRequestTime false lockOnExpire 0 maxKeyLength 512000000 (in Redis v3+, 255 otherwise) namespaceIsPrefix true namespaceSeparator none Adapter Specific Options Name Data Type Default Value Description lib_options array [] Associative array of Redis options where the array key is the options constant value (see RedisCluster::OPT_* constants for details). namespace_separator string \":\" A separator for the namespace and prefix. password string \"\" Password to authenticate with Redis server name string \"\" Name to determine configuration from php.ini ( MUST NOT be combined with seeds ) seeds array [] List of strings containing &lt;hostname&gt;:&lt;port&gt; ( MUST NOT be combined with name ) timeout float 1.0 Timeout for commands, see PhpRedis timeouts documentation for more background. read_timeout float 2.0 Read timeout for commands, see PhpRedis timeouts documentation for more background. persistent bool false Flag to specify whether to create a persistent connection or not version string \"\" The Redis server version. MUST be specified in a Semantic Versioning 2.0.0 format. This information is used to determine some features/capabilities without opening a connection to the server. Memory Adapter The Laminas\\Cache\\Storage\\Adapter\\Memory stores items in-memory in the current process only. This adapter implements the following interfaces: Laminas\\Cache\\Storage\\StorageInterface Laminas\\Cache\\Storage\\AvailableSpaceCapableInterface Laminas\\Cache\\Storage\\ClearByPrefixInterface Laminas\\Cache\\Storage\\ClearExpiredInterface Laminas\\Cache\\Storage\\FlushableInterface Laminas\\Cache\\Storage\\IterableInterface Laminas\\Cache\\Storage\\TaggableInterface Laminas\\Cache\\Storage\\TotalSpaceCapableInterface Capabilities Capability Value supportedDatatypes string , null , boolean , integer , double , array , object , resource supportedMetadata mtime minTtl 1 maxTtl Value of PHP_INT_MAX staticTtl false ttlPrecision 0.05 useRequestTime false lockOnExpire 0 maxKeyLength 0 namespaceIsPrefix false Adapter Specific Options Name Data Type Default Value Description memory_limit string\\|integer 50% of memory_limit INI value Limit of how much memory can PHP allocate to allow store items. Memory Limit The adapter has the following behavior with regards to the memory limit: If the consumed memory exceeds the limit provided, an OutOfSpaceException is thrown. A number less the or equal to zero disables the memory limit. When a value is provided for the memory limit, the value is measured in bytes. Shorthand notation may also be provided. Current process only All stored items will be lost on termination of the script. For web-facing requests, this typically means the cache is volatile. MongoDB Adapter Laminas\\Cache\\Storage\\Adapter\\MongoDB stores cache items using MongoDB, via either the PHP extension mongo , or a MongoDB polyfill library, such as Mongofill . ext-mongodb If you are using the mongodb extension (vs the mongo extension), you will need to use the ExtMongoDb adapter instead. This adapter implements the following interfaces: Laminas\\Cache\\Storage\\FlushableInterface Capabilities Capability Value supportedDatatypes string , null , boolean , integer , double , array supportedMetadata _id minTtl 0 maxTtl 0 staticTtl true ttlPrecision 1 useRequestTime false lockOnExpire 0 maxKeyLength 255 namespaceIsPrefix true namespaceSeparator Option value of namespace_separator Adapter Specific Options Name Data Type Default Value Description lib_option array Associative array of options where the array key is the option name. namespace_separator string \":\" A separator for the namespace and prefix. Available keys for lib_option include: Key Default Description server mongodb://localhost:27017 The MongoDB server connection string (see the MongoClient docs ). database laminas Name of the database to use; MongoDB will create this database if it does not exist. collection cache Name of the collection to use; MongoDB will create this collection if it does not exist. connectionOptions ['fsync' =&gt; false, 'journal' =&gt; true] Associative array of options to pass to MongoClient (see the MongoClient docs ). driverOptions [] Associative array of driver options to pass to MongoClient (see the MongoClient docs ). ExtMongoDB Adapter Available since version 2.8.0 Laminas\\Cache\\Storage\\Adapter\\ExtMongoDB stores cache items using the mongodb extension, and requires that the MongoDB PHP Client library is also installed. You can install the client library using the following: $ composer require mongodb/mongodb ext-mongo If you are using the mongo extension (vs the mongodb extension), you will need to use the MongoDb adapter instead. This adapter implements the following interfaces: Laminas\\Cache\\Storage\\FlushableInterface Capabilities Capability Value supportedDatatypes string , null , boolean , integer , double , array supportedMetadata _id minTtl 0 maxTtl 0 staticTtl true ttlPrecision 1 useRequestTime false lockOnExpire 0 maxKeyLength 255 namespaceIsPrefix true namespaceSeparator Option value of namespace_separator Adapter Specific Options Name Data Type Default Value Description lib_option array Associative array of options where the array key is the option name. namespace_separator string \":\" A separator for the namespace and prefix. Available keys for lib_option include: Key Default Description server mongodb://localhost:27017 The MongoDB server connection string (see the MongoDB\\Client docs ). database laminas Name of the database to use; MongoDB will create this database if it does not exist. collection cache Name of the collection to use; MongoDB will create this collection if it does not exist. connectionOptions ['fsync' =&gt; false, 'journal' =&gt; true] Associative array of URI options (such as authentication credentials or query string parameters) to pass to MongoDB\\\\Client (see the MongoDB\\Client docs ). driverOptions [] Associative array of driver options to pass to MongoDB\\\\Client (see the MongoDB\\Client docs ). WinCache Adapter Laminas\\Cache\\Storage\\Adapter\\WinCache stores cache items into shared memory through the PHP extension WinCache . This adapter implements the following interfaces: Laminas\\Cache\\Storage\\StorageInterface Laminas\\Cache\\Storage\\AvailableSpaceCapableInterface Laminas\\Cache\\Storage\\FlushableInterface Laminas\\Cache\\Storage\\TotalSpaceCapableInterface Capabilities Capability Value supportedDatatypes null , boolean , integer , double , string , array (serialized), object (serialized) supportedMetadata internal_key, ttl, hits, size minTtl 1 maxTtl 0 staticTtl true ttlPrecision 1 useRequestTime apc.use_request_time php.ini value. lockOnExpire 0 namespaceIsPrefix true namespaceSeparator Option value of namespace_separator Adapter Specific Options Name Data Type Default Value Description namespace_separator string \":\" A separator for the namespace and prefix. XCache Adapter Laminas\\Cache\\Storage\\Adapter\\XCache stores cache items into shared memory through the PHP extension XCache . This adapter implements the following interfaces: Laminas\\Cache\\Storage\\StorageInterface Laminas\\Cache\\Storage\\AvailableSpaceCapableInterface Laminas\\Cache\\Storage\\ClearByNamespaceInterface Laminas\\Cache\\Storage\\ClearByPrefixInterface Laminas\\Cache\\Storage\\FlushableInterface Laminas\\Cache\\Storage\\IterableInterface Laminas\\Cache\\Storage\\TotalSpaceCapableInterface Capabilities Capability Value supportedDatatypes boolean , integer , double , string , array (serialized), object (serialized) supportedMetadata internal_key, size, refcount, hits, ctime, atime, hvalue minTtl 1 maxTtl xcache.var_maxttl php.ini value staticTtl true ttlPrecision 1 useRequestTime true lockOnExpire 0 maxKeyLength 5182 namespaceIsPrefix true namespaceSeparator Option value of namespace_separator Adapter Specific Options Name Data Type Default Value Description namespace_separator string \":\" A separator for the namespace and prefix. admin_auth boolean false Enable admin authentication by configuration options admin_user and admin_pass . This makes XCache administration functions accessible without the need of HTTP-Authentication if xcache.admin.enable_auth is enabled. admin_user string \"\" The username of xcache.admin.user . admin_pass string \"\" The password of xcache.admin.pass in plain text. ZendServerDisk Adapter Laminas\\Cache\\Storage\\Adapter\\ZendServerDisk stores cache items on the filesystem using the Zend Server Data Caching API . This adapter implements the following interfaces: Laminas\\Cache\\Storage\\StorageInterface Laminas\\Cache\\Storage\\AvailableSpaceCapableInterface Laminas\\Cache\\Storage\\ClearByNamespaceInterface Laminas\\Cache\\Storage\\FlushableInterface Laminas\\Cache\\Storage\\TotalSpaceCapableInterface Capabilities Capability Value supportedDatatypes null , boolean , integer , double , string , array (serialized), object (serialized) supportedMetadata none minTtl 1 maxTtl 0 maxKeyLength 0 staticTtl true ttlPrecision 1 useRequestTime false lockOnExpire if 'zend_datacache.lock_on_expire' is enabled 120 else 0 namespaceIsPrefix true namespaceSeparator :: ZendServerShm Adapter Laminas\\Cache\\Storage\\Adapter\\ZendServerShm stores cache items in shared memory through the Zend Server Data Caching API . This adapter implements the following interfaces: Laminas\\Cache\\Storage\\StorageInterface Laminas\\Cache\\Storage\\ClearByNamespaceInterface Laminas\\Cache\\Storage\\FlushableInterface Laminas\\Cache\\Storage\\TotalSpaceCapableInterface Capabilities Capability Value supportedDatatypes null , boolean , integer , double , string , array (serialized), object (serialized) supportedMetadata none minTtl 1 maxTtl 0 maxKeyLength 0 staticTtl true ttlPrecision 1 useRequestTime false lockOnExpire if 'zend_datacache.lock_on_expire' is enabled 120 else 0 namespaceIsPrefix true namespaceSeparator :: Examples Basic Usage use Laminas\\Cache\\Service\\StorageAdapterFactoryInterface; use Psr\\Container\\ContainerInterface; /** @var ContainerInterface $container */ $container = null; // can be any configured PSR-11 container /** @var StorageAdapterFactoryInterface $storageFactory */ $storageFactory = $container-&gt;get(StorageAdapterFactoryInterface::class); $cache = $storageFactory-&gt;create( 'filesystem', [], [ // Don't throw exceptions on cache errors [ 'name' =&gt; 'exception_handler', 'options' =&gt; [ 'throw_exceptions' =&gt; false ], ], ] ); $key = 'unique-cache-key'; $result = $cache-&gt;getItem($key, $success); if (! $success) { $result = doExpensiveStuff(); $cache-&gt;setItem($key, $result); } Get multiple Rows from a Database use Laminas\\Cache\\Service\\StorageAdapterFactoryInterface; use Psr\\Container\\ContainerInterface; /** @var ContainerInterface $container */ $container = null; // can be any configured PSR-11 container /** @var StorageAdapterFactoryInterface $storageFactory */ $storageFactory = $container-&gt;get(StorageAdapterFactoryInterface::class); // Instantiate the cache instance using a namespace for the same type of items $cache = $storageFactory-&gt;create( 'filesystem', // With a namespace, we can indicate the same type of items, // so we can simply use the database id as the cache key [ 'namespace' =&gt; 'dbtable', ], [ // Don't throw exceptions on cache errors [ 'name' =&gt; 'exception_handler', 'options' =&gt; [ 'throw_exceptions' =&gt; false, ], ], // We store database rows on filesystem so we need to serialize them [ 'name' =&gt; 'Serializer', ], ] ); // Load two rows from cache if possible $ids = [1, 2]; $results = $cache-&gt;getItems($ids); if (count($results) &lt; count($ids)) { // Load rows from db if loading from cache failed $missingIds = array_diff($ids, array_keys($results)); $missingResults = []; $query = 'SELECT * FROM dbtable WHERE id IN (' . implode(',', $missingIds) . ')'; foreach ($pdo-&gt;query($query, PDO::FETCH_ASSOC) as $row) { $missingResults[ $row['id'] ] = $row; } // Update cache items of the loaded rows from db $cache-&gt;setItems($missingResults); // merge results from cache and db $results = array_merge($results, $missingResults); }","title":"Adapters"},{"location":"v2/storage/adapter/#adapters","text":"Storage adapters are wrappers for real storage resources such as memory or the filesystem, using the well known adapter pattern. They come with tons of methods to read, write, and modify stored items, and to get information about stored items and the storage. All adapters implement Laminas\\Cache\\Storage\\StorageInterface , and most extend Laminas\\Cache\\Storage\\Adapter\\AbstractAdapter , which provides a foundation of common logic. Configuration is handled by either Laminas\\Cache\\Storage\\Adapter\\AdapterOptions , or an adapter-specific options class if it exists. You may pass the options instance to the class at instantiation, via the setOptions() method, or, alternately, pass an associative array of options in either place (internally, these are then passed to an options class instance). Alternately, you can pass associative array to the Laminas\\Cache\\Service\\StorageAdapterFactoryInterface::create method.","title":"Adapters"},{"location":"v2/storage/adapter/#quick-start","text":"Caching adapters can either be created from the provided Laminas\\Cache\\Service\\StorageAdapterFactoryInterface , or by instantiating one of the Laminas\\Cache\\Storage\\Adapter\\* classes. To make life easier, the Laminas\\Cache\\Service\\StorageAdapterFactoryInterface comes with a create() method to create an adapter and all requested plugins at once. use Laminas\\Cache\\Service\\StorageAdapterFactoryInterface; use Laminas\\Cache\\Service\\StoragePluginFactoryInterface; use Psr\\Container\\ContainerInterface; /** @var ContainerInterface $container */ $container = null; // can be any configured PSR-11 container /** @var StorageAdapterFactoryInterface $storageFactory */ $storageFactory = $container-&gt;get(StorageAdapterFactoryInterface::class); // Via factory: $cache = $storageFactory-&gt;create( 'apc', ['ttl' =&gt; 3600], [ [ 'name' =&gt; 'exception_handler', 'options' =&gt; [ 'throw_exceptions' =&gt; false, ], ], ] ); // Via array configuration: $cache = $storageFactory-&gt;createFromArrayConfiguration([ 'adapter' =&gt; 'apc', 'options' =&gt; ['ttl' =&gt; 3600], 'plugins' =&gt; [ [ 'name' =&gt; 'exception_handler', 'options' =&gt; [ 'throw_exceptions' =&gt; false, ], ], ], ]); // Alternately, create the adapter and plugin separately: $cache = $storageFactory-&gt;create('apc', ['ttl' =&gt; 3600]); $pluginFactory = $container-&gt;get(StoragePluginFactoryInterface::class); $plugin = $pluginFactory-&gt;create('exception_handler', [ 'throw_exceptions' =&gt; false, ]); $cache-&gt;addPlugin($plugin); // Or do it completely manually: $cache = new Laminas\\Cache\\Storage\\Adapter\\Apc(); $cache-&gt;getOptions()-&gt;setTtl(3600); $plugin = new Laminas\\Cache\\Storage\\Plugin\\ExceptionHandler(); $plugin-&gt;getOptions()-&gt;setThrowExceptions(false); $cache-&gt;addPlugin($plugin);","title":"Quick Start"},{"location":"v2/storage/adapter/#basic-configuration-options","text":"The following configuration options are defined by Laminas\\Cache\\Storage\\Adapter\\AdapterOptions and are available for every supported adapter. Adapter-specific configuration options are described on adapter level below. Option Data Type Default Value Description ttl integer 0 Time to live namespace string “laminascache” The “namespace” in which cache items will live key_pattern null | string|null` Pattern against which to validate cache keys readable boolean true Enable/Disable reading data from cache writable boolean true Enable/Disable writing data to cache","title":"Basic Configuration Options"},{"location":"v2/storage/adapter/#storageinterface","text":"Laminas\\Cache\\Storage\\StorageInterface is the basic interface implemented by all storage adapters. namespace Laminas\\Cache\\Storage; use Traversable; interface StorageInterface { /** * Set options. * * @param array|Traversable|Adapter\\AdapterOptions $options * @return StorageInterface Fluent interface */ public function setOptions($options); /** * Get options * * @return Adapter\\AdapterOptions */ public function getOptions(); /* reading */ /** * Get an item. * * @param string $key * @param bool $success * @param mixed $casToken * @return mixed Data on success, null on failure * @throws \\Laminas\\Cache\\Exception\\ExceptionInterface */ public function getItem($key, &amp; $success = null, &amp; $casToken = null); /** * Get multiple items. * * @param array $keys * @return array Associative array of keys and values * @throws \\Laminas\\Cache\\Exception\\ExceptionInterface */ public function getItems(array $keys); /** * Test if an item exists. * * @param string $key * @return bool * @throws \\Laminas\\Cache\\Exception\\ExceptionInterface */ public function hasItem($key); /** * Test multiple items. * * @param array $keys * @return array Array of found keys * @throws \\Laminas\\Cache\\Exception\\ExceptionInterface */ public function hasItems(array $keys); /** * Get metadata of an item. * * @param string $key * @return array|bool Metadata on success, false on failure * @throws \\Laminas\\Cache\\Exception\\ExceptionInterface */ public function getMetadata($key); /** * Get multiple metadata * * @param array $keys * @return array Associative array of keys and metadata * @throws \\Laminas\\Cache\\Exception\\ExceptionInterface */ public function getMetadatas(array $keys); /* writing */ /** * Store an item. * * @param string $key * @param mixed $value * @return bool * @throws \\Laminas\\Cache\\Exception\\ExceptionInterface */ public function setItem($key, $value); /** * Store multiple items. * * @param array $keyValuePairs * @return array Array of not stored keys * @throws \\Laminas\\Cache\\Exception\\ExceptionInterface */ public function setItems(array $keyValuePairs); /** * Add an item. * * @param string $key * @param mixed $value * @return bool * @throws \\Laminas\\Cache\\Exception\\ExceptionInterface */ public function addItem($key, $value); /** * Add multiple items. * * @param array $keyValuePairs * @return array Array of not stored keys * @throws \\Laminas\\Cache\\Exception\\ExceptionInterface */ public function addItems(array $keyValuePairs); /** * Replace an existing item. * * @param string $key * @param mixed $value * @return bool * @throws \\Laminas\\Cache\\Exception\\ExceptionInterface */ public function replaceItem($key, $value); /** * Replace multiple existing items. * * @param array $keyValuePairs * @return array Array of not stored keys * @throws \\Laminas\\Cache\\Exception\\ExceptionInterface */ public function replaceItems(array $keyValuePairs); /** * Set an item only if token matches * * It uses the token received from getItem() to check if the item has * changed before overwriting it. * * @param mixed $token * @param string $key * @param mixed $value * @return bool * @throws \\Laminas\\Cache\\Exception\\ExceptionInterface * @see getItem() * @see setItem() */ public function checkAndSetItem($token, $key, $value); /** * Reset lifetime of an item * * @param string $key * @return bool * @throws \\Laminas\\Cache\\Exception\\ExceptionInterface */ public function touchItem($key); /** * Reset lifetime of multiple items. * * @param array $keys * @return array Array of not updated keys * @throws \\Laminas\\Cache\\Exception\\ExceptionInterface */ public function touchItems(array $keys); /** * Remove an item. * * @param string $key * @return bool * @throws \\Laminas\\Cache\\Exception\\ExceptionInterface */ public function removeItem($key); /** * Remove multiple items. * * @param array $keys * @return array Array of not removed keys * @throws \\Laminas\\Cache\\Exception\\ExceptionInterface */ public function removeItems(array $keys); /** * Increment an item. * * @param string $key * @param int $value * @return int|bool The new value on success, false on failure * @throws \\Laminas\\Cache\\Exception\\ExceptionInterface */ public function incrementItem($key, $value); /** * Increment multiple items. * * @param array $keyValuePairs * @return array Associative array of keys and new values * @throws \\Laminas\\Cache\\Exception\\ExceptionInterface */ public function incrementItems(array $keyValuePairs); /** * Decrement an item. * * @param string $key * @param int $value * @return int|bool The new value on success, false on failure * @throws \\Laminas\\Cache\\Exception\\ExceptionInterface */ public function decrementItem($key, $value); /** * Decrement multiple items. * * @param array $keyValuePairs * @return array Associative array of keys and new values * @throws \\Laminas\\Cache\\Exception\\ExceptionInterface */ public function decrementItems(array $keyValuePairs); /* status */ /** * Capabilities of this storage * * @return Capabilities */ public function getCapabilities(); }","title":"StorageInterface"},{"location":"v2/storage/adapter/#availablespacecapableinterface","text":"Laminas\\Cache\\Storage\\AvailableSpaceCapableInterface implements a method to allow retrieving the current available space remaining in storage. namespace Laminas\\Cache\\Storage; interface AvailableSpaceCapableInterface { /** * Get available space in bytes * * @return int|float */ public function getAvailableSpace(); }","title":"AvailableSpaceCapableInterface"},{"location":"v2/storage/adapter/#totalspacecapableinterface","text":"Laminas\\Cache\\Storage\\TotalSpaceCapableInterface implements a method to allow retrieving the total storage space. namespace Laminas\\Cache\\Storage; interface TotalSpaceCapableInterface { /** * Get total space in bytes * * @return int|float */ public function getTotalSpace(); }","title":"TotalSpaceCapableInterface"},{"location":"v2/storage/adapter/#clearbynamespaceinterface","text":"Laminas\\Cache\\Storage\\ClearByNamespaceInterface implements a method to allow clearing all cached items within a given namespace. namespace Laminas\\Cache\\Storage; interface ClearByNamespaceInterface { /** * Remove items of given namespace * * @param string $namespace * @return bool */ public function clearByNamespace($namespace); }","title":"ClearByNamespaceInterface"},{"location":"v2/storage/adapter/#clearbyprefixinterface","text":"Laminas\\Cache\\Storage\\ClearByPrefixInterface implements a method to allow clearing all cached items that have a given prefix (within the currently configured namespace). namespace Laminas\\Cache\\Storage; interface ClearByPrefixInterface { /** * Remove items matching given prefix * * @param string $prefix * @return bool */ public function clearByPrefix($prefix); }","title":"ClearByPrefixInterface"},{"location":"v2/storage/adapter/#clearexpiredinterface","text":"Laminas\\Cache\\Storage\\ClearExpiredInterface implements a method to allow clearing all expired items (within the current configured namespace). namespace Laminas\\Cache\\Storage; interface ClearExpiredInterface { /** * Remove expired items * * @return bool */ public function clearExpired(); }","title":"ClearExpiredInterface"},{"location":"v2/storage/adapter/#flushableinterface","text":"Laminas\\Cache\\Storage\\FlushableInterface implements a method for flushing the entire cache storage. namespace Laminas\\Cache\\Storage; interface FlushableInterface { /** * Flush the whole storage * * @return bool */ public function flush(); }","title":"FlushableInterface"},{"location":"v2/storage/adapter/#iterableinterface","text":"Laminas\\Cache\\Storage\\IterableInterface implements a method for retrieving an iterator of all items in storage. It extends IteratorAggregate , so it's possible to directly iterate over the storage implementations that implement this interface using foreach . namespace Laminas\\Cache\\Storage; use IteratorAggregate; /** * * @method IteratorInterface getIterator() Get the storage iterator */ interface IterableInterface extends IteratorAggregate { /** * @return \\Traversable */ public function getIterator(); }","title":"IterableInterface"},{"location":"v2/storage/adapter/#optimizableinterface","text":"Laminas\\Cache\\Storage\\OptimizableInterface implements a method for running optimization processes on the storage adapter. namespace Laminas\\Cache\\Storage; interface OptimizableInterface { /** * Optimize the storage * * @return bool */ public function optimize(); }","title":"OptimizableInterface"},{"location":"v2/storage/adapter/#taggableinterface","text":"Laminas\\Cache\\Storage\\TaggableInterface implements methods for tagging items, and cleaning (expiring) items matching tags. namespace Laminas\\Cache\\Storage; interface TaggableInterface { /** * Set tags to an item by given key. * An empty array will remove all tags. * * @param string $key * @param string[] $tags * @return bool */ public function setTags($key, array $tags); /** * Get tags of an item by given key * * @param string $key * @return string[]|FALSE */ public function getTags($key); /** * Remove items matching given tags. * * If $disjunction only one of the given tags must match * else all given tags must match. * * @param string[] $tags * @param bool $disjunction * @return bool */ public function clearByTags(array $tags, $disjunction = false); }","title":"TaggableInterface"},{"location":"v2/storage/adapter/#apc-adapter","text":"Laminas\\Cache\\Storage\\Adapter\\Apc stores cache items in shared memory through the PHP extension APC (Alternative PHP Cache). This adapter implements the following interfaces: Laminas\\Cache\\Storage\\StorageInterface Laminas\\Cache\\Storage\\AvailableSpaceCapableInterface Laminas\\Cache\\Storage\\ClearByNamespaceInterface Laminas\\Cache\\Storage\\ClearByPrefixInterface Laminas\\Cache\\Storage\\FlushableInterface Laminas\\Cache\\Storage\\IterableInterface Laminas\\Cache\\Storage\\TotalSpaceCapableInterface","title":"Apc Adapter"},{"location":"v2/storage/adapter/#blackhole-adapter","text":"Laminas\\Cache\\Storage\\Adapter\\BlackHole does not store any cache items. This adapter is useful to bypass caching behavior. This might be the case in development mode or unit testing. This adapter implements the following interfaces: Laminas\\Cache\\Storage\\StorageInterface Laminas\\Cache\\Storage\\AvailableSpaceCapableInterface Laminas\\Cache\\Storage\\ClearByNamespaceInterface Laminas\\Cache\\Storage\\ClearByPrefixInterface Laminas\\Cache\\Storage\\ClearExpiredInterface Laminas\\Cache\\Storage\\FlushableInterface Laminas\\Cache\\Storage\\IterableInterface Laminas\\Cache\\Storage\\OptimizableInterface Laminas\\Cache\\Storage\\TaggableInterface Laminas\\Cache\\Storage\\TotalSpaceCapableInterface","title":"BlackHole Adapter"},{"location":"v2/storage/adapter/#dba-adapter","text":"Laminas\\Cache\\Storage\\Adapter\\Dba stores cache items into dbm -like databases using the PHP extension dba . This adapter implements the following interfaces: Laminas\\Cache\\Storage\\StorageInterface Laminas\\Cache\\Storage\\AvailableSpaceCapableInterface Laminas\\Cache\\Storage\\ClearByNamespaceInterface Laminas\\Cache\\Storage\\ClearByPrefixInterface Laminas\\Cache\\Storage\\FlushableInterface Laminas\\Cache\\Storage\\IterableInterface Laminas\\Cache\\Storage\\OptimizableInterface Laminas\\Cache\\Storage\\TotalSpaceCapableInterface","title":"Dba Adapter"},{"location":"v2/storage/adapter/#filesystem-adapter","text":"Laminas\\Cache\\Storage\\Adapter\\Filesystem stores cache items on the filesystem. This adapter implements the following interfaces: Laminas\\Cache\\Storage\\StorageInterface Laminas\\Cache\\Storage\\AvailableSpaceCapableInterface Laminas\\Cache\\Storage\\ClearByNamespaceInterface Laminas\\Cache\\Storage\\ClearByPrefixInterface Laminas\\Cache\\Storage\\ClearExpiredInterface Laminas\\Cache\\Storage\\FlushableInterface Laminas\\Cache\\Storage\\IterableInterface Laminas\\Cache\\Storage\\OptimizableInterface Laminas\\Cache\\Storage\\TaggableInterface Laminas\\Cache\\Storage\\TotalSpaceCapableInterface","title":"Filesystem Adapter"},{"location":"v2/storage/adapter/#memcached-adapter","text":"Laminas\\Cache\\Storage\\Adapter\\Memcached stores cache items over the memcached protocol, using the PHP extension memcached , based on Libmemcached . This adapter implements the following interfaces: Laminas\\Cache\\Storage\\StorageInterface Laminas\\Cache\\Storage\\AvailableSpaceCapableInterface Laminas\\Cache\\Storage\\FlushableInterface Laminas\\Cache\\Storage\\TotalSpaceCapableInterface","title":"Memcached Adapter"},{"location":"v2/storage/adapter/#redis-adapter","text":"Laminas\\Cache\\Storage\\Adapter\\Redis stores cache items over the Redis protocol using the PHP extension PhpRedis . This adapter implements the following interfaces: Laminas\\Cache\\Storage\\ClearByNamespaceInterface Laminas\\Cache\\Storage\\ClearByPrefixInterface Laminas\\Cache\\Storage\\FlushableInterface Laminas\\Cache\\Storage\\TotalSpaceCapableInterface","title":"Redis Adapter"},{"location":"v2/storage/adapter/#rediscluster-adapter","text":"Laminas\\Cache\\Storage\\Adapter\\RedisCluster stores cache items over the Redis cluster protocol using the PHP extension PhpRedis . This adapter implements the following interfaces: Laminas\\Cache\\Storage\\ClearByNamespaceInterface Laminas\\Cache\\Storage\\ClearByPrefixInterface Laminas\\Cache\\Storage\\FlushableInterface","title":"RedisCluster Adapter"},{"location":"v2/storage/adapter/#memory-adapter","text":"The Laminas\\Cache\\Storage\\Adapter\\Memory stores items in-memory in the current process only. This adapter implements the following interfaces: Laminas\\Cache\\Storage\\StorageInterface Laminas\\Cache\\Storage\\AvailableSpaceCapableInterface Laminas\\Cache\\Storage\\ClearByPrefixInterface Laminas\\Cache\\Storage\\ClearExpiredInterface Laminas\\Cache\\Storage\\FlushableInterface Laminas\\Cache\\Storage\\IterableInterface Laminas\\Cache\\Storage\\TaggableInterface Laminas\\Cache\\Storage\\TotalSpaceCapableInterface","title":"Memory Adapter"},{"location":"v2/storage/adapter/#mongodb-adapter","text":"Laminas\\Cache\\Storage\\Adapter\\MongoDB stores cache items using MongoDB, via either the PHP extension mongo , or a MongoDB polyfill library, such as Mongofill .","title":"MongoDB Adapter"},{"location":"v2/storage/adapter/#extmongodb-adapter","text":"Available since version 2.8.0 Laminas\\Cache\\Storage\\Adapter\\ExtMongoDB stores cache items using the mongodb extension, and requires that the MongoDB PHP Client library is also installed. You can install the client library using the following: $ composer require mongodb/mongodb","title":"ExtMongoDB Adapter"},{"location":"v2/storage/adapter/#wincache-adapter","text":"Laminas\\Cache\\Storage\\Adapter\\WinCache stores cache items into shared memory through the PHP extension WinCache . This adapter implements the following interfaces: Laminas\\Cache\\Storage\\StorageInterface Laminas\\Cache\\Storage\\AvailableSpaceCapableInterface Laminas\\Cache\\Storage\\FlushableInterface Laminas\\Cache\\Storage\\TotalSpaceCapableInterface","title":"WinCache Adapter"},{"location":"v2/storage/adapter/#xcache-adapter","text":"Laminas\\Cache\\Storage\\Adapter\\XCache stores cache items into shared memory through the PHP extension XCache . This adapter implements the following interfaces: Laminas\\Cache\\Storage\\StorageInterface Laminas\\Cache\\Storage\\AvailableSpaceCapableInterface Laminas\\Cache\\Storage\\ClearByNamespaceInterface Laminas\\Cache\\Storage\\ClearByPrefixInterface Laminas\\Cache\\Storage\\FlushableInterface Laminas\\Cache\\Storage\\IterableInterface Laminas\\Cache\\Storage\\TotalSpaceCapableInterface","title":"XCache Adapter"},{"location":"v2/storage/adapter/#zendserverdisk-adapter","text":"Laminas\\Cache\\Storage\\Adapter\\ZendServerDisk stores cache items on the filesystem using the Zend Server Data Caching API . This adapter implements the following interfaces: Laminas\\Cache\\Storage\\StorageInterface Laminas\\Cache\\Storage\\AvailableSpaceCapableInterface Laminas\\Cache\\Storage\\ClearByNamespaceInterface Laminas\\Cache\\Storage\\FlushableInterface Laminas\\Cache\\Storage\\TotalSpaceCapableInterface","title":"ZendServerDisk Adapter"},{"location":"v2/storage/adapter/#zendservershm-adapter","text":"Laminas\\Cache\\Storage\\Adapter\\ZendServerShm stores cache items in shared memory through the Zend Server Data Caching API . This adapter implements the following interfaces: Laminas\\Cache\\Storage\\StorageInterface Laminas\\Cache\\Storage\\ClearByNamespaceInterface Laminas\\Cache\\Storage\\FlushableInterface Laminas\\Cache\\Storage\\TotalSpaceCapableInterface","title":"ZendServerShm Adapter"},{"location":"v2/storage/adapter/#examples","text":"","title":"Examples"},{"location":"v2/storage/capabilities/","text":"Storage Capabilities Storage capabilities describe how a storage adapter works, and which features it supports. To get capabilities of a storage adapter, you can use the method getCapabilities() , but only the storage adapter and its plugins have permissions to change them. Because capabilities are mutable, you can subscribe to the \"change\" event to get notifications; see the examples for details. If you are writing your own plugin or adapter, you can also change capabilities because you have access to the marker object and can create your own marker to instantiate a new instance of Laminas\\Cache\\Storage\\Capabilities . Available Methods namespace Laminas\\Cache\\Storage; use ArrayObject; use stdClass; use Laminas\\Cache\\Exception; use Laminas\\EventManager\\EventsCapableInterface; class Capabilities { /** * Constructor * * @param StorageInterface $storage * @param stdClass $marker * @param array $capabilities * @param null|Capabilities $baseCapabilities */ public function __construct( StorageInterface $storage, stdClass $marker, array $capabilities = [], Capabilities $baseCapabilities = null ); /** * Get the storage adapter * * @return StorageInterface */ public function getAdapter(); /** * Get supported datatypes * * @return array */ public function getSupportedDatatypes(); /** * Set supported datatypes * * @param stdClass $marker * @param array $datatypes * @throws Exception\\InvalidArgumentException * @return Capabilities Fluent interface */ public function setSupportedDatatypes(stdClass $marker, array $datatypes); /** * Get supported metadata * * @return array */ public function getSupportedMetadata(); /** * Set supported metadata * * @param stdClass $marker * @param string[] $metadata * @throws Exception\\InvalidArgumentException * @return Capabilities Fluent interface */ public function setSupportedMetadata(stdClass $marker, array $metadata); /** * Get minimum supported time-to-live * * @return int 0 means items never expire */ public function getMinTtl(); /** * Set minimum supported time-to-live * * @param stdClass $marker * @param int $minTtl * @throws Exception\\InvalidArgumentException * @return Capabilities Fluent interface */ public function setMinTtl(stdClass $marker, $minTtl); /** * Get maximum supported time-to-live * * @return int 0 means infinite */ public function getMaxTtl(); /** * Set maximum supported time-to-live * * @param stdClass $marker * @param int $maxTtl * @throws Exception\\InvalidArgumentException * @return Capabilities Fluent interface */ public function setMaxTtl(stdClass $marker, $maxTtl); /** * Is the time-to-live handled static (on write) * or dynamic (on read) * * @return bool */ public function getStaticTtl(); /** * Set if the time-to-live handled static (on write) or dynamic (on read) * * @param stdClass $marker * @param bool $flag * @return Capabilities Fluent interface */ public function setStaticTtl(stdClass $marker, $flag); /** * Get time-to-live precision * * @return float */ public function getTtlPrecision(); /** * Set time-to-live precision * * @param stdClass $marker * @param float $ttlPrecision * @throws Exception\\InvalidArgumentException * @return Capabilities Fluent interface */ public function setTtlPrecision(stdClass $marker, $ttlPrecision); /** * Get use request time * * @return bool */ public function getUseRequestTime(); /** * Set use request time * * @param stdClass $marker * @param bool $flag * @return Capabilities Fluent interface */ public function setUseRequestTime(stdClass $marker, $flag); /** * Get \"lock-on-expire\" support in seconds. * * @return int 0 = Expired items will never be retrieved * &gt;0 = Time in seconds an expired item could be retrieved * -1 = Expired items could be retrieved forever */ public function getLockOnExpire() { return $this-&gt;getCapability('lockOnExpire', 0); } /** * Set \"lock-on-expire\" support in seconds. * * @param stdClass $marker * @param int $timeout * @return Capabilities Fluent interface */ public function setLockOnExpire(stdClass $marker, $timeout) { return $this-&gt;setCapability($marker, 'lockOnExpire', (int) $timeout); } /** * Get maximum key length * * @return int -1 means unknown, 0 means infinite */ public function getMaxKeyLength(); /** * Set maximum key length * * @param stdClass $marker * @param int $maxKeyLength * @throws Exception\\InvalidArgumentException * @return Capabilities Fluent interface */ public function setMaxKeyLength(stdClass $marker, $maxKeyLength); /** * Get if namespace support is implemented as prefix * * @return bool */ public function getNamespaceIsPrefix(); /** * Set if namespace support is implemented as prefix * * @param stdClass $marker * @param bool $flag * @return Capabilities Fluent interface */ public function setNamespaceIsPrefix(stdClass $marker, $flag); /** * Get namespace separator if namespace is implemented as prefix * * @return string */ public function getNamespaceSeparator(); /** * Set the namespace separator if namespace is implemented as prefix * * @param stdClass $marker * @param string $separator * @return Capabilities Fluent interface */ public function setNamespaceSeparator(stdClass $marker, $separator); } Examples Get Storage Capabilities and do specific Stuff based on them use Laminas\\Cache\\Service\\StorageAdapterFactoryInterface; use Psr\\Container\\ContainerInterface; /** @var ContainerInterface $container */ $container = null; // can be any configured PSR-11 container /** @var StorageAdapterFactoryInterface $storageFactory */ $storageFactory = $container-&gt;get(StorageAdapterFactoryInterface::class); $cache = $storageFactory-&gt;create('filesystem'); $supportedDatatypes = $cache-&gt;getCapabilities()-&gt;getSupportedDatatypes(); // now you can run specific stuff in base of supported feature if ($supportedDatatypes['object']) { $cache-&gt;set($key, $object); } else { $cache-&gt;set($key, serialize($object)); } Listen to the change Event use Laminas\\Cache\\Service\\StorageAdapterFactoryInterface; use Psr\\Container\\ContainerInterface; /** @var ContainerInterface $container */ $container = null; // can be any configured PSR-11 container /** @var StorageAdapterFactoryInterface $storageFactory */ $storageFactory = $container-&gt;get(StorageAdapterFactoryInterface::class); $cache = $storageFactory-&gt;create('filesystem', [ 'no_atime' =&gt; false, ]); // Catching capability changes $cache-&gt;getEventManager()-&gt;attach('capability', function($event) { echo count($event-&gt;getParams()) . ' capabilities changed'; }); // change option which changes capabilities $cache-&gt;getOptions()-&gt;setNoATime(true);","title":"Capabilities"},{"location":"v2/storage/capabilities/#storage-capabilities","text":"Storage capabilities describe how a storage adapter works, and which features it supports. To get capabilities of a storage adapter, you can use the method getCapabilities() , but only the storage adapter and its plugins have permissions to change them. Because capabilities are mutable, you can subscribe to the \"change\" event to get notifications; see the examples for details. If you are writing your own plugin or adapter, you can also change capabilities because you have access to the marker object and can create your own marker to instantiate a new instance of Laminas\\Cache\\Storage\\Capabilities .","title":"Storage Capabilities"},{"location":"v2/storage/capabilities/#available-methods","text":"namespace Laminas\\Cache\\Storage; use ArrayObject; use stdClass; use Laminas\\Cache\\Exception; use Laminas\\EventManager\\EventsCapableInterface; class Capabilities { /** * Constructor * * @param StorageInterface $storage * @param stdClass $marker * @param array $capabilities * @param null|Capabilities $baseCapabilities */ public function __construct( StorageInterface $storage, stdClass $marker, array $capabilities = [], Capabilities $baseCapabilities = null ); /** * Get the storage adapter * * @return StorageInterface */ public function getAdapter(); /** * Get supported datatypes * * @return array */ public function getSupportedDatatypes(); /** * Set supported datatypes * * @param stdClass $marker * @param array $datatypes * @throws Exception\\InvalidArgumentException * @return Capabilities Fluent interface */ public function setSupportedDatatypes(stdClass $marker, array $datatypes); /** * Get supported metadata * * @return array */ public function getSupportedMetadata(); /** * Set supported metadata * * @param stdClass $marker * @param string[] $metadata * @throws Exception\\InvalidArgumentException * @return Capabilities Fluent interface */ public function setSupportedMetadata(stdClass $marker, array $metadata); /** * Get minimum supported time-to-live * * @return int 0 means items never expire */ public function getMinTtl(); /** * Set minimum supported time-to-live * * @param stdClass $marker * @param int $minTtl * @throws Exception\\InvalidArgumentException * @return Capabilities Fluent interface */ public function setMinTtl(stdClass $marker, $minTtl); /** * Get maximum supported time-to-live * * @return int 0 means infinite */ public function getMaxTtl(); /** * Set maximum supported time-to-live * * @param stdClass $marker * @param int $maxTtl * @throws Exception\\InvalidArgumentException * @return Capabilities Fluent interface */ public function setMaxTtl(stdClass $marker, $maxTtl); /** * Is the time-to-live handled static (on write) * or dynamic (on read) * * @return bool */ public function getStaticTtl(); /** * Set if the time-to-live handled static (on write) or dynamic (on read) * * @param stdClass $marker * @param bool $flag * @return Capabilities Fluent interface */ public function setStaticTtl(stdClass $marker, $flag); /** * Get time-to-live precision * * @return float */ public function getTtlPrecision(); /** * Set time-to-live precision * * @param stdClass $marker * @param float $ttlPrecision * @throws Exception\\InvalidArgumentException * @return Capabilities Fluent interface */ public function setTtlPrecision(stdClass $marker, $ttlPrecision); /** * Get use request time * * @return bool */ public function getUseRequestTime(); /** * Set use request time * * @param stdClass $marker * @param bool $flag * @return Capabilities Fluent interface */ public function setUseRequestTime(stdClass $marker, $flag); /** * Get \"lock-on-expire\" support in seconds. * * @return int 0 = Expired items will never be retrieved * &gt;0 = Time in seconds an expired item could be retrieved * -1 = Expired items could be retrieved forever */ public function getLockOnExpire() { return $this-&gt;getCapability('lockOnExpire', 0); } /** * Set \"lock-on-expire\" support in seconds. * * @param stdClass $marker * @param int $timeout * @return Capabilities Fluent interface */ public function setLockOnExpire(stdClass $marker, $timeout) { return $this-&gt;setCapability($marker, 'lockOnExpire', (int) $timeout); } /** * Get maximum key length * * @return int -1 means unknown, 0 means infinite */ public function getMaxKeyLength(); /** * Set maximum key length * * @param stdClass $marker * @param int $maxKeyLength * @throws Exception\\InvalidArgumentException * @return Capabilities Fluent interface */ public function setMaxKeyLength(stdClass $marker, $maxKeyLength); /** * Get if namespace support is implemented as prefix * * @return bool */ public function getNamespaceIsPrefix(); /** * Set if namespace support is implemented as prefix * * @param stdClass $marker * @param bool $flag * @return Capabilities Fluent interface */ public function setNamespaceIsPrefix(stdClass $marker, $flag); /** * Get namespace separator if namespace is implemented as prefix * * @return string */ public function getNamespaceSeparator(); /** * Set the namespace separator if namespace is implemented as prefix * * @param stdClass $marker * @param string $separator * @return Capabilities Fluent interface */ public function setNamespaceSeparator(stdClass $marker, $separator); }","title":"Available Methods"},{"location":"v2/storage/capabilities/#examples","text":"","title":"Examples"},{"location":"v2/storage/plugin/","text":"Plugins Cache storage plugins are objects that provide additional functionality to or influence behavior of a storage adapter. The plugins listen to events the adapter triggers, and can: change the arguments provided to the method triggering the event (via *.post events) skip and directly return a result (by calling stopPropagation ) change the result (by calling setResult on the provided Laminas\\Cache\\Storage\\PostEvent ) catch exceptions (by reacting to Laminas\\Cache\\Storage\\ExceptionEvent ) Quick Start Storage plugins can either be created from Laminas\\Cache\\Service\\StoragePluginFactoryInterface::create() , or by instantiating one of the Laminas\\Cache\\Storage\\Plugin\\* classes. To make life easier, Laminas\\Cache\\Service\\StoragePluginFactoryInterface::create() can create both the requested adapter and all specified plugins at once. use Laminas\\Cache\\Service\\StoragePluginFactoryInterface; use Psr\\Container\\ContainerInterface; use Laminas\\Cache\\Service\\StorageAdapterFactoryInterface; /** @var ContainerInterface $container */ $container = null; // can be any configured PSR-11 container $storageFactory = $container-&gt;get(StorageAdapterFactoryInterface::class); // All at once: $cache = $storageFactory-&gt;create( 'filesystem', [], [ ['name' =&gt; 'serializer'], ] ); // Alternately, via discrete factory methods: $cache = $storageFactory-&gt;create('filesystem'); $pluginFactory = $container-&gt;get(StoragePluginFactoryInterface::class); $plugin = $pluginFactory-&gt;create('serializer'); $cache-&gt;addPlugin($plugin); // Or manually: $cache = new Laminas\\Cache\\Storage\\Adapter\\Filesystem(); $plugin = new Laminas\\Cache\\Storage\\Plugin\\Serializer(); $cache-&gt;addPlugin($plugin); The ClearExpiredByFactor Plugin Laminas\\Cache\\Storage\\Plugin\\ClearExpiredByFactor calls the storage method clearExpired() randomly (by factor) after every call of setItem() , setItems() , addItem() , and addItems() . Plugin specific Options Name Data Type Default Value Description clearing_factor integer 0 The automatic clearing factor. Adapter must implement ClearExpiredInterface The storage adapter must implement Laminas\\Cache\\Storage\\ClearExpiredInterface to work with this plugin. The ExceptionHandler Plugin Laminas\\Cache\\Storage\\Plugin\\ExceptionHandler catches all exceptions thrown on reading from or writing to the cache, and sends the exception to a defined callback function. You may also configure the plugin to re-throw exceptions. Plugin specific Options Name Data Type Default Value Description exception_callback callable\\|null null Callback to invoke on exception; receives the exception as the sole argument. throw_exceptions boolean true Re-throw caught exceptions. The IgnoreUserAbort Plugin Laminas\\Cache\\Storage\\Plugin\\IgnoreUserAbort ignores user-invoked script termination when, allowing cache write operations to complete first. Plugin specific Options Name Data Type Default Value Description exit_on_abort boolean true Terminate script execution on user abort. The OptimizeByFactor Plugin Laminas\\Cache\\Storage\\Plugin\\OptimizeByFactor calls the storage method optimize() randomly (by factor) after removing items from the cache. Plugin specific Options Name Data Type Default Value Description optimizing_factor integer 0 The automatic optimization factor. Adapter must implement OptimizableInterface The storage adapter must implement Laminas\\Cache\\Storage\\OptimizableInterface to work with this plugin. The Serializer Plugin Laminas\\Cache\\Storage\\Plugin\\Serializer will serialize data when writing to cache, and deserialize when reading. This allows storing datatypes not supported by the underlying storage adapter. Plugin specific Options Name Data Type Default Value Description serializer null\\|string\\|Laminas\\Serializer\\Adapter\\AdapterInterface null The serializer to use; see below. serializer_options array [] Array of options to use when instantiating the specified serializer. The serializer value has two special cases: When null , the default serializer is used (JSON). When a string , the value will be pulled via Laminas\\Serializer\\AdapterPluginManager , with the provided serializer_options . Available Methods The following methods are available to all Laminas\\Cache\\Storage\\Plugin\\PluginInterface implementations: namespace Laminas\\Cache\\Storage\\Plugin; use Laminas\\EventManager\\EventManagerInterface; use Laminas\\EventManager\\ListenerAggregateInterface; interface PluginInterface extends ListenerAggregateInterface { /** * Set options * * @param PluginOptions $options * @return PluginInterface */ public function setOptions(PluginOptions $options); /** * Get options * * @return PluginOptions */ public function getOptions(); /** * Attach listeners; inherited from ListenerAggregateInterface. * * @param EventManagerInterface $events * @return void */ public function attach(EventManagerInterface $events); /** * Detach listeners; inherited from ListenerAggregateInterface. * * @param EventManagerInterface $events * @return void */ public function attach(EventManagerInterface $events); } Examples Basic Plugin Implementation use Laminas\\Cache\\Storage\\Event; use Laminas\\Cache\\Storage\\Plugin\\AbstractPlugin; use Laminas\\EventManager\\EventManagerInterface; class MyPlugin extends AbstractPlugin { protected $handles = []; /** * Attach to all events this plugin is interested in. */ public function attach(EventManagerInterface $events) { $this-&gt;handles[] = $events-&gt;attach('getItem.pre', array($this, 'onGetItemPre')); $this-&gt;handles[] = $events-&gt;attach('getItem.post', array($this, 'onGetItemPost')); } /** * Detach all handlers this plugin previously attached. */ public function detach(EventManagerInterface $events) { foreach ($this-&gt;handles as $handle) { $events-&gt;detach($handle); } $this-&gt;handles = []; } public function onGetItemPre(Event $event) { $params = $event-&gt;getParams(); echo sprintf(\"Method 'getItem' with key '%s' started\\n\", $params['key']); } public function onGetItemPost(Event $event) { $params = $event-&gt;getParams(); echo sprintf(\"Method 'getItem' with key '%s' finished\\n\", $params['key']); } } // After defining this plugin, we can instantiate and add it to an adapter // instance: $plugin = new MyPlugin(); $cache-&gt;addPlugin($plugin); // Now when calling getItem(), our plugin should print the expected output: $cache-&gt;getItem('cache-key'); // Method 'getItem' with key 'cache-key' started // Method 'getItem' with key 'cache-key' finished","title":"Plugins"},{"location":"v2/storage/plugin/#plugins","text":"Cache storage plugins are objects that provide additional functionality to or influence behavior of a storage adapter. The plugins listen to events the adapter triggers, and can: change the arguments provided to the method triggering the event (via *.post events) skip and directly return a result (by calling stopPropagation ) change the result (by calling setResult on the provided Laminas\\Cache\\Storage\\PostEvent ) catch exceptions (by reacting to Laminas\\Cache\\Storage\\ExceptionEvent )","title":"Plugins"},{"location":"v2/storage/plugin/#quick-start","text":"Storage plugins can either be created from Laminas\\Cache\\Service\\StoragePluginFactoryInterface::create() , or by instantiating one of the Laminas\\Cache\\Storage\\Plugin\\* classes. To make life easier, Laminas\\Cache\\Service\\StoragePluginFactoryInterface::create() can create both the requested adapter and all specified plugins at once. use Laminas\\Cache\\Service\\StoragePluginFactoryInterface; use Psr\\Container\\ContainerInterface; use Laminas\\Cache\\Service\\StorageAdapterFactoryInterface; /** @var ContainerInterface $container */ $container = null; // can be any configured PSR-11 container $storageFactory = $container-&gt;get(StorageAdapterFactoryInterface::class); // All at once: $cache = $storageFactory-&gt;create( 'filesystem', [], [ ['name' =&gt; 'serializer'], ] ); // Alternately, via discrete factory methods: $cache = $storageFactory-&gt;create('filesystem'); $pluginFactory = $container-&gt;get(StoragePluginFactoryInterface::class); $plugin = $pluginFactory-&gt;create('serializer'); $cache-&gt;addPlugin($plugin); // Or manually: $cache = new Laminas\\Cache\\Storage\\Adapter\\Filesystem(); $plugin = new Laminas\\Cache\\Storage\\Plugin\\Serializer(); $cache-&gt;addPlugin($plugin);","title":"Quick Start"},{"location":"v2/storage/plugin/#the-clearexpiredbyfactor-plugin","text":"Laminas\\Cache\\Storage\\Plugin\\ClearExpiredByFactor calls the storage method clearExpired() randomly (by factor) after every call of setItem() , setItems() , addItem() , and addItems() .","title":"The ClearExpiredByFactor Plugin"},{"location":"v2/storage/plugin/#the-exceptionhandler-plugin","text":"Laminas\\Cache\\Storage\\Plugin\\ExceptionHandler catches all exceptions thrown on reading from or writing to the cache, and sends the exception to a defined callback function. You may also configure the plugin to re-throw exceptions.","title":"The ExceptionHandler Plugin"},{"location":"v2/storage/plugin/#the-ignoreuserabort-plugin","text":"Laminas\\Cache\\Storage\\Plugin\\IgnoreUserAbort ignores user-invoked script termination when, allowing cache write operations to complete first.","title":"The IgnoreUserAbort Plugin"},{"location":"v2/storage/plugin/#the-optimizebyfactor-plugin","text":"Laminas\\Cache\\Storage\\Plugin\\OptimizeByFactor calls the storage method optimize() randomly (by factor) after removing items from the cache.","title":"The OptimizeByFactor Plugin"},{"location":"v2/storage/plugin/#the-serializer-plugin","text":"Laminas\\Cache\\Storage\\Plugin\\Serializer will serialize data when writing to cache, and deserialize when reading. This allows storing datatypes not supported by the underlying storage adapter.","title":"The Serializer Plugin"},{"location":"v2/storage/plugin/#available-methods","text":"The following methods are available to all Laminas\\Cache\\Storage\\Plugin\\PluginInterface implementations: namespace Laminas\\Cache\\Storage\\Plugin; use Laminas\\EventManager\\EventManagerInterface; use Laminas\\EventManager\\ListenerAggregateInterface; interface PluginInterface extends ListenerAggregateInterface { /** * Set options * * @param PluginOptions $options * @return PluginInterface */ public function setOptions(PluginOptions $options); /** * Get options * * @return PluginOptions */ public function getOptions(); /** * Attach listeners; inherited from ListenerAggregateInterface. * * @param EventManagerInterface $events * @return void */ public function attach(EventManagerInterface $events); /** * Detach listeners; inherited from ListenerAggregateInterface. * * @param EventManagerInterface $events * @return void */ public function attach(EventManagerInterface $events); }","title":"Available Methods"},{"location":"v2/storage/plugin/#examples","text":"","title":"Examples"},{"location":"v3/installation/","text":"This Is Only a Placeholder The content of this page can be found under: https://github.com/laminas/documentation-theme/blob/master/theme/pages/installation.html","title":"Installation"},{"location":"v3/installation/#this-is-only-a-placeholder","text":"The content of this page can be found under: https://github.com/laminas/documentation-theme/blob/master/theme/pages/installation.html","title":"This Is Only a Placeholder"},{"location":"v3/psr16/","text":"PSR-16 PSR-16 provides a simplified approach to cache access that does not involve cache pools, tags, deferment, etc.; it can be thought of as a key/value storage approach to caching. laminas-cache provides PSR-16 support via the class Laminas\\Cache\\Psr\\SimpleCache\\SimpleCacheDecorator . This class implements PSR-16's Psr\\SimpleCache\\CacheInterface , and composes a Laminas\\Cache\\Storage\\StorageInterface instance to which it proxies all operations. Instantiation is as follows: use Laminas\\Cache\\Psr\\SimpleCache\\SimpleCacheDecorator; use Laminas\\Cache\\Service\\StorageAdapterFactoryInterface; use Psr\\Container\\ContainerInterface; /** @var ContainerInterface $container */ $container = null; // can be any configured PSR-11 container $storageFactory = $container-&gt;get(StorageAdapterFactoryInterface::class); $storage = $storageFactory-&gt;create('apc'); $cache = new SimpleCacheDecorator($storage); Once you have a SimpleCacheDecorator instance, you can perform operations per that specification: // Use has() to determine whether to fetch the value or calculate it: $value = $cache-&gt;has('someKey') ? $cache-&gt;get('someKey') : calculateValue(); if (! $cache-&gt;has('someKey')) { $cache-&gt;set('someKey', $value); } // Or use a default value: $value = $cache-&gt;get('someKey', $defaultValue); When setting values, whether single values or multiple, you can also optionally provide a Time To Live (TTL) value. This proxies to the underlying storage instance's options, temporarily resetting its TTL value for the duration of the operation. TTL values may be expressed as integers (in which case they represent seconds) or DateInterval instances. As examples: $cache-&gt;set('someKey', $value, 30); // set TTL to 30s $cache-&gt;set('someKey', $value, new DateInterval('P1D')); // set TTL to 1 day $cache-&gt;setMultiple([ 'key1' =&gt; $value1, 'key2' =&gt; $value2, ], 3600); // set TTL to 1 hour $cache-&gt;setMultiple([ 'key1' =&gt; $value1, 'key2' =&gt; $value2, ], new DateInterval('P6H')); // set TTL to 6 hours For more details on what methods are exposed, consult the CacheInterface specification . Serialization PSR-16 has strict requirements around serialization of values. This is done to ensure that if you swap one PSR-16 adapter for another, the new one will be able to return the same values that the original adapter saved to the cache. Not all cache backends support the same data types, however. laminas-cache provides a plugin, Laminas\\Cache\\Storage\\Plugin\\Serializer , that you can attach to adapters in order to ensure data is serialized to a string when saving to the cache, and deserialized to native PHP types on retrieval. The following adapters require this plugin in order to work with the SimpleCacheDecorator : Dba Filesystem Memcache MongoDB Redis XCache We provide a number of examples of attaching plugins to storage adapters in the plugins chapter . Generally, it will be one of: use Laminas\\Cache\\Service\\StorageAdapterFactoryInterface; use Laminas\\Cache\\Storage\\Plugin\\Serializer; use Psr\\Container\\ContainerInterface; // Manual attachment after you have an instance: $cache-&gt;addPlugin(new Serializer()); // Via configuration: /** @var ContainerInterface $container */ $container = null; // can be any configured PSR-11 container $storageFactory = $container-&gt;get(StorageAdapterFactoryInterface::class); $cache = $storageFactory-&gt;create( 'filesystem', [], [ ['name' =&gt; 'serializer'], ] ); Deleting Items and Exceptions PSR-16 states that the delete() and deleteMultiple() methods should return false if an error occured when deleting the key(s) provided, but true otherwise. Generally, laminas-cache storage adapters comply with this. However, it is possible to configure your adapter such that you may get a false positive result from these methods. When an exception is raised and caught during key removal by an adapter, the adapter triggers an event with a Laminas\\Cache\\Storage\\ExceptionEvent . Plugins can react to these, and even manipulate the event instance. One such plugin, Laminas\\Cache\\Storage\\Plugin\\ExceptionHandler , has a configuration option, throw_exceptions that, when boolean false , will prevent raising the exception. In such cases, adapters will typically return a boolean false anyways, but custom, third-party adapters may not. Additionally, if you add a custom plugin that listens to removal event exceptions and modifies the return value and/or disables throwing the exception, a false positive return value could occur. As such, we recommend that if you wish to use laminas-cache to provide a PSR-16 adapter, you audit the plugins you use with your adapter to ensure that you will get consistent, correct behavior for delete() and deleteMultiple() operations.","title":"PSR-16"},{"location":"v3/psr16/#psr-16","text":"PSR-16 provides a simplified approach to cache access that does not involve cache pools, tags, deferment, etc.; it can be thought of as a key/value storage approach to caching. laminas-cache provides PSR-16 support via the class Laminas\\Cache\\Psr\\SimpleCache\\SimpleCacheDecorator . This class implements PSR-16's Psr\\SimpleCache\\CacheInterface , and composes a Laminas\\Cache\\Storage\\StorageInterface instance to which it proxies all operations. Instantiation is as follows: use Laminas\\Cache\\Psr\\SimpleCache\\SimpleCacheDecorator; use Laminas\\Cache\\Service\\StorageAdapterFactoryInterface; use Psr\\Container\\ContainerInterface; /** @var ContainerInterface $container */ $container = null; // can be any configured PSR-11 container $storageFactory = $container-&gt;get(StorageAdapterFactoryInterface::class); $storage = $storageFactory-&gt;create('apc'); $cache = new SimpleCacheDecorator($storage); Once you have a SimpleCacheDecorator instance, you can perform operations per that specification: // Use has() to determine whether to fetch the value or calculate it: $value = $cache-&gt;has('someKey') ? $cache-&gt;get('someKey') : calculateValue(); if (! $cache-&gt;has('someKey')) { $cache-&gt;set('someKey', $value); } // Or use a default value: $value = $cache-&gt;get('someKey', $defaultValue); When setting values, whether single values or multiple, you can also optionally provide a Time To Live (TTL) value. This proxies to the underlying storage instance's options, temporarily resetting its TTL value for the duration of the operation. TTL values may be expressed as integers (in which case they represent seconds) or DateInterval instances. As examples: $cache-&gt;set('someKey', $value, 30); // set TTL to 30s $cache-&gt;set('someKey', $value, new DateInterval('P1D')); // set TTL to 1 day $cache-&gt;setMultiple([ 'key1' =&gt; $value1, 'key2' =&gt; $value2, ], 3600); // set TTL to 1 hour $cache-&gt;setMultiple([ 'key1' =&gt; $value1, 'key2' =&gt; $value2, ], new DateInterval('P6H')); // set TTL to 6 hours For more details on what methods are exposed, consult the CacheInterface specification .","title":"PSR-16"},{"location":"v3/psr16/#serialization","text":"PSR-16 has strict requirements around serialization of values. This is done to ensure that if you swap one PSR-16 adapter for another, the new one will be able to return the same values that the original adapter saved to the cache. Not all cache backends support the same data types, however. laminas-cache provides a plugin, Laminas\\Cache\\Storage\\Plugin\\Serializer , that you can attach to adapters in order to ensure data is serialized to a string when saving to the cache, and deserialized to native PHP types on retrieval. The following adapters require this plugin in order to work with the SimpleCacheDecorator : Dba Filesystem Memcache MongoDB Redis XCache We provide a number of examples of attaching plugins to storage adapters in the plugins chapter . Generally, it will be one of: use Laminas\\Cache\\Service\\StorageAdapterFactoryInterface; use Laminas\\Cache\\Storage\\Plugin\\Serializer; use Psr\\Container\\ContainerInterface; // Manual attachment after you have an instance: $cache-&gt;addPlugin(new Serializer()); // Via configuration: /** @var ContainerInterface $container */ $container = null; // can be any configured PSR-11 container $storageFactory = $container-&gt;get(StorageAdapterFactoryInterface::class); $cache = $storageFactory-&gt;create( 'filesystem', [], [ ['name' =&gt; 'serializer'], ] );","title":"Serialization"},{"location":"v3/psr16/#deleting-items-and-exceptions","text":"PSR-16 states that the delete() and deleteMultiple() methods should return false if an error occured when deleting the key(s) provided, but true otherwise. Generally, laminas-cache storage adapters comply with this. However, it is possible to configure your adapter such that you may get a false positive result from these methods. When an exception is raised and caught during key removal by an adapter, the adapter triggers an event with a Laminas\\Cache\\Storage\\ExceptionEvent . Plugins can react to these, and even manipulate the event instance. One such plugin, Laminas\\Cache\\Storage\\Plugin\\ExceptionHandler , has a configuration option, throw_exceptions that, when boolean false , will prevent raising the exception. In such cases, adapters will typically return a boolean false anyways, but custom, third-party adapters may not. Additionally, if you add a custom plugin that listens to removal event exceptions and modifies the return value and/or disables throwing the exception, a false positive return value could occur. As such, we recommend that if you wish to use laminas-cache to provide a PSR-16 adapter, you audit the plugins you use with your adapter to ensure that you will get consistent, correct behavior for delete() and deleteMultiple() operations.","title":"Deleting Items and Exceptions"},{"location":"v3/psr6/","text":"PSR-6 Overview The Laminas\\Cache\\Psr\\CacheItemPool\\CacheItemPoolDecorator provides a PSR-6 compliant wrapper for supported storage adapters. PSR-6 specifies a common interface to cache storage, enabling developers to switch between implementations without having to worry about any behind-the-scenes differences between them. Quick Start To use the pool, instantiate your storage as normal, then pass it to the CacheItemPoolDecorator . use Laminas\\Cache\\Psr\\CacheItemPool\\CacheItemPoolDecorator;use Laminas\\Cache\\Service\\StorageAdapterFactoryInterface;use Psr\\Container\\ContainerInterface; /** @var ContainerInterface $container */ $container = null; // can be any configured PSR-11 container $storageFactory = $container-&gt;get(StorageAdapterFactoryInterface::class); $storage = $storageFactory-&gt;create('apc'); $pool = new CacheItemPoolDecorator($storage); // attempt to get an item from cache $item = $pool-&gt;getItem('foo'); // check whether item was found if (! $item-&gt;isHit()) { // ... // perform expensive operation to calculate $value for 'foo' // ... $item-&gt;set($value); $pool-&gt;save($item); } // use the value of the item echo $item-&gt;get(); Note that you will always get back a CacheItem object, whether it was found in cache or not: this is so false -y values like an empty string, null , or false can be stored. Always check isHit() to determine if the item was found. Supported Adapters The PSR-6 specification requires that the underlying storage support time-to-live (TTL), which is set when the item is saved. For this reason the following adapters cannot be used: Dba , Filesystem , Memory and Session . The XCache adapter calculates TTLs based on the request time, not the time the item is actually persisted, which means that it also cannot be used. In addition adapters must support the Laminas\\Cache\\FlushableInterface . All the current Laminas\\Cache\\Storage\\Adapter s fulfil this requirement. Attempting to use an unsupported adapter will throw an exception implementing Psr\\Cache\\CacheException . The Laminas\\Cache\\Psr\\CacheItemPool\\CacheItemPoolDecorator adapter doesn't support driver deferred saves, so cache items are saved on destruct or on explicit commit() call. Quirks APC You cannot set the apc.use_request_time ini setting with the APC adapter: the specification requires that all TTL values are calculated from when the item is actually saved to storage. If this is set when you instantiate the pool it will throw an exception implementing Psr\\Cache\\CacheException . Changing the setting after you have instantiated the pool will result in non-standard behaviour. Logging Errors The specification states : While caching is often an important part of application performance, it should never be a critical part of application functionality. Thus, an error in a cache system SHOULD NOT result in application failure. Once you've got your pool instance, almost all exceptions thrown by the storage will be caught and ignored. The only storage exceptions that bubble up implement Psr\\Cache\\InvalidArgumentException and are typically caused by invalid key errors. To be PSR-6 compliant, cache keys must not contain the following characters: {}()/\\@: . However different storage adapters may have further restrictions. Check the documentation for your particular adapter to be sure. We strongly recommend tracking exceptions caught from storage, either by logging them or recording them in some other way. Doing so is as simple as adding an ExceptionHandler plugin . Say you have a PSR-3 compliant logger called $logger : use Laminas\\Cache\\Psr\\CacheItemPool\\CacheItemPoolDecorator; use Laminas\\Cache\\Service\\StorageAdapterFactoryInterface; use Psr\\Container\\ContainerInterface; $cacheLogger = function (\\Exception $e) use ($logger) { $message = sprintf( '[CACHE] %s:%s %s \"%s\"', $exception-&gt;getFile(), $exception-&gt;getLine(), $exception-&gt;getCode(), $exception-&gt;getMessage() ); $logger-&gt;error($message); }; /** @var ContainerInterface $container */ $container = null; // can be any configured PSR-11 container $storageFactory = $container-&gt;get(StorageAdapterFactoryInterface::class); $storage = $storageFactory-&gt;create( 'apc', [], [ [ 'name' =&gt; 'exceptionhandler', 'options' =&gt; [ 'exception_callback' =&gt; $cacheLogger, 'throw_exceptions' =&gt; true, ], ], ] ); $pool = new CacheItemPoolDecorator($storage); Note that throw_exceptions should always be true (the default) or you will not get the correct return values from calls on the pool such as save() . Supported Data Types As per the specification , the following data types can be stored in cache: string , integer , float , boolean , null , array , object and be returned as a value with exactly the same type. Not all adapters can natively store all these types. For instance, Redis stores booleans and integers as a string. Where this is the case all values will be automatically run through serialize() on save and unserialize() on get: you do not need to use a Laminas\\Cache\\Storage\\Plugin\\Serializer plugin. Time-Related Operations By default, the PSR-6 cache decorator uses the systems time to determine cache expirations. This can be changed by passing a stella-maris/clock Clock implementation to the CacheItemPoolDecorator#__construct . By doing so, the method CacheItemInterface#expiresAfter uses that Clock to calculate the cache items TTL when passing a DateInterval instance. use Lcobucci\\Clock\\SystemClock; $clock = new SystemClock('Antarctica/Troll'); $pool = new CacheItemPoolDecorator($storage, $clock); $item = $pool-&gt;getItem('non-existent-key'); $item -&gt;set('foo') -&gt;expiresAfter(DateInterval::createFromDateString('24 hours')); // Saves the item which expires in 24h $pool-&gt;save($item);","title":"PSR-6"},{"location":"v3/psr6/#psr-6","text":"","title":"PSR-6"},{"location":"v3/psr6/#overview","text":"The Laminas\\Cache\\Psr\\CacheItemPool\\CacheItemPoolDecorator provides a PSR-6 compliant wrapper for supported storage adapters. PSR-6 specifies a common interface to cache storage, enabling developers to switch between implementations without having to worry about any behind-the-scenes differences between them.","title":"Overview"},{"location":"v3/psr6/#quick-start","text":"To use the pool, instantiate your storage as normal, then pass it to the CacheItemPoolDecorator . use Laminas\\Cache\\Psr\\CacheItemPool\\CacheItemPoolDecorator;use Laminas\\Cache\\Service\\StorageAdapterFactoryInterface;use Psr\\Container\\ContainerInterface; /** @var ContainerInterface $container */ $container = null; // can be any configured PSR-11 container $storageFactory = $container-&gt;get(StorageAdapterFactoryInterface::class); $storage = $storageFactory-&gt;create('apc'); $pool = new CacheItemPoolDecorator($storage); // attempt to get an item from cache $item = $pool-&gt;getItem('foo'); // check whether item was found if (! $item-&gt;isHit()) { // ... // perform expensive operation to calculate $value for 'foo' // ... $item-&gt;set($value); $pool-&gt;save($item); } // use the value of the item echo $item-&gt;get(); Note that you will always get back a CacheItem object, whether it was found in cache or not: this is so false -y values like an empty string, null , or false can be stored. Always check isHit() to determine if the item was found.","title":"Quick Start"},{"location":"v3/psr6/#supported-adapters","text":"The PSR-6 specification requires that the underlying storage support time-to-live (TTL), which is set when the item is saved. For this reason the following adapters cannot be used: Dba , Filesystem , Memory and Session . The XCache adapter calculates TTLs based on the request time, not the time the item is actually persisted, which means that it also cannot be used. In addition adapters must support the Laminas\\Cache\\FlushableInterface . All the current Laminas\\Cache\\Storage\\Adapter s fulfil this requirement. Attempting to use an unsupported adapter will throw an exception implementing Psr\\Cache\\CacheException . The Laminas\\Cache\\Psr\\CacheItemPool\\CacheItemPoolDecorator adapter doesn't support driver deferred saves, so cache items are saved on destruct or on explicit commit() call.","title":"Supported Adapters"},{"location":"v3/psr6/#logging-errors","text":"The specification states : While caching is often an important part of application performance, it should never be a critical part of application functionality. Thus, an error in a cache system SHOULD NOT result in application failure. Once you've got your pool instance, almost all exceptions thrown by the storage will be caught and ignored. The only storage exceptions that bubble up implement Psr\\Cache\\InvalidArgumentException and are typically caused by invalid key errors. To be PSR-6 compliant, cache keys must not contain the following characters: {}()/\\@: . However different storage adapters may have further restrictions. Check the documentation for your particular adapter to be sure. We strongly recommend tracking exceptions caught from storage, either by logging them or recording them in some other way. Doing so is as simple as adding an ExceptionHandler plugin . Say you have a PSR-3 compliant logger called $logger : use Laminas\\Cache\\Psr\\CacheItemPool\\CacheItemPoolDecorator; use Laminas\\Cache\\Service\\StorageAdapterFactoryInterface; use Psr\\Container\\ContainerInterface; $cacheLogger = function (\\Exception $e) use ($logger) { $message = sprintf( '[CACHE] %s:%s %s \"%s\"', $exception-&gt;getFile(), $exception-&gt;getLine(), $exception-&gt;getCode(), $exception-&gt;getMessage() ); $logger-&gt;error($message); }; /** @var ContainerInterface $container */ $container = null; // can be any configured PSR-11 container $storageFactory = $container-&gt;get(StorageAdapterFactoryInterface::class); $storage = $storageFactory-&gt;create( 'apc', [], [ [ 'name' =&gt; 'exceptionhandler', 'options' =&gt; [ 'exception_callback' =&gt; $cacheLogger, 'throw_exceptions' =&gt; true, ], ], ] ); $pool = new CacheItemPoolDecorator($storage); Note that throw_exceptions should always be true (the default) or you will not get the correct return values from calls on the pool such as save() .","title":"Logging Errors"},{"location":"v3/psr6/#supported-data-types","text":"As per the specification , the following data types can be stored in cache: string , integer , float , boolean , null , array , object and be returned as a value with exactly the same type. Not all adapters can natively store all these types. For instance, Redis stores booleans and integers as a string. Where this is the case all values will be automatically run through serialize() on save and unserialize() on get: you do not need to use a Laminas\\Cache\\Storage\\Plugin\\Serializer plugin.","title":"Supported Data Types"},{"location":"v3/psr6/#time-related-operations","text":"By default, the PSR-6 cache decorator uses the systems time to determine cache expirations. This can be changed by passing a stella-maris/clock Clock implementation to the CacheItemPoolDecorator#__construct . By doing so, the method CacheItemInterface#expiresAfter uses that Clock to calculate the cache items TTL when passing a DateInterval instance. use Lcobucci\\Clock\\SystemClock; $clock = new SystemClock('Antarctica/Troll'); $pool = new CacheItemPoolDecorator($storage, $clock); $item = $pool-&gt;getItem('non-existent-key'); $item -&gt;set('foo') -&gt;expiresAfter(DateInterval::createFromDateString('24 hours')); // Saves the item which expires in 24h $pool-&gt;save($item);","title":"Time-Related Operations"},{"location":"v3/application-integration/usage-in-a-laminas-mvc-application/","text":"Usage in a laminas-mvc Application The following example shows one potential use case of laminas-cache within a laminas-mvc based application. The example uses a module, a controller and shows the resolving of dependencies of the controller by configuration. Preparation Before starting, make sure laminas-cache is installed and configured . Installation Requirements laminas-cache is shipped without a specific cache adapter to allow free choice of storage backends and their dependencies. So make sure that the required adapters are installed. The following example used the filesystem adapter of laminas-cache : $ composer require laminas/laminas-cache-storage-adapter-filesystem Configure Cache To configure the cache in a laminas-mvc based application, use either application or module configuration (such as config/autoload/*.global.php or module/Application/config/module.config.php , respectively), and define the configuration key caches . In this example, the global configuration is used and a separate file is created for the cache configuration. Create a configuration file with name like config/autoload/cache.global.php and it will automatically be included : return [ 'caches' =&gt; [ 'default-cache' =&gt; [ 'adapter' =&gt; Laminas\\Cache\\Storage\\Adapter\\Filesystem::class, 'options' =&gt; [ 'cache_dir' =&gt; __DIR__ . '/../../data/cache', ], ], ], ]; The factory Laminas\\Cache\\Service\\StorageCacheAbstractServiceFactory uses the configuration, searches for the configuration key caches and creates the storage adapters using the discovered configuration. Cache Named config Is Not Possible A cache named config is not possible due to internal service conflicts with MVC configuration. The service named config is reserved for project configuration and thus cannot be used with the caches configuration. Create Controller Create a controller class and inject the cache with the interface for all cache storage adapters via the constructor, e.g. module/Application/Controller/IndexController.php : namespace Application\\Controller; use Laminas\\Cache\\Storage\\StorageInterface; use Laminas\\Mvc\\Controller\\AbstractActionController; final class IndexController extends AbstractActionController { public function __construct( private readonly StorageInterface $cache ) {} public function indexAction(): array { if (! $this-&gt;cache-&gt;hasItem('example')) { $this-&gt;cache-&gt;addItem('example', 'value'); } echo $this-&gt;cache-&gt;getItem('example') // value; // … return []; } } Register Controller To register the controller for the application, extend the configuration of the module. Add the following lines to the module configuration file, e.g. module/Application/config/module.config.php : namespace Application; use Laminas\\ServiceManager\\AbstractFactory\\ConfigAbstractFactory; return [ 'controllers' =&gt; [ 'factories' =&gt; [ Controller\\IndexController::class =&gt; ConfigAbstractFactory::class, ], ], // … ]; The example uses the config factory from laminas-servicemanager which allows any string to be used to fetch a service from the application service container, like the name of the configured cache: default-cache . This means that the factory searches for an appropriate configuration to create the controller and to resolve the constructor dependencies for the controller class. Add Factory Configuration For Controller Extend the module configuration file to add the configuration for the controller. Use the name of the cache ( default-cache ), which was previously defined in the configuration of the caches, to retrieve the related cache storage instance: namespace Application; use Laminas\\ServiceManager\\AbstractFactory\\ConfigAbstractFactory; return [ 'controllers' =&gt; [ 'factories' =&gt; [ Controller\\IndexController::class =&gt; ConfigAbstractFactory::class, ], ], ConfigAbstractFactory::class =&gt; [ Controller\\IndexController::class =&gt; [ 'default-cache', ], ], // … ]; Using Multiple Caches The use more than one cache backend, the factory Laminas\\Cache\\Service\\StorageCacheAbstractServiceFactory allows to define multiple cache storages. Extend the cache configuration in config/autoload/cache.global.php and add more cache adapters: return [ 'caches' =&gt; [ 'default-cache' =&gt; [ 'adapter' =&gt; Laminas\\Cache\\Storage\\Adapter\\Filesystem::class, 'options' =&gt; [ 'cache_dir' =&gt; __DIR__ . '/../../data/cache', ], ], 'secondary-cache' =&gt; [ 'adapter' =&gt; Laminas\\Cache\\Storage\\Adapter\\Memory::class, ], 'dummy-cache' =&gt; [ 'adapter' =&gt; Laminas\\Cache\\Storage\\Adapter\\BlackHole::class, ], ], ]; Installation Requirements Make sure that the used storage adapters are installed : $ composer require laminas/laminas-cache-storage-adapter-memory laminas/laminas-cache-storage-adapter-blackhole Change Used Adapter for Controller To use a different cache adapter for the controller, change the related module configuration and use one of the previously defined names: namespace Application; use Laminas\\ServiceManager\\AbstractFactory\\ConfigAbstractFactory; return [ 'controllers' =&gt; [ 'factories' =&gt; [ Controller\\IndexController::class =&gt; ConfigAbstractFactory::class, ], ], ConfigAbstractFactory::class =&gt; [ Controller\\IndexController::class =&gt; [ 'dummy-cache', ], ], // … ]; Learn More Storage Adapters Environment-Specific Application Configuration Configuration-based Abstract Factory","title":"Usage in a laminas-mvc Application"},{"location":"v3/application-integration/usage-in-a-laminas-mvc-application/#usage-in-a-laminas-mvc-application","text":"The following example shows one potential use case of laminas-cache within a laminas-mvc based application. The example uses a module, a controller and shows the resolving of dependencies of the controller by configuration.","title":"Usage in a laminas-mvc Application"},{"location":"v3/application-integration/usage-in-a-laminas-mvc-application/#preparation","text":"Before starting, make sure laminas-cache is installed and configured . Installation Requirements laminas-cache is shipped without a specific cache adapter to allow free choice of storage backends and their dependencies. So make sure that the required adapters are installed. The following example used the filesystem adapter of laminas-cache : $ composer require laminas/laminas-cache-storage-adapter-filesystem","title":"Preparation"},{"location":"v3/application-integration/usage-in-a-laminas-mvc-application/#configure-cache","text":"To configure the cache in a laminas-mvc based application, use either application or module configuration (such as config/autoload/*.global.php or module/Application/config/module.config.php , respectively), and define the configuration key caches . In this example, the global configuration is used and a separate file is created for the cache configuration. Create a configuration file with name like config/autoload/cache.global.php and it will automatically be included : return [ 'caches' =&gt; [ 'default-cache' =&gt; [ 'adapter' =&gt; Laminas\\Cache\\Storage\\Adapter\\Filesystem::class, 'options' =&gt; [ 'cache_dir' =&gt; __DIR__ . '/../../data/cache', ], ], ], ]; The factory Laminas\\Cache\\Service\\StorageCacheAbstractServiceFactory uses the configuration, searches for the configuration key caches and creates the storage adapters using the discovered configuration. Cache Named config Is Not Possible A cache named config is not possible due to internal service conflicts with MVC configuration. The service named config is reserved for project configuration and thus cannot be used with the caches configuration.","title":"Configure Cache"},{"location":"v3/application-integration/usage-in-a-laminas-mvc-application/#create-controller","text":"Create a controller class and inject the cache with the interface for all cache storage adapters via the constructor, e.g. module/Application/Controller/IndexController.php : namespace Application\\Controller; use Laminas\\Cache\\Storage\\StorageInterface; use Laminas\\Mvc\\Controller\\AbstractActionController; final class IndexController extends AbstractActionController { public function __construct( private readonly StorageInterface $cache ) {} public function indexAction(): array { if (! $this-&gt;cache-&gt;hasItem('example')) { $this-&gt;cache-&gt;addItem('example', 'value'); } echo $this-&gt;cache-&gt;getItem('example') // value; // … return []; } }","title":"Create Controller"},{"location":"v3/application-integration/usage-in-a-laminas-mvc-application/#register-controller","text":"To register the controller for the application, extend the configuration of the module. Add the following lines to the module configuration file, e.g. module/Application/config/module.config.php : namespace Application; use Laminas\\ServiceManager\\AbstractFactory\\ConfigAbstractFactory; return [ 'controllers' =&gt; [ 'factories' =&gt; [ Controller\\IndexController::class =&gt; ConfigAbstractFactory::class, ], ], // … ]; The example uses the config factory from laminas-servicemanager which allows any string to be used to fetch a service from the application service container, like the name of the configured cache: default-cache . This means that the factory searches for an appropriate configuration to create the controller and to resolve the constructor dependencies for the controller class.","title":"Register Controller"},{"location":"v3/application-integration/usage-in-a-laminas-mvc-application/#using-multiple-caches","text":"The use more than one cache backend, the factory Laminas\\Cache\\Service\\StorageCacheAbstractServiceFactory allows to define multiple cache storages. Extend the cache configuration in config/autoload/cache.global.php and add more cache adapters: return [ 'caches' =&gt; [ 'default-cache' =&gt; [ 'adapter' =&gt; Laminas\\Cache\\Storage\\Adapter\\Filesystem::class, 'options' =&gt; [ 'cache_dir' =&gt; __DIR__ . '/../../data/cache', ], ], 'secondary-cache' =&gt; [ 'adapter' =&gt; Laminas\\Cache\\Storage\\Adapter\\Memory::class, ], 'dummy-cache' =&gt; [ 'adapter' =&gt; Laminas\\Cache\\Storage\\Adapter\\BlackHole::class, ], ], ]; Installation Requirements Make sure that the used storage adapters are installed : $ composer require laminas/laminas-cache-storage-adapter-memory laminas/laminas-cache-storage-adapter-blackhole","title":"Using Multiple Caches"},{"location":"v3/application-integration/usage-in-a-laminas-mvc-application/#learn-more","text":"Storage Adapters Environment-Specific Application Configuration Configuration-based Abstract Factory","title":"Learn More"},{"location":"v3/migration/to-version-3/","text":"Migration to Version 3.0 Upgrading to laminas-cache will require a few code-changes, depending on how the storage adapters were used. Please note that the migration guide assumes that laminas-cache is installed via Composer . Please check out the checklist to see what changes need to be done. The biggest change with laminas-cache v3.0 is that this component will be shipped without a specific cache adapter. The idea behind this is, that projects can freely choose those cache adapters they really use. In the past, most of the adapters Laminas does officially support were not properly tested, blocked PHP version upgrades (due to extensions lacking compatibility) and had to be maintained due to backwards compatibility. Starting with v3.0, all adapters can be maintained and evolve independently. Checklist laminas-cache is updated to the latest version from within 2.x (currently 2.13.2 ) laminas-cli is installed to verify the configuration integrity ( vendor/bin/laminas laminas-cache:deprecation:check-storage-factory-config ); in case you don't want to use laminas-cli , please check out the normalized array configuration example in the release notes of 2.12.0 laminas-cache is required with ^3.0 within composer.json Cache adapters which are used within the project needs to be required in at least ^2.0 ; in case you don't know which adapters are in use, either check your project configuration or search for the Laminas\\Cache\\Storage\\Adapter namespace in your projects source code. Every adapter has to be listed in either your module.config.php (laminas-mvc) or config.php (mezzio) configuration. Project does not use any of the removed classes and traits Storage adapters are not extended in any way as all adapters are final starting with v2.0 of the individual adapter component PSR-6 CacheItemPoolDecorator does now validate the maximum key length the same way as PSR-6 SimpleCacheDecorator and therefore fulfills the requirements by the underlying PSR. New Features Each cache adapter has its own package . Support for PHP 8.1 PSR-6 CacheItemPoolDecorator validates the maximum key length. Removed Classes and Traits With laminas-cache v3, some classes/traits were removed as well: Due to the switch to satellite packages , the StorageFactory was replaced with the StorageAdapterFactoryInterface . Due to the same reason, the PatternFactory was removed. Cache patterns mostly need an underlying adapter which have to be created with the new StorageAdapterFactoryInterface ClassCache cache pattern was removed. For more details, please read the related issue . PatternCacheFactory and StoragePatternCacheFactory which were introduced in v2.12.0 to provide forward compatibility. PatternPluginManager and PatternPluginManagerFactory which were removed due to the fact that most cache patterns require underlying cache adapter and thus are not instantiable from their name and options. PluginManagerLookupTrait which was used to provide forward compatibility for the StorageAdapterFactoryInterface . PatternOptions are not capable of the storage option anymore Breaking Changes CallbackCache , OutputCache and ObjectCache now require the underlying cache adapter ( StorageInterface ) as 1st __construct dependency. The options can be passed via 2nd __construct)[https://github.com/CallbackCache , OutputCache and ObjectCache now require the underlying cache adapter ( StorageInterface arguments but are optional. Please note that it is not possible to inject the pattern configuration as an array anymore Storage configurations must be in a specific shape. For more details, head to the release notes of 2.12.0 All cache adapters are now marked as final and are not extensible anymore. In case that you are extending one of the cache adapters, please change your code as composition should be preferred over inheritance. For an example, please check out the composition over inheritance section. Due to the enhancement of CacheItemPoolDecorator , the maximum key length for the underlying cache adapter is validated before it is passed to the adapter. The SerializationTrait which was meant to be used by both PSR-6 and PSR-16 decorators is now marked as internal . The PCRE_MAXIMUM_QUANTIFIER_LENGTH constant of the SimpleCacheDecorator (which was marked as internal ) has now been moved to the new (also internal ) MaximumKeyLengthTrait and thus had to become a public static property (as traits do not support constants). Satellite Packages Starting with laminas-cache v3, we are introducing satellite packages for each cache backend. In order to make this package work, you have to specify at least one satellite package. A list of available cache adapters can be found here (starting with their v2 release): laminas/laminas-cache-storage-adapter-apcu laminas/laminas-cache-storage-adapter-blackhole laminas/laminas-cache-storage-adapter-ext-mongodb laminas/laminas-cache-storage-adapter-filesystem laminas/laminas-cache-storage-adapter-memcached laminas/laminas-cache-storage-adapter-memory laminas/laminas-cache-storage-adapter-redis laminas/laminas-cache-storage-adapter-session Composition Over Inheritance In case you are extending one of the cache implementations, your code might look as follows: use Laminas\\Cache\\Storage\\Adapter\\Filesystem; class MyFileystemStorage extends Filesystem { protected function internalSetItem(&amp;$normalizedKey,&amp;$value) { $value = doSomethingWithValue($value); $normalizedKey = doSOmethingWithKey($normalizedKey); return parent::internalSetItem($normalizedKey,$value); } } If this looks familiar, using composition would look like this: use Laminas\\Cache\\Exception; use Laminas\\Cache\\Storage\\Adapter\\AbstractAdapter; use Laminas\\Cache\\Storage\\Adapter\\Filesystem; use Laminas\\Cache\\Storage\\Adapter\\FilesystemOptions; final class MyFilesytemStorage extends AbstractAdapter { /** * @var \\Laminas\\Cache\\Storage\\Adapter\\Filesystem */ private $filesystem; public function __construct(Filesystem $filesystem) { $this-&gt;filesystem = $filesystem; parent::__construct(); } protected function internalGetItem(&amp;$normalizedKey,&amp;$success = null,&amp;$casToken = null) { return $this-&gt;filesystem-&gt;getItem( $normalizedKey, $success, $casToken ); } protected function internalSetItem(&amp;$normalizedKey,&amp;$value) { $value = doSomethingWithValue($value); $normalizedKey = doSomethingWithValue($normalizedKey); return $this-&gt;filesystem-&gt;setItem( $normalizedKey, $value ); } protected function internalRemoveItem(&amp;$normalizedKey) { return $this-&gt;filesystem-&gt;removeItem( $normalizedKey ); } } Even tho, that this is more code to add/change than the previous solution, this gives the maintainers of the cache adapters more freedom to provide more stable adapter implementations. If this does not fit your requirements, please let us know via the laminas-cache repository on GitHub and tell us more about your implementations. Maybe your addition should be part of our official adapter or could be provided as a dedicated Plugin instead. StorageFactory Dependency In case your code heavily depends on StorageFactory (or if you are using not yet compatible laminas components (e.g. laminas-i18n , ...), Laminas got your back. With laminas/laminas-cache-storage-deprecated-factory , the StorageFactory is retained to create a temporary backwards compatibility layer.","title":"Migration to Version 3.0"},{"location":"v3/migration/to-version-3/#migration-to-version-30","text":"Upgrading to laminas-cache will require a few code-changes, depending on how the storage adapters were used. Please note that the migration guide assumes that laminas-cache is installed via Composer . Please check out the checklist to see what changes need to be done. The biggest change with laminas-cache v3.0 is that this component will be shipped without a specific cache adapter. The idea behind this is, that projects can freely choose those cache adapters they really use. In the past, most of the adapters Laminas does officially support were not properly tested, blocked PHP version upgrades (due to extensions lacking compatibility) and had to be maintained due to backwards compatibility. Starting with v3.0, all adapters can be maintained and evolve independently.","title":"Migration to Version 3.0"},{"location":"v3/migration/to-version-3/#checklist","text":"laminas-cache is updated to the latest version from within 2.x (currently 2.13.2 ) laminas-cli is installed to verify the configuration integrity ( vendor/bin/laminas laminas-cache:deprecation:check-storage-factory-config ); in case you don't want to use laminas-cli , please check out the normalized array configuration example in the release notes of 2.12.0 laminas-cache is required with ^3.0 within composer.json Cache adapters which are used within the project needs to be required in at least ^2.0 ; in case you don't know which adapters are in use, either check your project configuration or search for the Laminas\\Cache\\Storage\\Adapter namespace in your projects source code. Every adapter has to be listed in either your module.config.php (laminas-mvc) or config.php (mezzio) configuration. Project does not use any of the removed classes and traits Storage adapters are not extended in any way as all adapters are final starting with v2.0 of the individual adapter component PSR-6 CacheItemPoolDecorator does now validate the maximum key length the same way as PSR-6 SimpleCacheDecorator and therefore fulfills the requirements by the underlying PSR.","title":"Checklist"},{"location":"v3/migration/to-version-3/#new-features","text":"Each cache adapter has its own package . Support for PHP 8.1 PSR-6 CacheItemPoolDecorator validates the maximum key length.","title":"New Features"},{"location":"v3/migration/to-version-3/#removed-classes-and-traits","text":"With laminas-cache v3, some classes/traits were removed as well: Due to the switch to satellite packages , the StorageFactory was replaced with the StorageAdapterFactoryInterface . Due to the same reason, the PatternFactory was removed. Cache patterns mostly need an underlying adapter which have to be created with the new StorageAdapterFactoryInterface ClassCache cache pattern was removed. For more details, please read the related issue . PatternCacheFactory and StoragePatternCacheFactory which were introduced in v2.12.0 to provide forward compatibility. PatternPluginManager and PatternPluginManagerFactory which were removed due to the fact that most cache patterns require underlying cache adapter and thus are not instantiable from their name and options. PluginManagerLookupTrait which was used to provide forward compatibility for the StorageAdapterFactoryInterface . PatternOptions are not capable of the storage option anymore","title":"Removed Classes and Traits"},{"location":"v3/migration/to-version-3/#breaking-changes","text":"CallbackCache , OutputCache and ObjectCache now require the underlying cache adapter ( StorageInterface ) as 1st __construct dependency. The options can be passed via 2nd __construct)[https://github.com/CallbackCache , OutputCache and ObjectCache now require the underlying cache adapter ( StorageInterface arguments but are optional. Please note that it is not possible to inject the pattern configuration as an array anymore Storage configurations must be in a specific shape. For more details, head to the release notes of 2.12.0 All cache adapters are now marked as final and are not extensible anymore. In case that you are extending one of the cache adapters, please change your code as composition should be preferred over inheritance. For an example, please check out the composition over inheritance section. Due to the enhancement of CacheItemPoolDecorator , the maximum key length for the underlying cache adapter is validated before it is passed to the adapter. The SerializationTrait which was meant to be used by both PSR-6 and PSR-16 decorators is now marked as internal . The PCRE_MAXIMUM_QUANTIFIER_LENGTH constant of the SimpleCacheDecorator (which was marked as internal ) has now been moved to the new (also internal ) MaximumKeyLengthTrait and thus had to become a public static property (as traits do not support constants).","title":"Breaking Changes"},{"location":"v3/migration/to-version-3/#satellite-packages","text":"Starting with laminas-cache v3, we are introducing satellite packages for each cache backend. In order to make this package work, you have to specify at least one satellite package. A list of available cache adapters can be found here (starting with their v2 release): laminas/laminas-cache-storage-adapter-apcu laminas/laminas-cache-storage-adapter-blackhole laminas/laminas-cache-storage-adapter-ext-mongodb laminas/laminas-cache-storage-adapter-filesystem laminas/laminas-cache-storage-adapter-memcached laminas/laminas-cache-storage-adapter-memory laminas/laminas-cache-storage-adapter-redis laminas/laminas-cache-storage-adapter-session","title":"Satellite Packages"},{"location":"v3/migration/to-version-3/#composition-over-inheritance","text":"In case you are extending one of the cache implementations, your code might look as follows: use Laminas\\Cache\\Storage\\Adapter\\Filesystem; class MyFileystemStorage extends Filesystem { protected function internalSetItem(&amp;$normalizedKey,&amp;$value) { $value = doSomethingWithValue($value); $normalizedKey = doSOmethingWithKey($normalizedKey); return parent::internalSetItem($normalizedKey,$value); } } If this looks familiar, using composition would look like this: use Laminas\\Cache\\Exception; use Laminas\\Cache\\Storage\\Adapter\\AbstractAdapter; use Laminas\\Cache\\Storage\\Adapter\\Filesystem; use Laminas\\Cache\\Storage\\Adapter\\FilesystemOptions; final class MyFilesytemStorage extends AbstractAdapter { /** * @var \\Laminas\\Cache\\Storage\\Adapter\\Filesystem */ private $filesystem; public function __construct(Filesystem $filesystem) { $this-&gt;filesystem = $filesystem; parent::__construct(); } protected function internalGetItem(&amp;$normalizedKey,&amp;$success = null,&amp;$casToken = null) { return $this-&gt;filesystem-&gt;getItem( $normalizedKey, $success, $casToken ); } protected function internalSetItem(&amp;$normalizedKey,&amp;$value) { $value = doSomethingWithValue($value); $normalizedKey = doSomethingWithValue($normalizedKey); return $this-&gt;filesystem-&gt;setItem( $normalizedKey, $value ); } protected function internalRemoveItem(&amp;$normalizedKey) { return $this-&gt;filesystem-&gt;removeItem( $normalizedKey ); } } Even tho, that this is more code to add/change than the previous solution, this gives the maintainers of the cache adapters more freedom to provide more stable adapter implementations. If this does not fit your requirements, please let us know via the laminas-cache repository on GitHub and tell us more about your implementations. Maybe your addition should be part of our official adapter or could be provided as a dedicated Plugin instead.","title":"Composition Over Inheritance"},{"location":"v3/migration/to-version-3/#storagefactory-dependency","text":"In case your code heavily depends on StorageFactory (or if you are using not yet compatible laminas components (e.g. laminas-i18n , ...), Laminas got your back. With laminas/laminas-cache-storage-deprecated-factory , the StorageFactory is retained to create a temporary backwards compatibility layer.","title":"StorageFactory Dependency"},{"location":"v3/pattern/callback-cache/","text":"CallbackCache The callback cache pattern caches the results of arbitrary PHP callables. Quick Start use Laminas\\Cache\\Pattern\\CallbackCache; use Laminas\\Cache\\Pattern\\PatternOptions; // Or the equivalent manual instantiation: $callbackCache = new CallbackCache( $storage, new PatternOptions([ 'cache_output' =&gt; true, ]) ); Storage Adapter The $storage adapter can be any adapter which implements the StorageInterface . Check out the Pattern Quick Start -Section for a standard adapter which can be used here. Configuration Options Option Data Type Default Value Description storage string\\|array\\|Laminas\\Cache\\Storage\\StorageInterface none deprecated Adapter used for reading and writing cached data. cache_output bool true Whether or not to cache callback output. Examples Instantiating the Callback Cache Pattern use Laminas\\Cache\\Pattern\\CallbackCache; $callbackCache = new CallbackCache($storage); Available Methods In addition to the methods defined in the PatternInterface and the StorageCapableInterface , this implementation provides the following methods. namespace Laminas\\Cache\\Pattern; use Laminas\\Cache\\Exception; class CallbackCache extends AbstractStorageCapablePattern { /** * Call the specified callback or get the result from cache * * @param callable $callback A valid callback * @param array $args Callback arguments * @return mixed Result * @throws Exception\\RuntimeException if invalid cached data * @throws \\Exception */ public function call($callback, array $args = []); /** * Intercept method overloading; proxies to call() * * @param string $function Function name to call * @param array $args Function arguments * @return mixed * @throws Exception\\RuntimeException * @throws \\Exception */ public function __call($function, array $args); /** * Generate a unique key in base of a key representing the callback part * and a key representing the arguments part. * * @param callable $callback A valid callback * @param array $args Callback arguments * @return string * @throws Exception\\RuntimeException * @throws Exception\\InvalidArgumentException */ public function generateKey($callback, array $args = []); }","title":"CallbackCache"},{"location":"v3/pattern/callback-cache/#callbackcache","text":"The callback cache pattern caches the results of arbitrary PHP callables.","title":"CallbackCache"},{"location":"v3/pattern/callback-cache/#quick-start","text":"use Laminas\\Cache\\Pattern\\CallbackCache; use Laminas\\Cache\\Pattern\\PatternOptions; // Or the equivalent manual instantiation: $callbackCache = new CallbackCache( $storage, new PatternOptions([ 'cache_output' =&gt; true, ]) );","title":"Quick Start"},{"location":"v3/pattern/callback-cache/#configuration-options","text":"Option Data Type Default Value Description storage string\\|array\\|Laminas\\Cache\\Storage\\StorageInterface none deprecated Adapter used for reading and writing cached data. cache_output bool true Whether or not to cache callback output.","title":"Configuration Options"},{"location":"v3/pattern/callback-cache/#examples","text":"","title":"Examples"},{"location":"v3/pattern/callback-cache/#available-methods","text":"In addition to the methods defined in the PatternInterface and the StorageCapableInterface , this implementation provides the following methods. namespace Laminas\\Cache\\Pattern; use Laminas\\Cache\\Exception; class CallbackCache extends AbstractStorageCapablePattern { /** * Call the specified callback or get the result from cache * * @param callable $callback A valid callback * @param array $args Callback arguments * @return mixed Result * @throws Exception\\RuntimeException if invalid cached data * @throws \\Exception */ public function call($callback, array $args = []); /** * Intercept method overloading; proxies to call() * * @param string $function Function name to call * @param array $args Function arguments * @return mixed * @throws Exception\\RuntimeException * @throws \\Exception */ public function __call($function, array $args); /** * Generate a unique key in base of a key representing the callback part * and a key representing the arguments part. * * @param callable $callback A valid callback * @param array $args Callback arguments * @return string * @throws Exception\\RuntimeException * @throws Exception\\InvalidArgumentException */ public function generateKey($callback, array $args = []); }","title":"Available Methods"},{"location":"v3/pattern/capture-cache/","text":"CaptureCache The CaptureCache pattern is useful for generating static resources to return via HTTP request. When used in such a fashion, the web server needs to be configured to run a PHP script generating the requested resource so that subsequent requests for the same resource can be shipped without calling PHP again. This pattern comes with basic logic for managing generated resources. Quick Start For use with an Apache 404 handler extend the Apache configuration, e.g. .htdocs : ErrorDocument 404 /index.php And add the cache to the related application script, e.g. index.php : use Laminas\\Cache\\Pattern\\CaptureCache; use Laminas\\Cache\\Pattern\\PatternOptions; $capture = new CaptureCache( new PatternOptions([ 'public_dir' =&gt; __DIR__, ]) ); // Start capturing all output, excluding headers, and write to the public // directory: $capture-&gt;start(); // Don't forget to change the HTTP response code header('Status: 200', true, 200); // do stuff to dynamically generate output Configuration Options Option Data Type Default Value Description public_dir string none Location of the public web root directory in which to write output. index_filename string \"index.html\" The name of the index file if only a directory was requested. file_locking bool true Whether or not to lock output files when writing. file_permission int\\|false 0600 ( false on Windows) Default permissions for generated output files. dir_permission int\\|false 0700 ( false on Windows) Default permissions for generated output directories. umask int\\|false false Whether or not to umask generated output files / directories. Examples Scaling Images in the Web Root Using the following Apache 404 configuration: # .htdocs ErrorDocument 404 /index.php Use the following script: // index.php use Laminas\\Cache\\Pattern\\CaptureCache; use Laminas\\Cache\\Pattern\\PatternOptions; $capture = new CaptureCache( new PatternOptions([ 'public_dir' =&gt; __DIR__, ]) ); Available Methods In addition to the methods exposed in PatternInterface , this implementation exposes the following methods. namespace Laminas\\Cache\\Pattern; use Laminas\\Cache\\Exception; class CaptureCache extends AbstractPattern { /** * Start the cache. * * @param string $pageId Page identifier * @return void */ public function start($pageId = null); /** * Write a page to the requested path. * * @param string $content * @param null|string $pageId * @throws Exception\\LogicException */ public function set($content, $pageId = null); /** * Retrieve a generated page from the cache. * * @param null|string $pageId * @return string|null * @throws Exception\\LogicException * @throws Exception\\RuntimeException */ public function get($pageId = null); /** * Check if a cache exists for the given page. * * @param null|string $pageId * @throws Exception\\LogicException * @return bool */ public function has($pageId = null); /** * Remove a page from the cache. * * @param null|string $pageId * @throws Exception\\LogicException * @throws Exception\\RuntimeException * @return bool */ public function remove($pageId = null); /** * Clear cached pages that match the specified glob pattern. * * @param string $pattern * @throws Exception\\LogicException */ public function clearByGlob($pattern = '**'); /** * Returns the generated file name. * * @param null|string $pageId * @return string */ public function getFilename($pageId = null); }","title":"CaptureCache"},{"location":"v3/pattern/capture-cache/#capturecache","text":"The CaptureCache pattern is useful for generating static resources to return via HTTP request. When used in such a fashion, the web server needs to be configured to run a PHP script generating the requested resource so that subsequent requests for the same resource can be shipped without calling PHP again. This pattern comes with basic logic for managing generated resources.","title":"CaptureCache"},{"location":"v3/pattern/capture-cache/#quick-start","text":"For use with an Apache 404 handler extend the Apache configuration, e.g. .htdocs : ErrorDocument 404 /index.php And add the cache to the related application script, e.g. index.php : use Laminas\\Cache\\Pattern\\CaptureCache; use Laminas\\Cache\\Pattern\\PatternOptions; $capture = new CaptureCache( new PatternOptions([ 'public_dir' =&gt; __DIR__, ]) ); // Start capturing all output, excluding headers, and write to the public // directory: $capture-&gt;start(); // Don't forget to change the HTTP response code header('Status: 200', true, 200); // do stuff to dynamically generate output","title":"Quick Start"},{"location":"v3/pattern/capture-cache/#configuration-options","text":"Option Data Type Default Value Description public_dir string none Location of the public web root directory in which to write output. index_filename string \"index.html\" The name of the index file if only a directory was requested. file_locking bool true Whether or not to lock output files when writing. file_permission int\\|false 0600 ( false on Windows) Default permissions for generated output files. dir_permission int\\|false 0700 ( false on Windows) Default permissions for generated output directories. umask int\\|false false Whether or not to umask generated output files / directories.","title":"Configuration Options"},{"location":"v3/pattern/capture-cache/#examples","text":"","title":"Examples"},{"location":"v3/pattern/capture-cache/#available-methods","text":"In addition to the methods exposed in PatternInterface , this implementation exposes the following methods. namespace Laminas\\Cache\\Pattern; use Laminas\\Cache\\Exception; class CaptureCache extends AbstractPattern { /** * Start the cache. * * @param string $pageId Page identifier * @return void */ public function start($pageId = null); /** * Write a page to the requested path. * * @param string $content * @param null|string $pageId * @throws Exception\\LogicException */ public function set($content, $pageId = null); /** * Retrieve a generated page from the cache. * * @param null|string $pageId * @return string|null * @throws Exception\\LogicException * @throws Exception\\RuntimeException */ public function get($pageId = null); /** * Check if a cache exists for the given page. * * @param null|string $pageId * @throws Exception\\LogicException * @return bool */ public function has($pageId = null); /** * Remove a page from the cache. * * @param null|string $pageId * @throws Exception\\LogicException * @throws Exception\\RuntimeException * @return bool */ public function remove($pageId = null); /** * Clear cached pages that match the specified glob pattern. * * @param string $pattern * @throws Exception\\LogicException */ public function clearByGlob($pattern = '**'); /** * Returns the generated file name. * * @param null|string $pageId * @return string */ public function getFilename($pageId = null); }","title":"Available Methods"},{"location":"v3/pattern/intro/","text":"Introduction Cache patterns are configurable objects that solve known performance bottlenecks. Each should be used only in the specific situations they are designed to address. For example, you can use the CallbackCache or ObjectCache patterns to cache method and function calls; to cache output generation, the OutputCache pattern could assist. All cache patterns implement Laminas\\Cache\\Pattern\\PatternInterface , and most extend the abstract class Laminas\\Cache\\Pattern\\AbstractPattern , which provides common logic. Configuration is provided via the Laminas\\Cache\\Pattern\\PatternOptions class, which can be instantiated with an associative array of options passed to the constructor. To configure a pattern object, you can provide a Laminas\\Cache\\Pattern\\PatternOptions instance to the setOptions() method, or provide your options (either as an associative array or PatternOptions instance) to the second argument of the factory. It's also possible to use a single instance of Laminas\\Cache\\Pattern\\PatternOptions and pass it to multiple pattern objects. Quick Start Pattern objects can be created by instantiating one of the Laminas\\Cache\\Pattern\\*Cache classes. Standard Storage Adapter for Documentation A cache adapter needs a storage adapter. To be able to follow the examples in the documentation, the adapter for the filesystem or the BlackHole adapter can be used, for example. $storage = new Laminas\\Cache\\Storage\\Adapter\\Filesystem(); // or $storage = new Laminas\\Cache\\Storage\\Adapter\\BlackHole(); use Laminas\\Cache\\Pattern\\CallbackCache; use Laminas\\Cache\\Pattern\\PatternOptions; $callbackCache = new CallbackCache( $storage, new PatternOptions() ); Available Methods The following methods are implemented by every cache pattern. Please read documentation of specific patterns to get more information. namespace Laminas\\Cache\\Pattern; interface PatternInterface { /** * Get all pattern options * * @return PatternOptions */ public function getOptions(); } There are cache patterns which depend on a storage. In this case, these adapters implement the StorageCapableInterface : namespace Laminas\\Cache\\Pattern; use Laminas\\Cache\\Storage\\StorageInterface; interface StorageCapableInterface extends PatternInterface { public function getStorage(): ?StorageInterface; }","title":"Introduction"},{"location":"v3/pattern/intro/#introduction","text":"Cache patterns are configurable objects that solve known performance bottlenecks. Each should be used only in the specific situations they are designed to address. For example, you can use the CallbackCache or ObjectCache patterns to cache method and function calls; to cache output generation, the OutputCache pattern could assist. All cache patterns implement Laminas\\Cache\\Pattern\\PatternInterface , and most extend the abstract class Laminas\\Cache\\Pattern\\AbstractPattern , which provides common logic. Configuration is provided via the Laminas\\Cache\\Pattern\\PatternOptions class, which can be instantiated with an associative array of options passed to the constructor. To configure a pattern object, you can provide a Laminas\\Cache\\Pattern\\PatternOptions instance to the setOptions() method, or provide your options (either as an associative array or PatternOptions instance) to the second argument of the factory. It's also possible to use a single instance of Laminas\\Cache\\Pattern\\PatternOptions and pass it to multiple pattern objects.","title":"Introduction"},{"location":"v3/pattern/intro/#quick-start","text":"Pattern objects can be created by instantiating one of the Laminas\\Cache\\Pattern\\*Cache classes.","title":"Quick Start"},{"location":"v3/pattern/intro/#available-methods","text":"The following methods are implemented by every cache pattern. Please read documentation of specific patterns to get more information. namespace Laminas\\Cache\\Pattern; interface PatternInterface { /** * Get all pattern options * * @return PatternOptions */ public function getOptions(); } There are cache patterns which depend on a storage. In this case, these adapters implement the StorageCapableInterface : namespace Laminas\\Cache\\Pattern; use Laminas\\Cache\\Storage\\StorageInterface; interface StorageCapableInterface extends PatternInterface { public function getStorage(): ?StorageInterface; }","title":"Available Methods"},{"location":"v3/pattern/object-cache/","text":"ObjectCache The ObjectCache pattern is an extension to the CallbackCache pattern. It has the same methods, but instead caches output from any instance method calls or public properties. Quick Start use Laminas\\Cache\\Pattern\\ObjectCache; use Laminas\\Cache\\Pattern\\PatternOptions; use stdClass; $object = new stdClass(); $objectCache = new ObjectCache( $storage, new PatternOptions([ 'object' =&gt; $object, ]) ); Storage Adapter The $storage adapter can be any adapter which implements the StorageInterface . Check out the Pattern Quick Start -Section for a standard adapter which can be used here. Configuration Options Option Data Type Default Value Description storage string\\|array\\|Laminas\\Cache\\Storage\\StorageInterface none deprecated Adapter used for reading and writing cached data. object object none The object for which to cache method calls. object_key null\\|string Class name of object Hopefully unique! cache_output bool true Whether or not to cache method output. cache_by_default bool true Cache all method calls by default. object_cache_methods array [] List of methods to cache (if cache_by_default is disabled). object_non_cache_methods array [] List of methods to blacklist (if cache_by_default is enabled). object_cache_magic_properties bool false Whether or not to cache properties exposed by method overloading. Examples Caching a Filter use Laminas\\Cache\\Pattern\\ObjectCache; use Laminas\\Cache\\Pattern\\PatternOptions; $filter = new \\Laminas\\Filter\\RealPath(); $cachedFilter = new ObjectCache( $storage, new PatternOptions([ 'object' =&gt; $filter, 'object_key' =&gt; 'RealpathFilter', // The realpath filter doesn't output anything // so the output don't need to be caught and cached 'cache_output' =&gt; false, ]) ); $path = $cachedFilter-&gt;call(\"filter\", ['/www/var/path/../../mypath']); // OR $path = $cachedFilter-&gt;filter('/www/var/path/../../mypath'); Available Methods In addition to the methods defined in PatternInterface and the StorageCapableInterface , this implementation defines the following methods. namespace Laminas\\Cache\\Pattern; use Laminas\\Cache\\Exception; class ObjectCache extends CallbackCache { /** * Call and cache a class method * * @param string $method Method name to call * @param array $args Method arguments * @return mixed * @throws Exception\\RuntimeException * @throws \\Exception */ public function call($method, array $args = []); /** * Method overloading: proxies to call(). * * @param string $method Method name to call * @param array $args Method arguments * @return mixed * @throws Exception\\RuntimeException * @throws \\Exception */ public function __call($method, array $args); /** * Generate a unique key in base of a key representing the callback part * and a key representing the arguments part. * * @param string $method The method * @param array $args Callback arguments * @return string * @throws Exception\\RuntimeException */ public function generateKey($method, array $args = []); /** * Property overloading: write data to a named property. * * NOTE: * Magic properties will be cached too if the option cacheMagicProperties * is enabled and the property doesn't exist in real. If so it calls __set * and removes cached data of previous __get and __isset calls. * * @param string $name * @param mixed $value * @return void * @see http://php.net/manual/language.oop5.overloading.php#language.oop5.overloading.members */ public function __set($name, $value); /** * Property overloading: read data from a named property. * * NOTE: * Magic properties will be cached too if the option cacheMagicProperties * is enabled and the property doesn't exist in real. If so it calls __get. * * @param string $name * @return mixed * @see http://php.net/manual/language.oop5.overloading.php#language.oop5.overloading.members */ public function __get($name); /** * Property overloading: check if a named property exists. * * NOTE: * Magic properties will be cached too if the option cacheMagicProperties * is enabled and the property doesn't exist in real. If so it calls __get. * * @param string $name * @return bool * @see http://php.net/manual/language.oop5.overloading.php#language.oop5.overloading.members */ public function __isset($name); /** * Property overloading: unset a named property. * * NOTE: * Magic properties will be cached too if the option cacheMagicProperties * is enabled and the property doesn't exist in real. If so it removes * previous cached __isset and __get calls. * * @param string $name * @return void * @see http://php.net/manual/language.oop5.overloading.php#language.oop5.overloading.members */ public function __unset($name); /** * Handle casting to string * * @return string * @see http://php.net/manual/language.oop5.magic.php#language.oop5.magic.tostring */ public function __toString(); /** * Intercept and cache invokable usage. * * @return mixed * @see http://php.net/manual/language.oop5.magic.php#language.oop5.magic.invoke */ public function __invoke(); }","title":"ObjectCache"},{"location":"v3/pattern/object-cache/#objectcache","text":"The ObjectCache pattern is an extension to the CallbackCache pattern. It has the same methods, but instead caches output from any instance method calls or public properties.","title":"ObjectCache"},{"location":"v3/pattern/object-cache/#quick-start","text":"use Laminas\\Cache\\Pattern\\ObjectCache; use Laminas\\Cache\\Pattern\\PatternOptions; use stdClass; $object = new stdClass(); $objectCache = new ObjectCache( $storage, new PatternOptions([ 'object' =&gt; $object, ]) );","title":"Quick Start"},{"location":"v3/pattern/object-cache/#configuration-options","text":"Option Data Type Default Value Description storage string\\|array\\|Laminas\\Cache\\Storage\\StorageInterface none deprecated Adapter used for reading and writing cached data. object object none The object for which to cache method calls. object_key null\\|string Class name of object Hopefully unique! cache_output bool true Whether or not to cache method output. cache_by_default bool true Cache all method calls by default. object_cache_methods array [] List of methods to cache (if cache_by_default is disabled). object_non_cache_methods array [] List of methods to blacklist (if cache_by_default is enabled). object_cache_magic_properties bool false Whether or not to cache properties exposed by method overloading.","title":"Configuration Options"},{"location":"v3/pattern/object-cache/#examples","text":"","title":"Examples"},{"location":"v3/pattern/object-cache/#available-methods","text":"In addition to the methods defined in PatternInterface and the StorageCapableInterface , this implementation defines the following methods. namespace Laminas\\Cache\\Pattern; use Laminas\\Cache\\Exception; class ObjectCache extends CallbackCache { /** * Call and cache a class method * * @param string $method Method name to call * @param array $args Method arguments * @return mixed * @throws Exception\\RuntimeException * @throws \\Exception */ public function call($method, array $args = []); /** * Method overloading: proxies to call(). * * @param string $method Method name to call * @param array $args Method arguments * @return mixed * @throws Exception\\RuntimeException * @throws \\Exception */ public function __call($method, array $args); /** * Generate a unique key in base of a key representing the callback part * and a key representing the arguments part. * * @param string $method The method * @param array $args Callback arguments * @return string * @throws Exception\\RuntimeException */ public function generateKey($method, array $args = []); /** * Property overloading: write data to a named property. * * NOTE: * Magic properties will be cached too if the option cacheMagicProperties * is enabled and the property doesn't exist in real. If so it calls __set * and removes cached data of previous __get and __isset calls. * * @param string $name * @param mixed $value * @return void * @see http://php.net/manual/language.oop5.overloading.php#language.oop5.overloading.members */ public function __set($name, $value); /** * Property overloading: read data from a named property. * * NOTE: * Magic properties will be cached too if the option cacheMagicProperties * is enabled and the property doesn't exist in real. If so it calls __get. * * @param string $name * @return mixed * @see http://php.net/manual/language.oop5.overloading.php#language.oop5.overloading.members */ public function __get($name); /** * Property overloading: check if a named property exists. * * NOTE: * Magic properties will be cached too if the option cacheMagicProperties * is enabled and the property doesn't exist in real. If so it calls __get. * * @param string $name * @return bool * @see http://php.net/manual/language.oop5.overloading.php#language.oop5.overloading.members */ public function __isset($name); /** * Property overloading: unset a named property. * * NOTE: * Magic properties will be cached too if the option cacheMagicProperties * is enabled and the property doesn't exist in real. If so it removes * previous cached __isset and __get calls. * * @param string $name * @return void * @see http://php.net/manual/language.oop5.overloading.php#language.oop5.overloading.members */ public function __unset($name); /** * Handle casting to string * * @return string * @see http://php.net/manual/language.oop5.magic.php#language.oop5.magic.tostring */ public function __toString(); /** * Intercept and cache invokable usage. * * @return mixed * @see http://php.net/manual/language.oop5.magic.php#language.oop5.magic.invoke */ public function __invoke(); }","title":"Available Methods"},{"location":"v3/pattern/output-cache/","text":"OutputCache The OutputCache pattern caches output between calls to start() and end() . Quick Start use Laminas\\Cache\\Pattern\\OutputCache; use Laminas\\Cache\\Pattern\\PatternOptions; $outputCache = new OutputCache( $storage, new PatternOptions() ); Storage Adapter The $storage adapter can be any adapter which implements the StorageInterface . Check out the Pattern Quick Start -Section for a standard adapter which can be used here. Configuration Options Option Data Type Default Value Description storage string\\|array\\|Laminas\\Cache\\Storage\\StorageInterface none deprecated Adapter used for reading and writing cached data. Examples Caching a View Script use Laminas\\Cache\\Pattern\\OutputCache; use Laminas\\Cache\\Pattern\\PatternOptions; $outputCache = new OutputCache( $storage, new PatternOptions() ); $outputCache-&gt;start('mySimpleViewScript'); include '/path/to/view/script.phtml'; $outputCache-&gt;end(); Available Methods In addition to the methods defined in PatternInterface and StorageCapableInterface , this implementation defines the following methods. namespace Laminas\\Cache\\Pattern; use Laminas\\Cache\\Exception; class OutputCache extends AbstractStorageCapablePattern { /** * If there is a cached item with the given key, display its data, and * return true. Otherwise, start buffering output until end() is called, or * the script ends. * * @param string $key Key * @throws Exception\\MissingKeyException if key is missing * @return bool */ public function start($key); /** * Stop buffering output, write buffered data to the cache using the key * provided to start(), and display the buffer. * * @throws Exception\\RuntimeException if output cache not started or buffering not active * @return bool TRUE on success, FALSE on failure writing to cache */ public function end(); }","title":"OutputCache"},{"location":"v3/pattern/output-cache/#outputcache","text":"The OutputCache pattern caches output between calls to start() and end() .","title":"OutputCache"},{"location":"v3/pattern/output-cache/#quick-start","text":"use Laminas\\Cache\\Pattern\\OutputCache; use Laminas\\Cache\\Pattern\\PatternOptions; $outputCache = new OutputCache( $storage, new PatternOptions() );","title":"Quick Start"},{"location":"v3/pattern/output-cache/#configuration-options","text":"Option Data Type Default Value Description storage string\\|array\\|Laminas\\Cache\\Storage\\StorageInterface none deprecated Adapter used for reading and writing cached data.","title":"Configuration Options"},{"location":"v3/pattern/output-cache/#examples","text":"","title":"Examples"},{"location":"v3/pattern/output-cache/#available-methods","text":"In addition to the methods defined in PatternInterface and StorageCapableInterface , this implementation defines the following methods. namespace Laminas\\Cache\\Pattern; use Laminas\\Cache\\Exception; class OutputCache extends AbstractStorageCapablePattern { /** * If there is a cached item with the given key, display its data, and * return true. Otherwise, start buffering output until end() is called, or * the script ends. * * @param string $key Key * @throws Exception\\MissingKeyException if key is missing * @return bool */ public function start($key); /** * Stop buffering output, write buffered data to the cache using the key * provided to start(), and display the buffer. * * @throws Exception\\RuntimeException if output cache not started or buffering not active * @return bool TRUE on success, FALSE on failure writing to cache */ public function end(); }","title":"Available Methods"},{"location":"v3/storage/adapter/","text":"Adapters Storage adapters are wrappers for real storage resources such as memory or the filesystem, using the well known adapter pattern. They come with tons of methods to read, write, and modify stored items, and to get information about stored items and the storage. All adapters implement Laminas\\Cache\\Storage\\StorageInterface , and most extend Laminas\\Cache\\Storage\\Adapter\\AbstractAdapter , which provides a foundation of common logic. Configuration is handled by either Laminas\\Cache\\Storage\\Adapter\\AdapterOptions , or an adapter-specific options class if it exists. You may pass the options instance to the class at instantiation, via the setOptions() method, or, alternately, pass an associative array of options in either place (internally, these are then passed to an options class instance). Alternately, you can pass associative array to the Laminas\\Cache\\Service\\StorageAdapterFactoryInterface::create method. Quick Start Caching adapters can either be created from the provided Laminas\\Cache\\Service\\StorageAdapterFactoryInterface , or by instantiating one of the Laminas\\Cache\\Storage\\Adapter\\* classes. To make life easier, the Laminas\\Cache\\Service\\StorageAdapterFactoryInterface comes with a create() method to create an adapter and all requested plugins at once. use Laminas\\Cache\\Service\\StorageAdapterFactoryInterface; use Laminas\\Cache\\Service\\StoragePluginFactoryInterface; use Psr\\Container\\ContainerInterface; /** @var ContainerInterface $container */ $container = null; // can be any configured PSR-11 container /** @var StorageAdapterFactoryInterface $storageFactory */ $storageFactory = $container-&gt;get(StorageAdapterFactoryInterface::class); // Via factory: $cache = $storageFactory-&gt;create( 'apcu', ['ttl' =&gt; 3600], [ [ 'name' =&gt; 'exception_handler', 'options' =&gt; [ 'throw_exceptions' =&gt; false, ], ], ] ); // Via array configuration: $cache = $storageFactory-&gt;createFromArrayConfiguration([ 'adapter' =&gt; 'apcu', 'options' =&gt; ['ttl' =&gt; 3600], 'plugins' =&gt; [ [ 'name' =&gt; 'exception_handler', 'options' =&gt; [ 'throw_exceptions' =&gt; false, ], ], ], ]); // Alternately, create the adapter and plugin separately: $cache = $storageFactory-&gt;create('apcu', ['ttl' =&gt; 3600]); $pluginFactory = $container-&gt;get(StoragePluginFactoryInterface::class); $plugin = $pluginFactory-&gt;create('exception_handler', [ 'throw_exceptions' =&gt; false, ]); $cache-&gt;addPlugin($plugin); // Or do it completely manually: $cache = new Laminas\\Cache\\Storage\\Adapter\\Apcu(); $cache-&gt;getOptions()-&gt;setTtl(3600); $plugin = new Laminas\\Cache\\Storage\\Plugin\\ExceptionHandler(); $plugin-&gt;getOptions()-&gt;setThrowExceptions(false); $cache-&gt;addPlugin($plugin); Many Methods throw Exceptions Because many caching operations throw an exception on error, you need to catch them. You can do so manually, or you can use the plugin Laminas\\Cache\\Storage\\Plugin\\ExceptionHandler with throw_exceptions set to false to automatically catch them. You can also define an exception_callback to log exceptions. Basic Configuration Options The following configuration options are defined by Laminas\\Cache\\Storage\\Adapter\\AdapterOptions and are available for every supported adapter. Adapter-specific configuration options are described on adapter level below. Option Data Type Default Value Description ttl integer 0 Time to live namespace string “laminascache” The “namespace” in which cache items will live key_pattern null\\|string null Pattern against which to validate cache keys readable boolean true Enable/Disable reading data from cache writable boolean true Enable/Disable writing data to cache StorageInterface Laminas\\Cache\\Storage\\StorageInterface is the basic interface implemented by all storage adapters. namespace Laminas\\Cache\\Storage; use Traversable; interface StorageInterface { /** * Set options. * * @param array|Traversable|Adapter\\AdapterOptions $options * @return StorageInterface Fluent interface */ public function setOptions($options); /** * Get options * * @return Adapter\\AdapterOptions */ public function getOptions(); /* reading */ /** * Get an item. * * @param string $key * @param bool $success * @param mixed $casToken * @return mixed Data on success, null on failure * @throws \\Laminas\\Cache\\Exception\\ExceptionInterface */ public function getItem($key, &amp; $success = null, &amp; $casToken = null); /** * Get multiple items. * * @param array $keys * @return array Associative array of keys and values * @throws \\Laminas\\Cache\\Exception\\ExceptionInterface */ public function getItems(array $keys); /** * Test if an item exists. * * @param string $key * @return bool * @throws \\Laminas\\Cache\\Exception\\ExceptionInterface */ public function hasItem($key); /** * Test multiple items. * * @param array $keys * @return array Array of found keys * @throws \\Laminas\\Cache\\Exception\\ExceptionInterface */ public function hasItems(array $keys); /** * Get metadata of an item. * * @param string $key * @return array|bool Metadata on success, false on failure * @throws \\Laminas\\Cache\\Exception\\ExceptionInterface */ public function getMetadata($key); /** * Get multiple metadata * * @param array $keys * @return array Associative array of keys and metadata * @throws \\Laminas\\Cache\\Exception\\ExceptionInterface */ public function getMetadatas(array $keys); /* writing */ /** * Store an item. * * @param string $key * @param mixed $value * @return bool * @throws \\Laminas\\Cache\\Exception\\ExceptionInterface */ public function setItem($key, $value); /** * Store multiple items. * * @param array $keyValuePairs * @return array Array of not stored keys * @throws \\Laminas\\Cache\\Exception\\ExceptionInterface */ public function setItems(array $keyValuePairs); /** * Add an item. * * @param string $key * @param mixed $value * @return bool * @throws \\Laminas\\Cache\\Exception\\ExceptionInterface */ public function addItem($key, $value); /** * Add multiple items. * * @param array $keyValuePairs * @return array Array of not stored keys * @throws \\Laminas\\Cache\\Exception\\ExceptionInterface */ public function addItems(array $keyValuePairs); /** * Replace an existing item. * * @param string $key * @param mixed $value * @return bool * @throws \\Laminas\\Cache\\Exception\\ExceptionInterface */ public function replaceItem($key, $value); /** * Replace multiple existing items. * * @param array $keyValuePairs * @return array Array of not stored keys * @throws \\Laminas\\Cache\\Exception\\ExceptionInterface */ public function replaceItems(array $keyValuePairs); /** * Set an item only if token matches * * It uses the token received from getItem() to check if the item has * changed before overwriting it. * * @param mixed $token * @param string $key * @param mixed $value * @return bool * @throws \\Laminas\\Cache\\Exception\\ExceptionInterface * @see getItem() * @see setItem() */ public function checkAndSetItem($token, $key, $value); /** * Reset lifetime of an item * * @param string $key * @return bool * @throws \\Laminas\\Cache\\Exception\\ExceptionInterface */ public function touchItem($key); /** * Reset lifetime of multiple items. * * @param array $keys * @return array Array of not updated keys * @throws \\Laminas\\Cache\\Exception\\ExceptionInterface */ public function touchItems(array $keys); /** * Remove an item. * * @param string $key * @return bool * @throws \\Laminas\\Cache\\Exception\\ExceptionInterface */ public function removeItem($key); /** * Remove multiple items. * * @param array $keys * @return array Array of not removed keys * @throws \\Laminas\\Cache\\Exception\\ExceptionInterface */ public function removeItems(array $keys); /** * Increment an item. * * @param string $key * @param int $value * @return int|bool The new value on success, false on failure * @throws \\Laminas\\Cache\\Exception\\ExceptionInterface */ public function incrementItem($key, $value); /** * Increment multiple items. * * @param array $keyValuePairs * @return array Associative array of keys and new values * @throws \\Laminas\\Cache\\Exception\\ExceptionInterface */ public function incrementItems(array $keyValuePairs); /** * Decrement an item. * * @param string $key * @param int $value * @return int|bool The new value on success, false on failure * @throws \\Laminas\\Cache\\Exception\\ExceptionInterface */ public function decrementItem($key, $value); /** * Decrement multiple items. * * @param array $keyValuePairs * @return array Associative array of keys and new values * @throws \\Laminas\\Cache\\Exception\\ExceptionInterface */ public function decrementItems(array $keyValuePairs); /* status */ /** * Capabilities of this storage * * @return Capabilities */ public function getCapabilities(); } AvailableSpaceCapableInterface Laminas\\Cache\\Storage\\AvailableSpaceCapableInterface implements a method to allow retrieving the current available space remaining in storage. namespace Laminas\\Cache\\Storage; interface AvailableSpaceCapableInterface { /** * Get available space in bytes * * @return int|float */ public function getAvailableSpace(); } TotalSpaceCapableInterface Laminas\\Cache\\Storage\\TotalSpaceCapableInterface implements a method to allow retrieving the total storage space. namespace Laminas\\Cache\\Storage; interface TotalSpaceCapableInterface { /** * Get total space in bytes * * @return int|float */ public function getTotalSpace(); } ClearByNamespaceInterface Laminas\\Cache\\Storage\\ClearByNamespaceInterface implements a method to allow clearing all cached items within a given namespace. namespace Laminas\\Cache\\Storage; interface ClearByNamespaceInterface { /** * Remove items of given namespace * * @param string $namespace * @return bool */ public function clearByNamespace($namespace); } ClearByPrefixInterface Laminas\\Cache\\Storage\\ClearByPrefixInterface implements a method to allow clearing all cached items that have a given prefix (within the currently configured namespace). namespace Laminas\\Cache\\Storage; interface ClearByPrefixInterface { /** * Remove items matching given prefix * * @param string $prefix * @return bool */ public function clearByPrefix($prefix); } ClearExpiredInterface Laminas\\Cache\\Storage\\ClearExpiredInterface implements a method to allow clearing all expired items (within the current configured namespace). namespace Laminas\\Cache\\Storage; interface ClearExpiredInterface { /** * Remove expired items * * @return bool */ public function clearExpired(); } FlushableInterface Laminas\\Cache\\Storage\\FlushableInterface implements a method for flushing the entire cache storage. namespace Laminas\\Cache\\Storage; interface FlushableInterface { /** * Flush the whole storage * * @return bool */ public function flush(); } IterableInterface Laminas\\Cache\\Storage\\IterableInterface implements a method for retrieving an iterator of all items in storage. It extends IteratorAggregate , so it's possible to directly iterate over the storage implementations that implement this interface using foreach . namespace Laminas\\Cache\\Storage; use IteratorAggregate; /** * * @method IteratorInterface getIterator() Get the storage iterator */ interface IterableInterface extends IteratorAggregate { /** * @return \\Traversable */ public function getIterator(); } OptimizableInterface Laminas\\Cache\\Storage\\OptimizableInterface implements a method for running optimization processes on the storage adapter. namespace Laminas\\Cache\\Storage; interface OptimizableInterface { /** * Optimize the storage * * @return bool */ public function optimize(); } TaggableInterface Laminas\\Cache\\Storage\\TaggableInterface implements methods for tagging items, and cleaning (expiring) items matching tags. namespace Laminas\\Cache\\Storage; interface TaggableInterface { /** * Set tags to an item by given key. * An empty array will remove all tags. * * @param string $key * @param string[] $tags * @return bool */ public function setTags($key, array $tags); /** * Get tags of an item by given key * * @param string $key * @return string[]|FALSE */ public function getTags($key); /** * Remove items matching given tags. * * If $disjunction only one of the given tags must match * else all given tags must match. * * @param string[] $tags * @param bool $disjunction * @return bool */ public function clearByTags(array $tags, $disjunction = false); } APCu Adapter Laminas\\Cache\\Storage\\Adapter\\Apcu stores cache items in shared memory through the PHP extension APCu (Alternative PHP Cache). This adapter implements the following interfaces: Laminas\\Cache\\Storage\\StorageInterface Laminas\\Cache\\Storage\\AvailableSpaceCapableInterface Laminas\\Cache\\Storage\\ClearByNamespaceInterface Laminas\\Cache\\Storage\\ClearByPrefixInterface Laminas\\Cache\\Storage\\FlushableInterface Laminas\\Cache\\Storage\\IterableInterface Laminas\\Cache\\Storage\\TotalSpaceCapableInterface Capabilities Capability Value supportedDatatypes null , bool , int , float , string , array (serialized), object (serialized) supportedMetadata internal_key, atime, ctime, mtime, rtime, size, hits, ttl minTtl 1 maxTtl 0 staticTtl true ttlPrecision 1 useRequestTime value of apc.use_request_time from php.ini lockOnExpire 0 maxKeyLength 5182 namespaceIsPrefix true namespaceSeparator Option value of namespace_separator Adapter Specific Options Name Data Type Default Value Description namespace_separator string \":\" A separator for the namespace and prefix. BlackHole Adapter Laminas\\Cache\\Storage\\Adapter\\BlackHole does not store any cache items. This adapter is useful to bypass caching behavior. This might be the case in development mode or unit testing. This adapter implements the following interfaces: Laminas\\Cache\\Storage\\StorageInterface Laminas\\Cache\\Storage\\AvailableSpaceCapableInterface Laminas\\Cache\\Storage\\ClearByNamespaceInterface Laminas\\Cache\\Storage\\ClearByPrefixInterface Laminas\\Cache\\Storage\\ClearExpiredInterface Laminas\\Cache\\Storage\\FlushableInterface Laminas\\Cache\\Storage\\IterableInterface Laminas\\Cache\\Storage\\OptimizableInterface Laminas\\Cache\\Storage\\TaggableInterface Laminas\\Cache\\Storage\\TotalSpaceCapableInterface Capabilities Capability Value supportedDatatypes null , bool , int , float , string , array , object supportedMetadata none minTtl 0 or 1, depending on psr option. maxTtl 0 staticTtl false or true , depending on psr option ttlPrecision 1 useRequestTime false lockOnExpire 0 maxKeyLength -1 namespaceIsPrefix true namespaceSeparator none Adapter Specific Options Name Data Type Default Value Description psr bool false Flag to specify whether the adapter should be compatible with CacheItemPoolDecorator or SimpleCacheDecorator Deprecation Notice The psr option was introduce to provide non-BC compatible way to use the BlackHole adapter with the PSR-6 and PSR-16 decorator. Ignore this option if this adapter is not used in combination with these decorators. This option is already flagged as internal and thus will be removed in laminas/laminas-cache-storage-adapter-blackhole 2.0. Filesystem Adapter Laminas\\Cache\\Storage\\Adapter\\Filesystem stores cache items on the filesystem. This adapter implements the following interfaces: Laminas\\Cache\\Storage\\StorageInterface Laminas\\Cache\\Storage\\AvailableSpaceCapableInterface Laminas\\Cache\\Storage\\ClearByNamespaceInterface Laminas\\Cache\\Storage\\ClearByPrefixInterface Laminas\\Cache\\Storage\\ClearExpiredInterface Laminas\\Cache\\Storage\\FlushableInterface Laminas\\Cache\\Storage\\IterableInterface Laminas\\Cache\\Storage\\OptimizableInterface Laminas\\Cache\\Storage\\TaggableInterface Laminas\\Cache\\Storage\\TotalSpaceCapableInterface Capabilities Capability Value supportedDatatypes string , null =&gt; string , boolean =&gt; string , integer =&gt; string , double =&gt; string supportedMetadata mtime, filespec, atime, ctime minTtl 1 maxTtl 0 staticTtl false ttlPrecision 1 useRequestTime false lockOnExpire 0 maxKeyLength 251 namespaceIsPrefix true namespaceSeparator Option value of namespace_separator Adapter Specific Options Name Data Type Default Value Description namespace_separator string \":\" A separator for the namespace and prefix cache_dir string \"\" Directory to store cache files. clear_stat_cache boolean true Call clearstatcache() enabled? dir_level integer 1 Defines how much sub-directories should be created. dir_permission integer false 0700 Set explicit permission on creating new directories. file_locking boolean true Lock files on writing. file_permission integer false 0600 Set explicit permission on creating new files. key_pattern string /^[a-z0-9_\\+\\-]*$/Di Validate key against pattern. no_atime boolean true Don’t get ‘fileatime’ as ‘atime’ on metadata. no_ctime boolean true Don’t get ‘filectime’ as ‘ctime’ on metadata. umask integer\\|false false Use umask to set file and directory permissions. suffix string dat Suffix for cache files tag_suffix string tag Suffix for tag files Note: the suffix and tag_suffix options will be escaped in order to be safe for glob operations. Memcached Adapter Laminas\\Cache\\Storage\\Adapter\\Memcached stores cache items over the memcached protocol, using the PHP extension memcached , based on Libmemcached . This adapter implements the following interfaces: Laminas\\Cache\\Storage\\StorageInterface Laminas\\Cache\\Storage\\AvailableSpaceCapableInterface Laminas\\Cache\\Storage\\FlushableInterface Laminas\\Cache\\Storage\\TotalSpaceCapableInterface Capabilities Capability Value supportedDatatypes null , boolean , integer , double , string , array (serialized), object (serialized) supportedMetadata none minTtl 1 maxTtl 0 staticTtl true ttlPrecision 1 useRequestTime false lockOnExpire 0 maxKeyLength 255 namespaceIsPrefix true namespaceSeparator none Adapter Specific Options Name Data Type Default Value Description servers array [] List of servers in the format [] = [string host, integer port] lib_options array [] Associative array of Libmemcached options where the array key is the option name (without the prefix OPT_ ) or the constant value. The array value is the option value. Please read the memcached setOption() page for more information Redis Adapter Laminas\\Cache\\Storage\\Adapter\\Redis stores cache items over the Redis protocol using the PHP extension PhpRedis . This adapter implements the following interfaces: Laminas\\Cache\\Storage\\ClearByNamespaceInterface Laminas\\Cache\\Storage\\ClearByPrefixInterface Laminas\\Cache\\Storage\\FlushableInterface Laminas\\Cache\\Storage\\TotalSpaceCapableInterface Capabilities Capability Value supportedDatatypes string , array (serialized), object (serialized) supportedMetadata ttl (Redis v2+) minTtl 1 maxTtl 0 staticTtl true ttlPrecision 1 useRequestTime false lockOnExpire 0 maxKeyLength 512000000 (in Redis v3+, 255 otherwise) namespaceIsPrefix true namespaceSeparator none Adapter Specific Options Name Data Type Default Value Description database integer 0 Set database identifier. lib_options array [] Associative array of Redis options where the array key is the option name. namespace_separator string \":\" A separator for the namespace and prefix. password string \"\" Set password. persistent_id string Set persistent id (name of the connection, leave blank to not use a persistent connection). resource_manager string \"\" Set the Redis resource manager to use server string\\|array \"\" See below. server can be described as any of the following: Uri /path/to/sock.sock Associative array: ['host' =&gt; &lt;host&gt;[, 'port' =&gt; &lt;port&gt;[, 'timeout' =&gt; &lt;timeout&gt;]]] List: [&lt;host&gt;[, &lt;port&gt;, [, &lt;timeout&gt;]]] RedisCluster Adapter Laminas\\Cache\\Storage\\Adapter\\RedisCluster stores cache items over the Redis cluster protocol using the PHP extension PhpRedis . This adapter implements the following interfaces: Laminas\\Cache\\Storage\\ClearByNamespaceInterface Laminas\\Cache\\Storage\\ClearByPrefixInterface Laminas\\Cache\\Storage\\FlushableInterface Capabilities Capability Value supportedDatatypes string , array (serialized), object (serialized) supportedMetadata ttl (Redis v2+) minTtl 1 maxTtl 0 staticTtl true ttlPrecision 1 useRequestTime false lockOnExpire 0 maxKeyLength 512000000 (in Redis v3+, 255 otherwise) namespaceIsPrefix true namespaceSeparator none Adapter Specific Options Name Data Type Default Value Description lib_options array [] Associative array of Redis options where the array key is the options constant value (see RedisCluster::OPT_* constants for details). namespace_separator string \":\" A separator for the namespace and prefix. password string \"\" Password to authenticate with Redis server name string \"\" Name to determine configuration from php.ini ( MUST NOT be combined with seeds ) seeds array [] List of strings containing &lt;hostname&gt;:&lt;port&gt; ( MUST NOT be combined with name ) timeout float 1.0 Timeout for commands, see PhpRedis timeouts documentation for more background. read_timeout float 2.0 Read timeout for commands, see PhpRedis timeouts documentation for more background. persistent bool false Flag to specify whether to create a persistent connection or not version string \"\" The Redis server version. MUST be specified in a Semantic Versioning 2.0.0 format. This information is used to determine some features/capabilities without opening a connection to the server. ssl_context array\\|SslContext\\|null null Associative array with SSL context options. Can be also an instance of SslContext (class available from within the redis adapter). Available since adapter version v2.8.0. Memory Adapter The Laminas\\Cache\\Storage\\Adapter\\Memory stores items in-memory in the current process only. This adapter implements the following interfaces: Laminas\\Cache\\Storage\\StorageInterface Laminas\\Cache\\Storage\\AvailableSpaceCapableInterface Laminas\\Cache\\Storage\\ClearByPrefixInterface Laminas\\Cache\\Storage\\ClearExpiredInterface Laminas\\Cache\\Storage\\FlushableInterface Laminas\\Cache\\Storage\\IterableInterface Laminas\\Cache\\Storage\\TaggableInterface Laminas\\Cache\\Storage\\TotalSpaceCapableInterface Capabilities Capability Value supportedDatatypes string , null , boolean , integer , double , array , object , resource supportedMetadata mtime minTtl 1 maxTtl Value of PHP_INT_MAX staticTtl false ttlPrecision 0.05 useRequestTime false lockOnExpire 0 maxKeyLength 0 namespaceIsPrefix false Adapter Specific Options Name Data Type Default Value Description memory_limit string\\|integer 50% of memory_limit INI value Limit of how much memory can PHP allocate to allow store items. Memory Limit The adapter has the following behavior with regards to the memory limit: If the consumed memory exceeds the limit provided, an OutOfSpaceException is thrown. A number less the or equal to zero disables the memory limit. When a value is provided for the memory limit, the value is measured in bytes. Shorthand notation may also be provided. Current process only All stored items will be lost on termination of the script. For web-facing requests, this typically means the cache is volatile. ExtMongoDB Adapter Available since version 2.8.0 Laminas\\Cache\\Storage\\Adapter\\ExtMongoDB stores cache items using the mongodb extension, and requires that the MongoDB PHP Client library is also installed. You can install the client library using the following: $ composer require mongodb/mongodb This adapter implements the following interfaces: Laminas\\Cache\\Storage\\FlushableInterface Capabilities Capability Value supportedDatatypes string , null , boolean , integer , double , array supportedMetadata _id minTtl 0 maxTtl 0 staticTtl true ttlPrecision 1 useRequestTime false lockOnExpire 0 maxKeyLength 255 namespaceIsPrefix true namespaceSeparator Option value of namespace_separator Adapter Specific Options Name Data Type Default Value Description lib_option array Associative array of options where the array key is the option name. namespace_separator string \":\" A separator for the namespace and prefix. Available keys for lib_option include: Key Default Description server mongodb://localhost:27017 The MongoDB server connection string (see the MongoDB\\Client docs ). database laminas Name of the database to use; MongoDB will create this database if it does not exist. collection cache Name of the collection to use; MongoDB will create this collection if it does not exist. connectionOptions ['fsync' =&gt; false, 'journal' =&gt; true] Associative array of URI options (such as authentication credentials or query string parameters) to pass to MongoDB\\\\Client (see the MongoDB\\Client docs ). driverOptions [] Associative array of driver options to pass to MongoDB\\\\Client (see the MongoDB\\Client docs ). Examples Basic Usage use Laminas\\Cache\\Service\\StorageAdapterFactoryInterface; use Psr\\Container\\ContainerInterface; /** @var ContainerInterface $container */ $container = null; // can be any configured PSR-11 container /** @var StorageAdapterFactoryInterface $storageFactory */ $storageFactory = $container-&gt;get(StorageAdapterFactoryInterface::class); $cache = $storageFactory-&gt;create( 'filesystem', [], [ // Don't throw exceptions on cache errors [ 'name' =&gt; 'exception_handler', 'options' =&gt; [ 'throw_exceptions' =&gt; false ], ], ] ); $key = 'unique-cache-key'; $result = $cache-&gt;getItem($key, $success); if (! $success) { $result = doExpensiveStuff(); $cache-&gt;setItem($key, $result); } Get multiple Rows from a Database use Laminas\\Cache\\Service\\StorageAdapterFactoryInterface; use Psr\\Container\\ContainerInterface; /** @var ContainerInterface $container */ $container = null; // can be any configured PSR-11 container /** @var StorageAdapterFactoryInterface $storageFactory */ $storageFactory = $container-&gt;get(StorageAdapterFactoryInterface::class); // Instantiate the cache instance using a namespace for the same type of items $cache = $storageFactory-&gt;create( 'filesystem', // With a namespace, we can indicate the same type of items, // so we can simply use the database id as the cache key [ 'namespace' =&gt; 'dbtable', ], [ // Don't throw exceptions on cache errors [ 'name' =&gt; 'exception_handler', 'options' =&gt; [ 'throw_exceptions' =&gt; false, ], ], // We store database rows on filesystem so we need to serialize them [ 'name' =&gt; 'Serializer', ], ] ); // Load two rows from cache if possible $ids = [1, 2]; $results = $cache-&gt;getItems($ids); if (count($results) &lt; count($ids)) { // Load rows from db if loading from cache failed $missingIds = array_diff($ids, array_keys($results)); $missingResults = []; $query = 'SELECT * FROM dbtable WHERE id IN (' . implode(',', $missingIds) . ')'; foreach ($pdo-&gt;query($query, PDO::FETCH_ASSOC) as $row) { $missingResults[ $row['id'] ] = $row; } // Update cache items of the loaded rows from db $cache-&gt;setItems($missingResults); // merge results from cache and db $results = array_merge($results, $missingResults); }","title":"Adapters"},{"location":"v3/storage/adapter/#adapters","text":"Storage adapters are wrappers for real storage resources such as memory or the filesystem, using the well known adapter pattern. They come with tons of methods to read, write, and modify stored items, and to get information about stored items and the storage. All adapters implement Laminas\\Cache\\Storage\\StorageInterface , and most extend Laminas\\Cache\\Storage\\Adapter\\AbstractAdapter , which provides a foundation of common logic. Configuration is handled by either Laminas\\Cache\\Storage\\Adapter\\AdapterOptions , or an adapter-specific options class if it exists. You may pass the options instance to the class at instantiation, via the setOptions() method, or, alternately, pass an associative array of options in either place (internally, these are then passed to an options class instance). Alternately, you can pass associative array to the Laminas\\Cache\\Service\\StorageAdapterFactoryInterface::create method.","title":"Adapters"},{"location":"v3/storage/adapter/#quick-start","text":"Caching adapters can either be created from the provided Laminas\\Cache\\Service\\StorageAdapterFactoryInterface , or by instantiating one of the Laminas\\Cache\\Storage\\Adapter\\* classes. To make life easier, the Laminas\\Cache\\Service\\StorageAdapterFactoryInterface comes with a create() method to create an adapter and all requested plugins at once. use Laminas\\Cache\\Service\\StorageAdapterFactoryInterface; use Laminas\\Cache\\Service\\StoragePluginFactoryInterface; use Psr\\Container\\ContainerInterface; /** @var ContainerInterface $container */ $container = null; // can be any configured PSR-11 container /** @var StorageAdapterFactoryInterface $storageFactory */ $storageFactory = $container-&gt;get(StorageAdapterFactoryInterface::class); // Via factory: $cache = $storageFactory-&gt;create( 'apcu', ['ttl' =&gt; 3600], [ [ 'name' =&gt; 'exception_handler', 'options' =&gt; [ 'throw_exceptions' =&gt; false, ], ], ] ); // Via array configuration: $cache = $storageFactory-&gt;createFromArrayConfiguration([ 'adapter' =&gt; 'apcu', 'options' =&gt; ['ttl' =&gt; 3600], 'plugins' =&gt; [ [ 'name' =&gt; 'exception_handler', 'options' =&gt; [ 'throw_exceptions' =&gt; false, ], ], ], ]); // Alternately, create the adapter and plugin separately: $cache = $storageFactory-&gt;create('apcu', ['ttl' =&gt; 3600]); $pluginFactory = $container-&gt;get(StoragePluginFactoryInterface::class); $plugin = $pluginFactory-&gt;create('exception_handler', [ 'throw_exceptions' =&gt; false, ]); $cache-&gt;addPlugin($plugin); // Or do it completely manually: $cache = new Laminas\\Cache\\Storage\\Adapter\\Apcu(); $cache-&gt;getOptions()-&gt;setTtl(3600); $plugin = new Laminas\\Cache\\Storage\\Plugin\\ExceptionHandler(); $plugin-&gt;getOptions()-&gt;setThrowExceptions(false); $cache-&gt;addPlugin($plugin);","title":"Quick Start"},{"location":"v3/storage/adapter/#basic-configuration-options","text":"The following configuration options are defined by Laminas\\Cache\\Storage\\Adapter\\AdapterOptions and are available for every supported adapter. Adapter-specific configuration options are described on adapter level below. Option Data Type Default Value Description ttl integer 0 Time to live namespace string “laminascache” The “namespace” in which cache items will live key_pattern null\\|string null Pattern against which to validate cache keys readable boolean true Enable/Disable reading data from cache writable boolean true Enable/Disable writing data to cache","title":"Basic Configuration Options"},{"location":"v3/storage/adapter/#storageinterface","text":"Laminas\\Cache\\Storage\\StorageInterface is the basic interface implemented by all storage adapters. namespace Laminas\\Cache\\Storage; use Traversable; interface StorageInterface { /** * Set options. * * @param array|Traversable|Adapter\\AdapterOptions $options * @return StorageInterface Fluent interface */ public function setOptions($options); /** * Get options * * @return Adapter\\AdapterOptions */ public function getOptions(); /* reading */ /** * Get an item. * * @param string $key * @param bool $success * @param mixed $casToken * @return mixed Data on success, null on failure * @throws \\Laminas\\Cache\\Exception\\ExceptionInterface */ public function getItem($key, &amp; $success = null, &amp; $casToken = null); /** * Get multiple items. * * @param array $keys * @return array Associative array of keys and values * @throws \\Laminas\\Cache\\Exception\\ExceptionInterface */ public function getItems(array $keys); /** * Test if an item exists. * * @param string $key * @return bool * @throws \\Laminas\\Cache\\Exception\\ExceptionInterface */ public function hasItem($key); /** * Test multiple items. * * @param array $keys * @return array Array of found keys * @throws \\Laminas\\Cache\\Exception\\ExceptionInterface */ public function hasItems(array $keys); /** * Get metadata of an item. * * @param string $key * @return array|bool Metadata on success, false on failure * @throws \\Laminas\\Cache\\Exception\\ExceptionInterface */ public function getMetadata($key); /** * Get multiple metadata * * @param array $keys * @return array Associative array of keys and metadata * @throws \\Laminas\\Cache\\Exception\\ExceptionInterface */ public function getMetadatas(array $keys); /* writing */ /** * Store an item. * * @param string $key * @param mixed $value * @return bool * @throws \\Laminas\\Cache\\Exception\\ExceptionInterface */ public function setItem($key, $value); /** * Store multiple items. * * @param array $keyValuePairs * @return array Array of not stored keys * @throws \\Laminas\\Cache\\Exception\\ExceptionInterface */ public function setItems(array $keyValuePairs); /** * Add an item. * * @param string $key * @param mixed $value * @return bool * @throws \\Laminas\\Cache\\Exception\\ExceptionInterface */ public function addItem($key, $value); /** * Add multiple items. * * @param array $keyValuePairs * @return array Array of not stored keys * @throws \\Laminas\\Cache\\Exception\\ExceptionInterface */ public function addItems(array $keyValuePairs); /** * Replace an existing item. * * @param string $key * @param mixed $value * @return bool * @throws \\Laminas\\Cache\\Exception\\ExceptionInterface */ public function replaceItem($key, $value); /** * Replace multiple existing items. * * @param array $keyValuePairs * @return array Array of not stored keys * @throws \\Laminas\\Cache\\Exception\\ExceptionInterface */ public function replaceItems(array $keyValuePairs); /** * Set an item only if token matches * * It uses the token received from getItem() to check if the item has * changed before overwriting it. * * @param mixed $token * @param string $key * @param mixed $value * @return bool * @throws \\Laminas\\Cache\\Exception\\ExceptionInterface * @see getItem() * @see setItem() */ public function checkAndSetItem($token, $key, $value); /** * Reset lifetime of an item * * @param string $key * @return bool * @throws \\Laminas\\Cache\\Exception\\ExceptionInterface */ public function touchItem($key); /** * Reset lifetime of multiple items. * * @param array $keys * @return array Array of not updated keys * @throws \\Laminas\\Cache\\Exception\\ExceptionInterface */ public function touchItems(array $keys); /** * Remove an item. * * @param string $key * @return bool * @throws \\Laminas\\Cache\\Exception\\ExceptionInterface */ public function removeItem($key); /** * Remove multiple items. * * @param array $keys * @return array Array of not removed keys * @throws \\Laminas\\Cache\\Exception\\ExceptionInterface */ public function removeItems(array $keys); /** * Increment an item. * * @param string $key * @param int $value * @return int|bool The new value on success, false on failure * @throws \\Laminas\\Cache\\Exception\\ExceptionInterface */ public function incrementItem($key, $value); /** * Increment multiple items. * * @param array $keyValuePairs * @return array Associative array of keys and new values * @throws \\Laminas\\Cache\\Exception\\ExceptionInterface */ public function incrementItems(array $keyValuePairs); /** * Decrement an item. * * @param string $key * @param int $value * @return int|bool The new value on success, false on failure * @throws \\Laminas\\Cache\\Exception\\ExceptionInterface */ public function decrementItem($key, $value); /** * Decrement multiple items. * * @param array $keyValuePairs * @return array Associative array of keys and new values * @throws \\Laminas\\Cache\\Exception\\ExceptionInterface */ public function decrementItems(array $keyValuePairs); /* status */ /** * Capabilities of this storage * * @return Capabilities */ public function getCapabilities(); }","title":"StorageInterface"},{"location":"v3/storage/adapter/#availablespacecapableinterface","text":"Laminas\\Cache\\Storage\\AvailableSpaceCapableInterface implements a method to allow retrieving the current available space remaining in storage. namespace Laminas\\Cache\\Storage; interface AvailableSpaceCapableInterface { /** * Get available space in bytes * * @return int|float */ public function getAvailableSpace(); }","title":"AvailableSpaceCapableInterface"},{"location":"v3/storage/adapter/#totalspacecapableinterface","text":"Laminas\\Cache\\Storage\\TotalSpaceCapableInterface implements a method to allow retrieving the total storage space. namespace Laminas\\Cache\\Storage; interface TotalSpaceCapableInterface { /** * Get total space in bytes * * @return int|float */ public function getTotalSpace(); }","title":"TotalSpaceCapableInterface"},{"location":"v3/storage/adapter/#clearbynamespaceinterface","text":"Laminas\\Cache\\Storage\\ClearByNamespaceInterface implements a method to allow clearing all cached items within a given namespace. namespace Laminas\\Cache\\Storage; interface ClearByNamespaceInterface { /** * Remove items of given namespace * * @param string $namespace * @return bool */ public function clearByNamespace($namespace); }","title":"ClearByNamespaceInterface"},{"location":"v3/storage/adapter/#clearbyprefixinterface","text":"Laminas\\Cache\\Storage\\ClearByPrefixInterface implements a method to allow clearing all cached items that have a given prefix (within the currently configured namespace). namespace Laminas\\Cache\\Storage; interface ClearByPrefixInterface { /** * Remove items matching given prefix * * @param string $prefix * @return bool */ public function clearByPrefix($prefix); }","title":"ClearByPrefixInterface"},{"location":"v3/storage/adapter/#clearexpiredinterface","text":"Laminas\\Cache\\Storage\\ClearExpiredInterface implements a method to allow clearing all expired items (within the current configured namespace). namespace Laminas\\Cache\\Storage; interface ClearExpiredInterface { /** * Remove expired items * * @return bool */ public function clearExpired(); }","title":"ClearExpiredInterface"},{"location":"v3/storage/adapter/#flushableinterface","text":"Laminas\\Cache\\Storage\\FlushableInterface implements a method for flushing the entire cache storage. namespace Laminas\\Cache\\Storage; interface FlushableInterface { /** * Flush the whole storage * * @return bool */ public function flush(); }","title":"FlushableInterface"},{"location":"v3/storage/adapter/#iterableinterface","text":"Laminas\\Cache\\Storage\\IterableInterface implements a method for retrieving an iterator of all items in storage. It extends IteratorAggregate , so it's possible to directly iterate over the storage implementations that implement this interface using foreach . namespace Laminas\\Cache\\Storage; use IteratorAggregate; /** * * @method IteratorInterface getIterator() Get the storage iterator */ interface IterableInterface extends IteratorAggregate { /** * @return \\Traversable */ public function getIterator(); }","title":"IterableInterface"},{"location":"v3/storage/adapter/#optimizableinterface","text":"Laminas\\Cache\\Storage\\OptimizableInterface implements a method for running optimization processes on the storage adapter. namespace Laminas\\Cache\\Storage; interface OptimizableInterface { /** * Optimize the storage * * @return bool */ public function optimize(); }","title":"OptimizableInterface"},{"location":"v3/storage/adapter/#taggableinterface","text":"Laminas\\Cache\\Storage\\TaggableInterface implements methods for tagging items, and cleaning (expiring) items matching tags. namespace Laminas\\Cache\\Storage; interface TaggableInterface { /** * Set tags to an item by given key. * An empty array will remove all tags. * * @param string $key * @param string[] $tags * @return bool */ public function setTags($key, array $tags); /** * Get tags of an item by given key * * @param string $key * @return string[]|FALSE */ public function getTags($key); /** * Remove items matching given tags. * * If $disjunction only one of the given tags must match * else all given tags must match. * * @param string[] $tags * @param bool $disjunction * @return bool */ public function clearByTags(array $tags, $disjunction = false); }","title":"TaggableInterface"},{"location":"v3/storage/adapter/#apcu-adapter","text":"Laminas\\Cache\\Storage\\Adapter\\Apcu stores cache items in shared memory through the PHP extension APCu (Alternative PHP Cache). This adapter implements the following interfaces: Laminas\\Cache\\Storage\\StorageInterface Laminas\\Cache\\Storage\\AvailableSpaceCapableInterface Laminas\\Cache\\Storage\\ClearByNamespaceInterface Laminas\\Cache\\Storage\\ClearByPrefixInterface Laminas\\Cache\\Storage\\FlushableInterface Laminas\\Cache\\Storage\\IterableInterface Laminas\\Cache\\Storage\\TotalSpaceCapableInterface","title":"APCu Adapter"},{"location":"v3/storage/adapter/#blackhole-adapter","text":"Laminas\\Cache\\Storage\\Adapter\\BlackHole does not store any cache items. This adapter is useful to bypass caching behavior. This might be the case in development mode or unit testing. This adapter implements the following interfaces: Laminas\\Cache\\Storage\\StorageInterface Laminas\\Cache\\Storage\\AvailableSpaceCapableInterface Laminas\\Cache\\Storage\\ClearByNamespaceInterface Laminas\\Cache\\Storage\\ClearByPrefixInterface Laminas\\Cache\\Storage\\ClearExpiredInterface Laminas\\Cache\\Storage\\FlushableInterface Laminas\\Cache\\Storage\\IterableInterface Laminas\\Cache\\Storage\\OptimizableInterface Laminas\\Cache\\Storage\\TaggableInterface Laminas\\Cache\\Storage\\TotalSpaceCapableInterface","title":"BlackHole Adapter"},{"location":"v3/storage/adapter/#filesystem-adapter","text":"Laminas\\Cache\\Storage\\Adapter\\Filesystem stores cache items on the filesystem. This adapter implements the following interfaces: Laminas\\Cache\\Storage\\StorageInterface Laminas\\Cache\\Storage\\AvailableSpaceCapableInterface Laminas\\Cache\\Storage\\ClearByNamespaceInterface Laminas\\Cache\\Storage\\ClearByPrefixInterface Laminas\\Cache\\Storage\\ClearExpiredInterface Laminas\\Cache\\Storage\\FlushableInterface Laminas\\Cache\\Storage\\IterableInterface Laminas\\Cache\\Storage\\OptimizableInterface Laminas\\Cache\\Storage\\TaggableInterface Laminas\\Cache\\Storage\\TotalSpaceCapableInterface","title":"Filesystem Adapter"},{"location":"v3/storage/adapter/#memcached-adapter","text":"Laminas\\Cache\\Storage\\Adapter\\Memcached stores cache items over the memcached protocol, using the PHP extension memcached , based on Libmemcached . This adapter implements the following interfaces: Laminas\\Cache\\Storage\\StorageInterface Laminas\\Cache\\Storage\\AvailableSpaceCapableInterface Laminas\\Cache\\Storage\\FlushableInterface Laminas\\Cache\\Storage\\TotalSpaceCapableInterface","title":"Memcached Adapter"},{"location":"v3/storage/adapter/#redis-adapter","text":"Laminas\\Cache\\Storage\\Adapter\\Redis stores cache items over the Redis protocol using the PHP extension PhpRedis . This adapter implements the following interfaces: Laminas\\Cache\\Storage\\ClearByNamespaceInterface Laminas\\Cache\\Storage\\ClearByPrefixInterface Laminas\\Cache\\Storage\\FlushableInterface Laminas\\Cache\\Storage\\TotalSpaceCapableInterface","title":"Redis Adapter"},{"location":"v3/storage/adapter/#rediscluster-adapter","text":"Laminas\\Cache\\Storage\\Adapter\\RedisCluster stores cache items over the Redis cluster protocol using the PHP extension PhpRedis . This adapter implements the following interfaces: Laminas\\Cache\\Storage\\ClearByNamespaceInterface Laminas\\Cache\\Storage\\ClearByPrefixInterface Laminas\\Cache\\Storage\\FlushableInterface","title":"RedisCluster Adapter"},{"location":"v3/storage/adapter/#memory-adapter","text":"The Laminas\\Cache\\Storage\\Adapter\\Memory stores items in-memory in the current process only. This adapter implements the following interfaces: Laminas\\Cache\\Storage\\StorageInterface Laminas\\Cache\\Storage\\AvailableSpaceCapableInterface Laminas\\Cache\\Storage\\ClearByPrefixInterface Laminas\\Cache\\Storage\\ClearExpiredInterface Laminas\\Cache\\Storage\\FlushableInterface Laminas\\Cache\\Storage\\IterableInterface Laminas\\Cache\\Storage\\TaggableInterface Laminas\\Cache\\Storage\\TotalSpaceCapableInterface","title":"Memory Adapter"},{"location":"v3/storage/adapter/#extmongodb-adapter","text":"Available since version 2.8.0 Laminas\\Cache\\Storage\\Adapter\\ExtMongoDB stores cache items using the mongodb extension, and requires that the MongoDB PHP Client library is also installed. You can install the client library using the following: $ composer require mongodb/mongodb This adapter implements the following interfaces: Laminas\\Cache\\Storage\\FlushableInterface","title":"ExtMongoDB Adapter"},{"location":"v3/storage/adapter/#examples","text":"","title":"Examples"},{"location":"v3/storage/capabilities/","text":"Storage Capabilities Storage capabilities describe how a storage adapter works, and which features it supports. To get capabilities of a storage adapter, you can use the method getCapabilities() , but only the storage adapter and its plugins have permissions to change them. Because capabilities are mutable, you can subscribe to the \"change\" event to get notifications; see the examples for details. If you are writing your own plugin or adapter, you can also change capabilities because you have access to the marker object and can create your own marker to instantiate a new instance of Laminas\\Cache\\Storage\\Capabilities . Available Methods namespace Laminas\\Cache\\Storage; use ArrayObject; use stdClass; use Laminas\\Cache\\Exception; use Laminas\\EventManager\\EventsCapableInterface; class Capabilities { /** * Constructor * * @param StorageInterface $storage * @param stdClass $marker * @param array $capabilities * @param null|Capabilities $baseCapabilities */ public function __construct( StorageInterface $storage, stdClass $marker, array $capabilities = [], Capabilities $baseCapabilities = null ); /** * Get the storage adapter * * @return StorageInterface */ public function getAdapter(); /** * Get supported datatypes * * @return array */ public function getSupportedDatatypes(); /** * Set supported datatypes * * @param stdClass $marker * @param array $datatypes * @throws Exception\\InvalidArgumentException * @return Capabilities Fluent interface */ public function setSupportedDatatypes(stdClass $marker, array $datatypes); /** * Get supported metadata * * @return array */ public function getSupportedMetadata(); /** * Set supported metadata * * @param stdClass $marker * @param string[] $metadata * @throws Exception\\InvalidArgumentException * @return Capabilities Fluent interface */ public function setSupportedMetadata(stdClass $marker, array $metadata); /** * Get minimum supported time-to-live * * @return int 0 means items never expire */ public function getMinTtl(); /** * Set minimum supported time-to-live * * @param stdClass $marker * @param int $minTtl * @throws Exception\\InvalidArgumentException * @return Capabilities Fluent interface */ public function setMinTtl(stdClass $marker, $minTtl); /** * Get maximum supported time-to-live * * @return int 0 means infinite */ public function getMaxTtl(); /** * Set maximum supported time-to-live * * @param stdClass $marker * @param int $maxTtl * @throws Exception\\InvalidArgumentException * @return Capabilities Fluent interface */ public function setMaxTtl(stdClass $marker, $maxTtl); /** * Is the time-to-live handled static (on write) * or dynamic (on read) * * @return bool */ public function getStaticTtl(); /** * Set if the time-to-live handled static (on write) or dynamic (on read) * * @param stdClass $marker * @param bool $flag * @return Capabilities Fluent interface */ public function setStaticTtl(stdClass $marker, $flag); /** * Get time-to-live precision * * @return float */ public function getTtlPrecision(); /** * Set time-to-live precision * * @param stdClass $marker * @param float $ttlPrecision * @throws Exception\\InvalidArgumentException * @return Capabilities Fluent interface */ public function setTtlPrecision(stdClass $marker, $ttlPrecision); /** * Get use request time * * @return bool */ public function getUseRequestTime(); /** * Set use request time * * @param stdClass $marker * @param bool $flag * @return Capabilities Fluent interface */ public function setUseRequestTime(stdClass $marker, $flag); /** * Get \"lock-on-expire\" support in seconds. * * @return int 0 = Expired items will never be retrieved * &gt;0 = Time in seconds an expired item could be retrieved * -1 = Expired items could be retrieved forever */ public function getLockOnExpire() { return $this-&gt;getCapability('lockOnExpire', 0); } /** * Set \"lock-on-expire\" support in seconds. * * @param stdClass $marker * @param int $timeout * @return Capabilities Fluent interface */ public function setLockOnExpire(stdClass $marker, $timeout) { return $this-&gt;setCapability($marker, 'lockOnExpire', (int) $timeout); } /** * Get maximum key length * * @return int -1 means unknown, 0 means infinite */ public function getMaxKeyLength(); /** * Set maximum key length * * @param stdClass $marker * @param int $maxKeyLength * @throws Exception\\InvalidArgumentException * @return Capabilities Fluent interface */ public function setMaxKeyLength(stdClass $marker, $maxKeyLength); /** * Get if namespace support is implemented as prefix * * @return bool */ public function getNamespaceIsPrefix(); /** * Set if namespace support is implemented as prefix * * @param stdClass $marker * @param bool $flag * @return Capabilities Fluent interface */ public function setNamespaceIsPrefix(stdClass $marker, $flag); /** * Get namespace separator if namespace is implemented as prefix * * @return string */ public function getNamespaceSeparator(); /** * Set the namespace separator if namespace is implemented as prefix * * @param stdClass $marker * @param string $separator * @return Capabilities Fluent interface */ public function setNamespaceSeparator(stdClass $marker, $separator); } Examples Get Storage Capabilities and do specific Stuff based on them use Laminas\\Cache\\Service\\StorageAdapterFactoryInterface; use Psr\\Container\\ContainerInterface; /** @var ContainerInterface $container */ $container = null; // can be any configured PSR-11 container /** @var StorageAdapterFactoryInterface $storageFactory */ $storageFactory = $container-&gt;get(StorageAdapterFactoryInterface::class); $cache = $storageFactory-&gt;create('filesystem'); $supportedDatatypes = $cache-&gt;getCapabilities()-&gt;getSupportedDatatypes(); // now you can run specific stuff in base of supported feature if ($supportedDatatypes['object']) { $cache-&gt;set($key, $object); } else { $cache-&gt;set($key, serialize($object)); } Listen to the change Event use Laminas\\Cache\\Service\\StorageAdapterFactoryInterface; use Psr\\Container\\ContainerInterface; /** @var ContainerInterface $container */ $container = null; // can be any configured PSR-11 container /** @var StorageAdapterFactoryInterface $storageFactory */ $storageFactory = $container-&gt;get(StorageAdapterFactoryInterface::class); $cache = $storageFactory-&gt;create('filesystem', [ 'no_atime' =&gt; false, ]); // Catching capability changes $cache-&gt;getEventManager()-&gt;attach('capability', function($event) { echo count($event-&gt;getParams()) . ' capabilities changed'; }); // change option which changes capabilities $cache-&gt;getOptions()-&gt;setNoATime(true);","title":"Capabilities"},{"location":"v3/storage/capabilities/#storage-capabilities","text":"Storage capabilities describe how a storage adapter works, and which features it supports. To get capabilities of a storage adapter, you can use the method getCapabilities() , but only the storage adapter and its plugins have permissions to change them. Because capabilities are mutable, you can subscribe to the \"change\" event to get notifications; see the examples for details. If you are writing your own plugin or adapter, you can also change capabilities because you have access to the marker object and can create your own marker to instantiate a new instance of Laminas\\Cache\\Storage\\Capabilities .","title":"Storage Capabilities"},{"location":"v3/storage/capabilities/#available-methods","text":"namespace Laminas\\Cache\\Storage; use ArrayObject; use stdClass; use Laminas\\Cache\\Exception; use Laminas\\EventManager\\EventsCapableInterface; class Capabilities { /** * Constructor * * @param StorageInterface $storage * @param stdClass $marker * @param array $capabilities * @param null|Capabilities $baseCapabilities */ public function __construct( StorageInterface $storage, stdClass $marker, array $capabilities = [], Capabilities $baseCapabilities = null ); /** * Get the storage adapter * * @return StorageInterface */ public function getAdapter(); /** * Get supported datatypes * * @return array */ public function getSupportedDatatypes(); /** * Set supported datatypes * * @param stdClass $marker * @param array $datatypes * @throws Exception\\InvalidArgumentException * @return Capabilities Fluent interface */ public function setSupportedDatatypes(stdClass $marker, array $datatypes); /** * Get supported metadata * * @return array */ public function getSupportedMetadata(); /** * Set supported metadata * * @param stdClass $marker * @param string[] $metadata * @throws Exception\\InvalidArgumentException * @return Capabilities Fluent interface */ public function setSupportedMetadata(stdClass $marker, array $metadata); /** * Get minimum supported time-to-live * * @return int 0 means items never expire */ public function getMinTtl(); /** * Set minimum supported time-to-live * * @param stdClass $marker * @param int $minTtl * @throws Exception\\InvalidArgumentException * @return Capabilities Fluent interface */ public function setMinTtl(stdClass $marker, $minTtl); /** * Get maximum supported time-to-live * * @return int 0 means infinite */ public function getMaxTtl(); /** * Set maximum supported time-to-live * * @param stdClass $marker * @param int $maxTtl * @throws Exception\\InvalidArgumentException * @return Capabilities Fluent interface */ public function setMaxTtl(stdClass $marker, $maxTtl); /** * Is the time-to-live handled static (on write) * or dynamic (on read) * * @return bool */ public function getStaticTtl(); /** * Set if the time-to-live handled static (on write) or dynamic (on read) * * @param stdClass $marker * @param bool $flag * @return Capabilities Fluent interface */ public function setStaticTtl(stdClass $marker, $flag); /** * Get time-to-live precision * * @return float */ public function getTtlPrecision(); /** * Set time-to-live precision * * @param stdClass $marker * @param float $ttlPrecision * @throws Exception\\InvalidArgumentException * @return Capabilities Fluent interface */ public function setTtlPrecision(stdClass $marker, $ttlPrecision); /** * Get use request time * * @return bool */ public function getUseRequestTime(); /** * Set use request time * * @param stdClass $marker * @param bool $flag * @return Capabilities Fluent interface */ public function setUseRequestTime(stdClass $marker, $flag); /** * Get \"lock-on-expire\" support in seconds. * * @return int 0 = Expired items will never be retrieved * &gt;0 = Time in seconds an expired item could be retrieved * -1 = Expired items could be retrieved forever */ public function getLockOnExpire() { return $this-&gt;getCapability('lockOnExpire', 0); } /** * Set \"lock-on-expire\" support in seconds. * * @param stdClass $marker * @param int $timeout * @return Capabilities Fluent interface */ public function setLockOnExpire(stdClass $marker, $timeout) { return $this-&gt;setCapability($marker, 'lockOnExpire', (int) $timeout); } /** * Get maximum key length * * @return int -1 means unknown, 0 means infinite */ public function getMaxKeyLength(); /** * Set maximum key length * * @param stdClass $marker * @param int $maxKeyLength * @throws Exception\\InvalidArgumentException * @return Capabilities Fluent interface */ public function setMaxKeyLength(stdClass $marker, $maxKeyLength); /** * Get if namespace support is implemented as prefix * * @return bool */ public function getNamespaceIsPrefix(); /** * Set if namespace support is implemented as prefix * * @param stdClass $marker * @param bool $flag * @return Capabilities Fluent interface */ public function setNamespaceIsPrefix(stdClass $marker, $flag); /** * Get namespace separator if namespace is implemented as prefix * * @return string */ public function getNamespaceSeparator(); /** * Set the namespace separator if namespace is implemented as prefix * * @param stdClass $marker * @param string $separator * @return Capabilities Fluent interface */ public function setNamespaceSeparator(stdClass $marker, $separator); }","title":"Available Methods"},{"location":"v3/storage/capabilities/#examples","text":"","title":"Examples"},{"location":"v3/storage/plugin/","text":"Plugins Cache storage plugins are objects that provide additional functionality to or influence behavior of a storage adapter. The plugins listen to events the adapter triggers, and can: change the arguments provided to the method triggering the event (via *.post events) skip and directly return a result (by calling stopPropagation ) change the result (by calling setResult on the provided Laminas\\Cache\\Storage\\PostEvent ) catch exceptions (by reacting to Laminas\\Cache\\Storage\\ExceptionEvent ) Quick Start Storage plugins can either be created from Laminas\\Cache\\Service\\StoragePluginFactoryInterface::create() , or by instantiating one of the Laminas\\Cache\\Storage\\Plugin\\* classes. To make life easier, Laminas\\Cache\\Service\\StoragePluginFactoryInterface::create() can create both the requested adapter and all specified plugins at once. use Laminas\\Cache\\Service\\StoragePluginFactoryInterface; use Psr\\Container\\ContainerInterface; use Laminas\\Cache\\Service\\StorageAdapterFactoryInterface; /** @var ContainerInterface $container */ $container = null; // can be any configured PSR-11 container $storageFactory = $container-&gt;get(StorageAdapterFactoryInterface::class); // All at once: $cache = $storageFactory-&gt;create( 'filesystem', [], [ ['name' =&gt; 'serializer'], ] ); // Alternately, via discrete factory methods: $cache = $storageFactory-&gt;create('filesystem'); $pluginFactory = $container-&gt;get(StoragePluginFactoryInterface::class); $plugin = $pluginFactory-&gt;create('serializer'); $cache-&gt;addPlugin($plugin); // Or manually: $cache = new Laminas\\Cache\\Storage\\Adapter\\Filesystem(); $plugin = new Laminas\\Cache\\Storage\\Plugin\\Serializer(); $cache-&gt;addPlugin($plugin); The ClearExpiredByFactor Plugin Laminas\\Cache\\Storage\\Plugin\\ClearExpiredByFactor calls the storage method clearExpired() randomly (by factor) after every call of setItem() , setItems() , addItem() , and addItems() . Plugin specific Options Name Data Type Default Value Description clearing_factor integer 0 The automatic clearing factor. Adapter must implement ClearExpiredInterface The storage adapter must implement Laminas\\Cache\\Storage\\ClearExpiredInterface to work with this plugin. The ExceptionHandler Plugin Laminas\\Cache\\Storage\\Plugin\\ExceptionHandler catches all exceptions thrown on reading from or writing to the cache, and sends the exception to a defined callback function. You may also configure the plugin to re-throw exceptions. Plugin specific Options Name Data Type Default Value Description exception_callback callable\\|null null Callback to invoke on exception; receives the exception as the sole argument. throw_exceptions boolean true Re-throw caught exceptions. The IgnoreUserAbort Plugin Laminas\\Cache\\Storage\\Plugin\\IgnoreUserAbort ignores user-invoked script termination when, allowing cache write operations to complete first. Plugin specific Options Name Data Type Default Value Description exit_on_abort boolean true Terminate script execution on user abort. The OptimizeByFactor Plugin Laminas\\Cache\\Storage\\Plugin\\OptimizeByFactor calls the storage method optimize() randomly (by factor) after removing items from the cache. Plugin specific Options Name Data Type Default Value Description optimizing_factor integer 0 The automatic optimization factor. Adapter must implement OptimizableInterface The storage adapter must implement Laminas\\Cache\\Storage\\OptimizableInterface to work with this plugin. The Serializer Plugin Laminas\\Cache\\Storage\\Plugin\\Serializer will serialize data when writing to cache, and deserialize when reading. This allows storing datatypes not supported by the underlying storage adapter. Plugin specific Options Name Data Type Default Value Description serializer null\\|string\\|Laminas\\Serializer\\Adapter\\AdapterInterface null The serializer to use; see below. serializer_options array [] Array of options to use when instantiating the specified serializer. The serializer value has two special cases: When null , the default serializer is used (JSON). When a string , the value will be pulled via Laminas\\Serializer\\AdapterPluginManager , with the provided serializer_options . Available Methods The following methods are available to all Laminas\\Cache\\Storage\\Plugin\\PluginInterface implementations: namespace Laminas\\Cache\\Storage\\Plugin; use Laminas\\EventManager\\EventManagerInterface; use Laminas\\EventManager\\ListenerAggregateInterface; interface PluginInterface extends ListenerAggregateInterface { /** * Set options * * @param PluginOptions $options * @return PluginInterface */ public function setOptions(PluginOptions $options); /** * Get options * * @return PluginOptions */ public function getOptions(); /** * Attach listeners; inherited from ListenerAggregateInterface. * * @param EventManagerInterface $events * @return void */ public function attach(EventManagerInterface $events); /** * Detach listeners; inherited from ListenerAggregateInterface. * * @param EventManagerInterface $events * @return void */ public function attach(EventManagerInterface $events); } Examples Basic Plugin Implementation use Laminas\\Cache\\Storage\\Event; use Laminas\\Cache\\Storage\\Plugin\\AbstractPlugin; use Laminas\\EventManager\\EventManagerInterface; class MyPlugin extends AbstractPlugin { protected $handles = []; /** * Attach to all events this plugin is interested in. */ public function attach(EventManagerInterface $events) { $this-&gt;handles[] = $events-&gt;attach('getItem.pre', array($this, 'onGetItemPre')); $this-&gt;handles[] = $events-&gt;attach('getItem.post', array($this, 'onGetItemPost')); } /** * Detach all handlers this plugin previously attached. */ public function detach(EventManagerInterface $events) { foreach ($this-&gt;handles as $handle) { $events-&gt;detach($handle); } $this-&gt;handles = []; } public function onGetItemPre(Event $event) { $params = $event-&gt;getParams(); echo sprintf(\"Method 'getItem' with key '%s' started\\n\", $params['key']); } public function onGetItemPost(Event $event) { $params = $event-&gt;getParams(); echo sprintf(\"Method 'getItem' with key '%s' finished\\n\", $params['key']); } } // After defining this plugin, we can instantiate and add it to an adapter // instance: $plugin = new MyPlugin(); $cache-&gt;addPlugin($plugin); // Now when calling getItem(), our plugin should print the expected output: $cache-&gt;getItem('cache-key'); // Method 'getItem' with key 'cache-key' started // Method 'getItem' with key 'cache-key' finished","title":"Plugins"},{"location":"v3/storage/plugin/#plugins","text":"Cache storage plugins are objects that provide additional functionality to or influence behavior of a storage adapter. The plugins listen to events the adapter triggers, and can: change the arguments provided to the method triggering the event (via *.post events) skip and directly return a result (by calling stopPropagation ) change the result (by calling setResult on the provided Laminas\\Cache\\Storage\\PostEvent ) catch exceptions (by reacting to Laminas\\Cache\\Storage\\ExceptionEvent )","title":"Plugins"},{"location":"v3/storage/plugin/#quick-start","text":"Storage plugins can either be created from Laminas\\Cache\\Service\\StoragePluginFactoryInterface::create() , or by instantiating one of the Laminas\\Cache\\Storage\\Plugin\\* classes. To make life easier, Laminas\\Cache\\Service\\StoragePluginFactoryInterface::create() can create both the requested adapter and all specified plugins at once. use Laminas\\Cache\\Service\\StoragePluginFactoryInterface; use Psr\\Container\\ContainerInterface; use Laminas\\Cache\\Service\\StorageAdapterFactoryInterface; /** @var ContainerInterface $container */ $container = null; // can be any configured PSR-11 container $storageFactory = $container-&gt;get(StorageAdapterFactoryInterface::class); // All at once: $cache = $storageFactory-&gt;create( 'filesystem', [], [ ['name' =&gt; 'serializer'], ] ); // Alternately, via discrete factory methods: $cache = $storageFactory-&gt;create('filesystem'); $pluginFactory = $container-&gt;get(StoragePluginFactoryInterface::class); $plugin = $pluginFactory-&gt;create('serializer'); $cache-&gt;addPlugin($plugin); // Or manually: $cache = new Laminas\\Cache\\Storage\\Adapter\\Filesystem(); $plugin = new Laminas\\Cache\\Storage\\Plugin\\Serializer(); $cache-&gt;addPlugin($plugin);","title":"Quick Start"},{"location":"v3/storage/plugin/#the-clearexpiredbyfactor-plugin","text":"Laminas\\Cache\\Storage\\Plugin\\ClearExpiredByFactor calls the storage method clearExpired() randomly (by factor) after every call of setItem() , setItems() , addItem() , and addItems() .","title":"The ClearExpiredByFactor Plugin"},{"location":"v3/storage/plugin/#the-exceptionhandler-plugin","text":"Laminas\\Cache\\Storage\\Plugin\\ExceptionHandler catches all exceptions thrown on reading from or writing to the cache, and sends the exception to a defined callback function. You may also configure the plugin to re-throw exceptions.","title":"The ExceptionHandler Plugin"},{"location":"v3/storage/plugin/#the-ignoreuserabort-plugin","text":"Laminas\\Cache\\Storage\\Plugin\\IgnoreUserAbort ignores user-invoked script termination when, allowing cache write operations to complete first.","title":"The IgnoreUserAbort Plugin"},{"location":"v3/storage/plugin/#the-optimizebyfactor-plugin","text":"Laminas\\Cache\\Storage\\Plugin\\OptimizeByFactor calls the storage method optimize() randomly (by factor) after removing items from the cache.","title":"The OptimizeByFactor Plugin"},{"location":"v3/storage/plugin/#the-serializer-plugin","text":"Laminas\\Cache\\Storage\\Plugin\\Serializer will serialize data when writing to cache, and deserialize when reading. This allows storing datatypes not supported by the underlying storage adapter.","title":"The Serializer Plugin"},{"location":"v3/storage/plugin/#available-methods","text":"The following methods are available to all Laminas\\Cache\\Storage\\Plugin\\PluginInterface implementations: namespace Laminas\\Cache\\Storage\\Plugin; use Laminas\\EventManager\\EventManagerInterface; use Laminas\\EventManager\\ListenerAggregateInterface; interface PluginInterface extends ListenerAggregateInterface { /** * Set options * * @param PluginOptions $options * @return PluginInterface */ public function setOptions(PluginOptions $options); /** * Get options * * @return PluginOptions */ public function getOptions(); /** * Attach listeners; inherited from ListenerAggregateInterface. * * @param EventManagerInterface $events * @return void */ public function attach(EventManagerInterface $events); /** * Detach listeners; inherited from ListenerAggregateInterface. * * @param EventManagerInterface $events * @return void */ public function attach(EventManagerInterface $events); }","title":"Available Methods"},{"location":"v3/storage/plugin/#examples","text":"","title":"Examples"},{"location":"v4/installation/","text":"This Is Only a Placeholder The content of this page can be found under: https://github.com/laminas/documentation-theme/blob/master/theme/pages/installation.html","title":"Installation"},{"location":"v4/installation/#this-is-only-a-placeholder","text":"The content of this page can be found under: https://github.com/laminas/documentation-theme/blob/master/theme/pages/installation.html","title":"This Is Only a Placeholder"},{"location":"v4/psr16/","text":"PSR-16 PSR-16 provides a simplified approach to cache access that does not involve cache pools, tags, deferment, etc.; it can be thought of as a key/value storage approach to caching. laminas-cache provides PSR-16 support via the class Laminas\\Cache\\Psr\\SimpleCache\\SimpleCacheDecorator . This class implements PSR-16's Psr\\SimpleCache\\CacheInterface , and composes a Laminas\\Cache\\Storage\\StorageInterface instance to which it proxies all operations. Instantiation is as follows: use Laminas\\Cache\\Psr\\SimpleCache\\SimpleCacheDecorator; use Laminas\\Cache\\Service\\StorageAdapterFactoryInterface; use Psr\\Container\\ContainerInterface; /** @var ContainerInterface $container */ $container = null; // can be any configured PSR-11 container $storageFactory = $container-&gt;get(StorageAdapterFactoryInterface::class); $storage = $storageFactory-&gt;create('apc'); $cache = new SimpleCacheDecorator($storage); Once you have a SimpleCacheDecorator instance, you can perform operations per that specification: // Use has() to determine whether to fetch the value or calculate it: $value = $cache-&gt;has('someKey') ? $cache-&gt;get('someKey') : calculateValue(); if (! $cache-&gt;has('someKey')) { $cache-&gt;set('someKey', $value); } // Or use a default value: $value = $cache-&gt;get('someKey', $defaultValue); When setting values, whether single values or multiple, you can also optionally provide a Time To Live (TTL) value. This proxies to the underlying storage instance's options, temporarily resetting its TTL value for the duration of the operation. TTL values may be expressed as integers (in which case they represent seconds) or DateInterval instances. As examples: $cache-&gt;set('someKey', $value, 30); // set TTL to 30s $cache-&gt;set('someKey', $value, new DateInterval('P1D')); // set TTL to 1 day $cache-&gt;setMultiple([ 'key1' =&gt; $value1, 'key2' =&gt; $value2, ], 3600); // set TTL to 1 hour $cache-&gt;setMultiple([ 'key1' =&gt; $value1, 'key2' =&gt; $value2, ], new DateInterval('P6H')); // set TTL to 6 hours For more details on what methods are exposed, consult the CacheInterface specification . Serialization PSR-16 has strict requirements around serialization of values. This is done to ensure that if you swap one PSR-16 adapter for another, the new one will be able to return the same values that the original adapter saved to the cache. Not all cache backends support the same data types, however. laminas-cache provides a plugin, Laminas\\Cache\\Storage\\Plugin\\Serializer , that you can attach to adapters in order to ensure data is serialized to a string when saving to the cache, and deserialized to native PHP types on retrieval. The following adapters require this plugin in order to work with the SimpleCacheDecorator : Dba Filesystem Memcache MongoDB Redis XCache We provide a number of examples of attaching plugins to storage adapters in the plugins chapter . Generally, it will be one of: use Laminas\\Cache\\Service\\StorageAdapterFactoryInterface; use Laminas\\Cache\\Storage\\Plugin\\Serializer; use Psr\\Container\\ContainerInterface; // Manual attachment after you have an instance: $cache-&gt;addPlugin(new Serializer()); // Via configuration: /** @var ContainerInterface $container */ $container = null; // can be any configured PSR-11 container $storageFactory = $container-&gt;get(StorageAdapterFactoryInterface::class); $cache = $storageFactory-&gt;create( 'filesystem', [], [ ['name' =&gt; 'serializer'], ] ); Deleting Items and Exceptions PSR-16 states that the delete() and deleteMultiple() methods should return false if an error occured when deleting the key(s) provided, but true otherwise. Generally, laminas-cache storage adapters comply with this. However, it is possible to configure your adapter such that you may get a false positive result from these methods. When an exception is raised and caught during key removal by an adapter, the adapter triggers an event with a Laminas\\Cache\\Storage\\ExceptionEvent . Plugins can react to these, and even manipulate the event instance. One such plugin, Laminas\\Cache\\Storage\\Plugin\\ExceptionHandler , has a configuration option, throw_exceptions that, when boolean false , will prevent raising the exception. In such cases, adapters will typically return a boolean false anyways, but custom, third-party adapters may not. Additionally, if you add a custom plugin that listens to removal event exceptions and modifies the return value and/or disables throwing the exception, a false positive return value could occur. As such, we recommend that if you wish to use laminas-cache to provide a PSR-16 adapter, you audit the plugins you use with your adapter to ensure that you will get consistent, correct behavior for delete() and deleteMultiple() operations.","title":"PSR-16"},{"location":"v4/psr16/#psr-16","text":"PSR-16 provides a simplified approach to cache access that does not involve cache pools, tags, deferment, etc.; it can be thought of as a key/value storage approach to caching. laminas-cache provides PSR-16 support via the class Laminas\\Cache\\Psr\\SimpleCache\\SimpleCacheDecorator . This class implements PSR-16's Psr\\SimpleCache\\CacheInterface , and composes a Laminas\\Cache\\Storage\\StorageInterface instance to which it proxies all operations. Instantiation is as follows: use Laminas\\Cache\\Psr\\SimpleCache\\SimpleCacheDecorator; use Laminas\\Cache\\Service\\StorageAdapterFactoryInterface; use Psr\\Container\\ContainerInterface; /** @var ContainerInterface $container */ $container = null; // can be any configured PSR-11 container $storageFactory = $container-&gt;get(StorageAdapterFactoryInterface::class); $storage = $storageFactory-&gt;create('apc'); $cache = new SimpleCacheDecorator($storage); Once you have a SimpleCacheDecorator instance, you can perform operations per that specification: // Use has() to determine whether to fetch the value or calculate it: $value = $cache-&gt;has('someKey') ? $cache-&gt;get('someKey') : calculateValue(); if (! $cache-&gt;has('someKey')) { $cache-&gt;set('someKey', $value); } // Or use a default value: $value = $cache-&gt;get('someKey', $defaultValue); When setting values, whether single values or multiple, you can also optionally provide a Time To Live (TTL) value. This proxies to the underlying storage instance's options, temporarily resetting its TTL value for the duration of the operation. TTL values may be expressed as integers (in which case they represent seconds) or DateInterval instances. As examples: $cache-&gt;set('someKey', $value, 30); // set TTL to 30s $cache-&gt;set('someKey', $value, new DateInterval('P1D')); // set TTL to 1 day $cache-&gt;setMultiple([ 'key1' =&gt; $value1, 'key2' =&gt; $value2, ], 3600); // set TTL to 1 hour $cache-&gt;setMultiple([ 'key1' =&gt; $value1, 'key2' =&gt; $value2, ], new DateInterval('P6H')); // set TTL to 6 hours For more details on what methods are exposed, consult the CacheInterface specification .","title":"PSR-16"},{"location":"v4/psr16/#serialization","text":"PSR-16 has strict requirements around serialization of values. This is done to ensure that if you swap one PSR-16 adapter for another, the new one will be able to return the same values that the original adapter saved to the cache. Not all cache backends support the same data types, however. laminas-cache provides a plugin, Laminas\\Cache\\Storage\\Plugin\\Serializer , that you can attach to adapters in order to ensure data is serialized to a string when saving to the cache, and deserialized to native PHP types on retrieval. The following adapters require this plugin in order to work with the SimpleCacheDecorator : Dba Filesystem Memcache MongoDB Redis XCache We provide a number of examples of attaching plugins to storage adapters in the plugins chapter . Generally, it will be one of: use Laminas\\Cache\\Service\\StorageAdapterFactoryInterface; use Laminas\\Cache\\Storage\\Plugin\\Serializer; use Psr\\Container\\ContainerInterface; // Manual attachment after you have an instance: $cache-&gt;addPlugin(new Serializer()); // Via configuration: /** @var ContainerInterface $container */ $container = null; // can be any configured PSR-11 container $storageFactory = $container-&gt;get(StorageAdapterFactoryInterface::class); $cache = $storageFactory-&gt;create( 'filesystem', [], [ ['name' =&gt; 'serializer'], ] );","title":"Serialization"},{"location":"v4/psr16/#deleting-items-and-exceptions","text":"PSR-16 states that the delete() and deleteMultiple() methods should return false if an error occured when deleting the key(s) provided, but true otherwise. Generally, laminas-cache storage adapters comply with this. However, it is possible to configure your adapter such that you may get a false positive result from these methods. When an exception is raised and caught during key removal by an adapter, the adapter triggers an event with a Laminas\\Cache\\Storage\\ExceptionEvent . Plugins can react to these, and even manipulate the event instance. One such plugin, Laminas\\Cache\\Storage\\Plugin\\ExceptionHandler , has a configuration option, throw_exceptions that, when boolean false , will prevent raising the exception. In such cases, adapters will typically return a boolean false anyways, but custom, third-party adapters may not. Additionally, if you add a custom plugin that listens to removal event exceptions and modifies the return value and/or disables throwing the exception, a false positive return value could occur. As such, we recommend that if you wish to use laminas-cache to provide a PSR-16 adapter, you audit the plugins you use with your adapter to ensure that you will get consistent, correct behavior for delete() and deleteMultiple() operations.","title":"Deleting Items and Exceptions"},{"location":"v4/psr6/","text":"PSR-6 Overview The Laminas\\Cache\\Psr\\CacheItemPool\\CacheItemPoolDecorator provides a PSR-6 compliant wrapper for supported storage adapters. PSR-6 specifies a common interface to cache storage, enabling developers to switch between implementations without having to worry about any behind-the-scenes differences between them. Quick Start To use the pool, instantiate your storage as normal, then pass it to the CacheItemPoolDecorator . use Laminas\\Cache\\Psr\\CacheItemPool\\CacheItemPoolDecorator;use Laminas\\Cache\\Service\\StorageAdapterFactoryInterface;use Psr\\Container\\ContainerInterface; /** @var ContainerInterface $container */ $container = null; // can be any configured PSR-11 container $storageFactory = $container-&gt;get(StorageAdapterFactoryInterface::class); $storage = $storageFactory-&gt;create('apc'); $pool = new CacheItemPoolDecorator($storage); // attempt to get an item from cache $item = $pool-&gt;getItem('foo'); // check whether item was found if (! $item-&gt;isHit()) { // ... // perform expensive operation to calculate $value for 'foo' // ... $item-&gt;set($value); $pool-&gt;save($item); } // use the value of the item echo $item-&gt;get(); Note that you will always get back a CacheItem object, whether it was found in cache or not: this is so false -y values like an empty string, null , or false can be stored. Always check isHit() to determine if the item was found. Supported Adapters The PSR-6 specification requires that the underlying storage support time-to-live (TTL), which is set when the item is saved. For this reason the following adapters cannot be used: Dba , Filesystem , Memory and Session . The XCache adapter calculates TTLs based on the request time, not the time the item is actually persisted, which means that it also cannot be used. In addition adapters must support the Laminas\\Cache\\FlushableInterface . All the current Laminas\\Cache\\Storage\\Adapter s fulfil this requirement. Attempting to use an unsupported adapter will throw an exception implementing Psr\\Cache\\CacheException . The Laminas\\Cache\\Psr\\CacheItemPool\\CacheItemPoolDecorator adapter doesn't support driver deferred saves, so cache items are saved on destruct or on explicit commit() call. Quirks APC You cannot set the apc.use_request_time ini setting with the APC adapter: the specification requires that all TTL values are calculated from when the item is actually saved to storage. If this is set when you instantiate the pool it will throw an exception implementing Psr\\Cache\\CacheException . Changing the setting after you have instantiated the pool will result in non-standard behaviour. Logging Errors The specification states : While caching is often an important part of application performance, it should never be a critical part of application functionality. Thus, an error in a cache system SHOULD NOT result in application failure. Once you've got your pool instance, almost all exceptions thrown by the storage will be caught and ignored. The only storage exceptions that bubble up implement Psr\\Cache\\InvalidArgumentException and are typically caused by invalid key errors. To be PSR-6 compliant, cache keys must not contain the following characters: {}()/\\@: . However different storage adapters may have further restrictions. Check the documentation for your particular adapter to be sure. We strongly recommend tracking exceptions caught from storage, either by logging them or recording them in some other way. Doing so is as simple as adding an ExceptionHandler plugin . Say you have a PSR-3 compliant logger called $logger : use Laminas\\Cache\\Psr\\CacheItemPool\\CacheItemPoolDecorator; use Laminas\\Cache\\Service\\StorageAdapterFactoryInterface; use Psr\\Container\\ContainerInterface; $cacheLogger = function (\\Exception $e) use ($logger) { $message = sprintf( '[CACHE] %s:%s %s \"%s\"', $exception-&gt;getFile(), $exception-&gt;getLine(), $exception-&gt;getCode(), $exception-&gt;getMessage() ); $logger-&gt;error($message); }; /** @var ContainerInterface $container */ $container = null; // can be any configured PSR-11 container $storageFactory = $container-&gt;get(StorageAdapterFactoryInterface::class); $storage = $storageFactory-&gt;create( 'apc', [], [ [ 'name' =&gt; 'exceptionhandler', 'options' =&gt; [ 'exception_callback' =&gt; $cacheLogger, 'throw_exceptions' =&gt; true, ], ], ] ); $pool = new CacheItemPoolDecorator($storage); Note that throw_exceptions should always be true (the default) or you will not get the correct return values from calls on the pool such as save() . Supported Data Types As per the specification , the following data types can be stored in cache: string , integer , float , boolean , null , array , object and be returned as a value with exactly the same type. Not all adapters can natively store all these types. For instance, Redis stores booleans and integers as a string. Where this is the case all values will be automatically run through serialize() on save and unserialize() on get: you do not need to use a Laminas\\Cache\\Storage\\Plugin\\Serializer plugin. Time-Related Operations By default, the PSR-6 cache decorator uses the systems time to determine cache expirations. This can be changed by passing a stella-maris/clock Clock implementation to the CacheItemPoolDecorator#__construct . By doing so, the method CacheItemInterface#expiresAfter uses that Clock to calculate the cache items TTL when passing a DateInterval instance. use Lcobucci\\Clock\\SystemClock; $clock = new SystemClock('Antarctica/Troll'); $pool = new CacheItemPoolDecorator($storage, $clock); $item = $pool-&gt;getItem('non-existent-key'); $item -&gt;set('foo') -&gt;expiresAfter(DateInterval::createFromDateString('24 hours')); // Saves the item which expires in 24h $pool-&gt;save($item);","title":"PSR-6"},{"location":"v4/psr6/#psr-6","text":"","title":"PSR-6"},{"location":"v4/psr6/#overview","text":"The Laminas\\Cache\\Psr\\CacheItemPool\\CacheItemPoolDecorator provides a PSR-6 compliant wrapper for supported storage adapters. PSR-6 specifies a common interface to cache storage, enabling developers to switch between implementations without having to worry about any behind-the-scenes differences between them.","title":"Overview"},{"location":"v4/psr6/#quick-start","text":"To use the pool, instantiate your storage as normal, then pass it to the CacheItemPoolDecorator . use Laminas\\Cache\\Psr\\CacheItemPool\\CacheItemPoolDecorator;use Laminas\\Cache\\Service\\StorageAdapterFactoryInterface;use Psr\\Container\\ContainerInterface; /** @var ContainerInterface $container */ $container = null; // can be any configured PSR-11 container $storageFactory = $container-&gt;get(StorageAdapterFactoryInterface::class); $storage = $storageFactory-&gt;create('apc'); $pool = new CacheItemPoolDecorator($storage); // attempt to get an item from cache $item = $pool-&gt;getItem('foo'); // check whether item was found if (! $item-&gt;isHit()) { // ... // perform expensive operation to calculate $value for 'foo' // ... $item-&gt;set($value); $pool-&gt;save($item); } // use the value of the item echo $item-&gt;get(); Note that you will always get back a CacheItem object, whether it was found in cache or not: this is so false -y values like an empty string, null , or false can be stored. Always check isHit() to determine if the item was found.","title":"Quick Start"},{"location":"v4/psr6/#supported-adapters","text":"The PSR-6 specification requires that the underlying storage support time-to-live (TTL), which is set when the item is saved. For this reason the following adapters cannot be used: Dba , Filesystem , Memory and Session . The XCache adapter calculates TTLs based on the request time, not the time the item is actually persisted, which means that it also cannot be used. In addition adapters must support the Laminas\\Cache\\FlushableInterface . All the current Laminas\\Cache\\Storage\\Adapter s fulfil this requirement. Attempting to use an unsupported adapter will throw an exception implementing Psr\\Cache\\CacheException . The Laminas\\Cache\\Psr\\CacheItemPool\\CacheItemPoolDecorator adapter doesn't support driver deferred saves, so cache items are saved on destruct or on explicit commit() call.","title":"Supported Adapters"},{"location":"v4/psr6/#logging-errors","text":"The specification states : While caching is often an important part of application performance, it should never be a critical part of application functionality. Thus, an error in a cache system SHOULD NOT result in application failure. Once you've got your pool instance, almost all exceptions thrown by the storage will be caught and ignored. The only storage exceptions that bubble up implement Psr\\Cache\\InvalidArgumentException and are typically caused by invalid key errors. To be PSR-6 compliant, cache keys must not contain the following characters: {}()/\\@: . However different storage adapters may have further restrictions. Check the documentation for your particular adapter to be sure. We strongly recommend tracking exceptions caught from storage, either by logging them or recording them in some other way. Doing so is as simple as adding an ExceptionHandler plugin . Say you have a PSR-3 compliant logger called $logger : use Laminas\\Cache\\Psr\\CacheItemPool\\CacheItemPoolDecorator; use Laminas\\Cache\\Service\\StorageAdapterFactoryInterface; use Psr\\Container\\ContainerInterface; $cacheLogger = function (\\Exception $e) use ($logger) { $message = sprintf( '[CACHE] %s:%s %s \"%s\"', $exception-&gt;getFile(), $exception-&gt;getLine(), $exception-&gt;getCode(), $exception-&gt;getMessage() ); $logger-&gt;error($message); }; /** @var ContainerInterface $container */ $container = null; // can be any configured PSR-11 container $storageFactory = $container-&gt;get(StorageAdapterFactoryInterface::class); $storage = $storageFactory-&gt;create( 'apc', [], [ [ 'name' =&gt; 'exceptionhandler', 'options' =&gt; [ 'exception_callback' =&gt; $cacheLogger, 'throw_exceptions' =&gt; true, ], ], ] ); $pool = new CacheItemPoolDecorator($storage); Note that throw_exceptions should always be true (the default) or you will not get the correct return values from calls on the pool such as save() .","title":"Logging Errors"},{"location":"v4/psr6/#supported-data-types","text":"As per the specification , the following data types can be stored in cache: string , integer , float , boolean , null , array , object and be returned as a value with exactly the same type. Not all adapters can natively store all these types. For instance, Redis stores booleans and integers as a string. Where this is the case all values will be automatically run through serialize() on save and unserialize() on get: you do not need to use a Laminas\\Cache\\Storage\\Plugin\\Serializer plugin.","title":"Supported Data Types"},{"location":"v4/psr6/#time-related-operations","text":"By default, the PSR-6 cache decorator uses the systems time to determine cache expirations. This can be changed by passing a stella-maris/clock Clock implementation to the CacheItemPoolDecorator#__construct . By doing so, the method CacheItemInterface#expiresAfter uses that Clock to calculate the cache items TTL when passing a DateInterval instance. use Lcobucci\\Clock\\SystemClock; $clock = new SystemClock('Antarctica/Troll'); $pool = new CacheItemPoolDecorator($storage, $clock); $item = $pool-&gt;getItem('non-existent-key'); $item -&gt;set('foo') -&gt;expiresAfter(DateInterval::createFromDateString('24 hours')); // Saves the item which expires in 24h $pool-&gt;save($item);","title":"Time-Related Operations"},{"location":"v4/application-integration/usage-in-a-laminas-mvc-application/","text":"Usage in a laminas-mvc Application The following example shows one potential use case of laminas-cache within a laminas-mvc based application. The example uses a module, a controller and shows the resolving of dependencies of the controller by configuration. Preparation Before starting, make sure laminas-cache is installed and configured . Installation Requirements laminas-cache is shipped without a specific cache adapter to allow free choice of storage backends and their dependencies. So make sure that the required adapters are installed. The following example used the filesystem adapter of laminas-cache : $ composer require laminas/laminas-cache-storage-adapter-filesystem Configure Cache To configure the cache in a laminas-mvc based application, use either application or module configuration (such as config/autoload/*.global.php or module/Application/config/module.config.php , respectively), and define the configuration key caches . In this example, the global configuration is used and a separate file is created for the cache configuration. Create a configuration file with name like config/autoload/cache.global.php and it will automatically be included : return [ 'caches' =&gt; [ 'default-cache' =&gt; [ 'adapter' =&gt; Laminas\\Cache\\Storage\\Adapter\\Filesystem::class, 'options' =&gt; [ 'cache_dir' =&gt; __DIR__ . '/../../data/cache', ], ], ], ]; The factory Laminas\\Cache\\Service\\StorageCacheAbstractServiceFactory uses the configuration, searches for the configuration key caches and creates the storage adapters using the discovered configuration. Create Controller Create a controller class and inject the cache with the interface for all cache storage adapters via the constructor, e.g. module/Application/Controller/IndexController.php : namespace Application\\Controller; use Laminas\\Cache\\Storage\\StorageInterface; use Laminas\\Mvc\\Controller\\AbstractActionController; final class IndexController extends AbstractActionController { public function __construct( private readonly StorageInterface $cache ) {} public function indexAction(): array { if (! $this-&gt;cache-&gt;hasItem('example')) { $this-&gt;cache-&gt;addItem('example', 'value'); } echo $this-&gt;cache-&gt;getItem('example') // value; // … return []; } } Register Controller To register the controller for the application, extend the configuration of the module. Add the following lines to the module configuration file, e.g. module/Application/config/module.config.php : namespace Application; use Laminas\\ServiceManager\\AbstractFactory\\ConfigAbstractFactory; return [ 'controllers' =&gt; [ 'factories' =&gt; [ Controller\\IndexController::class =&gt; ConfigAbstractFactory::class, ], ], // … ]; The example uses the config factory from laminas-servicemanager which allows any string to be used to fetch a service from the application service container, like the name of the configured cache: default-cache . This means that the factory searches for an appropriate configuration to create the controller and to resolve the constructor dependencies for the controller class. Add Factory Configuration For Controller Extend the module configuration file to add the configuration for the controller. Use the name of the cache ( default-cache ), which was previously defined in the configuration of the caches, to retrieve the related cache storage instance: namespace Application; use Laminas\\ServiceManager\\AbstractFactory\\ConfigAbstractFactory; return [ 'controllers' =&gt; [ 'factories' =&gt; [ Controller\\IndexController::class =&gt; ConfigAbstractFactory::class, ], ], ConfigAbstractFactory::class =&gt; [ Controller\\IndexController::class =&gt; [ 'default-cache', ], ], // … ]; Using Multiple Caches The use more than one cache backend, the factory Laminas\\Cache\\Service\\StorageCacheAbstractServiceFactory allows to define multiple cache storages. Extend the cache configuration in config/autoload/cache.global.php and add more cache adapters: return [ 'caches' =&gt; [ 'default-cache' =&gt; [ 'adapter' =&gt; Laminas\\Cache\\Storage\\Adapter\\Filesystem::class, 'options' =&gt; [ 'cache_dir' =&gt; __DIR__ . '/../../data/cache', ], ], 'secondary-cache' =&gt; [ 'adapter' =&gt; Laminas\\Cache\\Storage\\Adapter\\Memory::class, ], 'dummy-cache' =&gt; [ 'adapter' =&gt; Laminas\\Cache\\Storage\\Adapter\\BlackHole::class, ], ], ]; Installation Requirements Make sure that the used storage adapters are installed : $ composer require laminas/laminas-cache-storage-adapter-memory laminas/laminas-cache-storage-adapter-blackhole Change Used Adapter for Controller To use a different cache adapter for the controller, change the related module configuration and use one of the previously defined names: namespace Application; use Laminas\\ServiceManager\\AbstractFactory\\ConfigAbstractFactory; return [ 'controllers' =&gt; [ 'factories' =&gt; [ Controller\\IndexController::class =&gt; ConfigAbstractFactory::class, ], ], ConfigAbstractFactory::class =&gt; [ Controller\\IndexController::class =&gt; [ 'dummy-cache', ], ], // … ]; Learn More Storage Adapters Environment-Specific Application Configuration Configuration-based Abstract Factory","title":"Usage in a laminas-mvc Application"},{"location":"v4/application-integration/usage-in-a-laminas-mvc-application/#usage-in-a-laminas-mvc-application","text":"The following example shows one potential use case of laminas-cache within a laminas-mvc based application. The example uses a module, a controller and shows the resolving of dependencies of the controller by configuration.","title":"Usage in a laminas-mvc Application"},{"location":"v4/application-integration/usage-in-a-laminas-mvc-application/#preparation","text":"Before starting, make sure laminas-cache is installed and configured . Installation Requirements laminas-cache is shipped without a specific cache adapter to allow free choice of storage backends and their dependencies. So make sure that the required adapters are installed. The following example used the filesystem adapter of laminas-cache : $ composer require laminas/laminas-cache-storage-adapter-filesystem","title":"Preparation"},{"location":"v4/application-integration/usage-in-a-laminas-mvc-application/#configure-cache","text":"To configure the cache in a laminas-mvc based application, use either application or module configuration (such as config/autoload/*.global.php or module/Application/config/module.config.php , respectively), and define the configuration key caches . In this example, the global configuration is used and a separate file is created for the cache configuration. Create a configuration file with name like config/autoload/cache.global.php and it will automatically be included : return [ 'caches' =&gt; [ 'default-cache' =&gt; [ 'adapter' =&gt; Laminas\\Cache\\Storage\\Adapter\\Filesystem::class, 'options' =&gt; [ 'cache_dir' =&gt; __DIR__ . '/../../data/cache', ], ], ], ]; The factory Laminas\\Cache\\Service\\StorageCacheAbstractServiceFactory uses the configuration, searches for the configuration key caches and creates the storage adapters using the discovered configuration.","title":"Configure Cache"},{"location":"v4/application-integration/usage-in-a-laminas-mvc-application/#create-controller","text":"Create a controller class and inject the cache with the interface for all cache storage adapters via the constructor, e.g. module/Application/Controller/IndexController.php : namespace Application\\Controller; use Laminas\\Cache\\Storage\\StorageInterface; use Laminas\\Mvc\\Controller\\AbstractActionController; final class IndexController extends AbstractActionController { public function __construct( private readonly StorageInterface $cache ) {} public function indexAction(): array { if (! $this-&gt;cache-&gt;hasItem('example')) { $this-&gt;cache-&gt;addItem('example', 'value'); } echo $this-&gt;cache-&gt;getItem('example') // value; // … return []; } }","title":"Create Controller"},{"location":"v4/application-integration/usage-in-a-laminas-mvc-application/#register-controller","text":"To register the controller for the application, extend the configuration of the module. Add the following lines to the module configuration file, e.g. module/Application/config/module.config.php : namespace Application; use Laminas\\ServiceManager\\AbstractFactory\\ConfigAbstractFactory; return [ 'controllers' =&gt; [ 'factories' =&gt; [ Controller\\IndexController::class =&gt; ConfigAbstractFactory::class, ], ], // … ]; The example uses the config factory from laminas-servicemanager which allows any string to be used to fetch a service from the application service container, like the name of the configured cache: default-cache . This means that the factory searches for an appropriate configuration to create the controller and to resolve the constructor dependencies for the controller class.","title":"Register Controller"},{"location":"v4/application-integration/usage-in-a-laminas-mvc-application/#using-multiple-caches","text":"The use more than one cache backend, the factory Laminas\\Cache\\Service\\StorageCacheAbstractServiceFactory allows to define multiple cache storages. Extend the cache configuration in config/autoload/cache.global.php and add more cache adapters: return [ 'caches' =&gt; [ 'default-cache' =&gt; [ 'adapter' =&gt; Laminas\\Cache\\Storage\\Adapter\\Filesystem::class, 'options' =&gt; [ 'cache_dir' =&gt; __DIR__ . '/../../data/cache', ], ], 'secondary-cache' =&gt; [ 'adapter' =&gt; Laminas\\Cache\\Storage\\Adapter\\Memory::class, ], 'dummy-cache' =&gt; [ 'adapter' =&gt; Laminas\\Cache\\Storage\\Adapter\\BlackHole::class, ], ], ]; Installation Requirements Make sure that the used storage adapters are installed : $ composer require laminas/laminas-cache-storage-adapter-memory laminas/laminas-cache-storage-adapter-blackhole","title":"Using Multiple Caches"},{"location":"v4/application-integration/usage-in-a-laminas-mvc-application/#learn-more","text":"Storage Adapters Environment-Specific Application Configuration Configuration-based Abstract Factory","title":"Learn More"},{"location":"v4/migration/to-version-4/","text":"Migration to Version 4.0 Finally, native types everywhere . With v4.0, laminas-cache depends on laminas-servicemanager v4 which already introduced full native types and thus, cache now has native types as well. Along with these changes, we also decided to remove and/or enhance some features to make the usage of this component more user-friendly. So instead of working with metadata arrays, a new MetadataCapableInterface was introduced which provides a generic interface for storage adapters to tell both IDEs and static analysers to understand what metadata instances are returned for which storage adapter. This allows per-storage Metadata which can differ depending on the storage being used. Checklist Ensure you are on latest laminas/laminas-cache v3 Ensure you are on latest laminas/laminas-cache-storage-adapter-* version (might differ) Verify that you are not using one of the following methods StorageInterface#incrementItem (no replacement available, should be implemented in userland code) StorageInterface#incrementItems (no replacement available, should be implemented in userland code) StorageInterface#decrementItem (no replacement available, should be implemented in userland code) StorageInterface#decrementItems (no replacement available, should be implemented in userland code) Verify that you are not using supportedMetadata capability (use MetadataCapableInterface#getMetadata instead) Verify that you are not using KeyListIterator with mode CURRENT_AS_METADATA (use the returned key instead and pass it to the MetadataCapable storage adapter ( NOTE: not all adapters do implement MetadataCapableInterface ) If you use the Serializer plugin Verify that if you pass a string as serializer option, you do not directly depend on the return value of PluginOptions#getSerializer (method will return string instead of instantiating a new SerializerInterface instance). The plugin itself can still handle string and an instance of SerializerInterface as in previous versions If you provide own plugins, storage adapters, pattern, you have to upgrade to v4 and update all method/argument/property (return-) types according to the updated versions. Check out rector which can help with this kind of migration If you are handling Laminas\\Cache\\Exception\\MissingKeyException , you can remove that code as the exception does not exist anymore Check if you use ObjectCache pattern, that your code does not expect an instance of CallbackCache to be passed New Features Every adapter which supports metadata now implements MetadataCapableInterface and provides a dedicated object containing all the metadata values it supports Adds support for psr/cache and psr/simple-cache v2 &amp; v3 Removed Classes Laminas\\Cache\\Exception\\MissingKeyException Breaking Changes AbstractAdapter and StorageInterface are not aware of the methods getMetadata anymore. These were moved to the new MetadataCapableInterface Capabilities do not provide supportedMetadata anymore. The supported metadata is tied to the used storage adapter and thus, was already requiring projects to explicitly know the exact implementation of the cache backend in case of using these metadatas anyway KeyListIterator and the corresponding IteratorInterface does not provide the mode CURRENT_AS_METADATA anymore PluginOptions#getSerializer does not create a serializer anymore if a string option was passed, instead, the string is returned Increment and decrement feature was removed from StorageInterface , so there is no more StorageInterface#incrementItem , StorageInterface#decrementItem , StorageInterface#decrementItems and StorageInterface#incrementItems this also removes incrementItem , incrementItems , decrementItem , derementItems events ( pre , post and exception ) Every method now has native return types Every property now has native types Every method argument now has native types ObjectCache does not inherit the CallbackCache pattern anymore","title":"Migration to Version 4.0"},{"location":"v4/migration/to-version-4/#migration-to-version-40","text":"Finally, native types everywhere . With v4.0, laminas-cache depends on laminas-servicemanager v4 which already introduced full native types and thus, cache now has native types as well. Along with these changes, we also decided to remove and/or enhance some features to make the usage of this component more user-friendly. So instead of working with metadata arrays, a new MetadataCapableInterface was introduced which provides a generic interface for storage adapters to tell both IDEs and static analysers to understand what metadata instances are returned for which storage adapter. This allows per-storage Metadata which can differ depending on the storage being used.","title":"Migration to Version 4.0"},{"location":"v4/migration/to-version-4/#checklist","text":"Ensure you are on latest laminas/laminas-cache v3 Ensure you are on latest laminas/laminas-cache-storage-adapter-* version (might differ) Verify that you are not using one of the following methods StorageInterface#incrementItem (no replacement available, should be implemented in userland code) StorageInterface#incrementItems (no replacement available, should be implemented in userland code) StorageInterface#decrementItem (no replacement available, should be implemented in userland code) StorageInterface#decrementItems (no replacement available, should be implemented in userland code) Verify that you are not using supportedMetadata capability (use MetadataCapableInterface#getMetadata instead) Verify that you are not using KeyListIterator with mode CURRENT_AS_METADATA (use the returned key instead and pass it to the MetadataCapable storage adapter ( NOTE: not all adapters do implement MetadataCapableInterface ) If you use the Serializer plugin Verify that if you pass a string as serializer option, you do not directly depend on the return value of PluginOptions#getSerializer (method will return string instead of instantiating a new SerializerInterface instance). The plugin itself can still handle string and an instance of SerializerInterface as in previous versions If you provide own plugins, storage adapters, pattern, you have to upgrade to v4 and update all method/argument/property (return-) types according to the updated versions. Check out rector which can help with this kind of migration If you are handling Laminas\\Cache\\Exception\\MissingKeyException , you can remove that code as the exception does not exist anymore Check if you use ObjectCache pattern, that your code does not expect an instance of CallbackCache to be passed","title":"Checklist"},{"location":"v4/migration/to-version-4/#new-features","text":"Every adapter which supports metadata now implements MetadataCapableInterface and provides a dedicated object containing all the metadata values it supports Adds support for psr/cache and psr/simple-cache v2 &amp; v3","title":"New Features"},{"location":"v4/migration/to-version-4/#removed-classes","text":"Laminas\\Cache\\Exception\\MissingKeyException","title":"Removed Classes"},{"location":"v4/migration/to-version-4/#breaking-changes","text":"AbstractAdapter and StorageInterface are not aware of the methods getMetadata anymore. These were moved to the new MetadataCapableInterface Capabilities do not provide supportedMetadata anymore. The supported metadata is tied to the used storage adapter and thus, was already requiring projects to explicitly know the exact implementation of the cache backend in case of using these metadatas anyway KeyListIterator and the corresponding IteratorInterface does not provide the mode CURRENT_AS_METADATA anymore PluginOptions#getSerializer does not create a serializer anymore if a string option was passed, instead, the string is returned Increment and decrement feature was removed from StorageInterface , so there is no more StorageInterface#incrementItem , StorageInterface#decrementItem , StorageInterface#decrementItems and StorageInterface#incrementItems this also removes incrementItem , incrementItems , decrementItem , derementItems events ( pre , post and exception ) Every method now has native return types Every property now has native types Every method argument now has native types ObjectCache does not inherit the CallbackCache pattern anymore","title":"Breaking Changes"},{"location":"v4/pattern/callback-cache/","text":"CallbackCache The callback cache pattern caches the results of arbitrary PHP callables. Quick Start use Laminas\\Cache\\Pattern\\CallbackCache; use Laminas\\Cache\\Pattern\\PatternOptions; // Or the equivalent manual instantiation: $callbackCache = new CallbackCache( $storage, new PatternOptions([ 'cache_output' =&gt; true, ]) ); Storage Adapter The $storage adapter can be any adapter which implements the StorageInterface . Check out the Pattern Quick Start -Section for a standard adapter which can be used here. Configuration Options Option Data Type Default Value Description storage string\\|array\\|Laminas\\Cache\\Storage\\StorageInterface none deprecated Adapter used for reading and writing cached data. cache_output bool true Whether or not to cache callback output. Examples Instantiating the Callback Cache Pattern use Laminas\\Cache\\Pattern\\CallbackCache; $callbackCache = new CallbackCache($storage); Available Methods In addition to the methods defined in the PatternInterface and the StorageCapableInterface , this implementation provides the following methods. namespace Laminas\\Cache\\Pattern; use Laminas\\Cache\\Exception; class CallbackCache extends AbstractStorageCapablePattern { /** * Call the specified callback or get the result from cache * * @param callable $callback A valid callback * @param array $args Callback arguments * @return mixed Result * @throws Exception\\RuntimeException if invalid cached data * @throws \\Exception */ public function call(callable $callback, array $args = []): mixed; /** * Intercept method overloading; proxies to call() * * @param callable-string $function Function name to call * @param array $args Function arguments * @return mixed * @throws Exception\\RuntimeException * @throws \\Exception */ public function __call(string $function, array $args): mixed; /** * Generate a unique key in base of a key representing the callback part * and a key representing the arguments part. * * @param callable $callback A valid callback * @param array $args Callback arguments * @return non-empty-string * @throws Exception\\RuntimeException * @throws Exception\\InvalidArgumentException */ public function generateKey(callable $callback, array $args = []): string; }","title":"CallbackCache"},{"location":"v4/pattern/callback-cache/#callbackcache","text":"The callback cache pattern caches the results of arbitrary PHP callables.","title":"CallbackCache"},{"location":"v4/pattern/callback-cache/#quick-start","text":"use Laminas\\Cache\\Pattern\\CallbackCache; use Laminas\\Cache\\Pattern\\PatternOptions; // Or the equivalent manual instantiation: $callbackCache = new CallbackCache( $storage, new PatternOptions([ 'cache_output' =&gt; true, ]) );","title":"Quick Start"},{"location":"v4/pattern/callback-cache/#configuration-options","text":"Option Data Type Default Value Description storage string\\|array\\|Laminas\\Cache\\Storage\\StorageInterface none deprecated Adapter used for reading and writing cached data. cache_output bool true Whether or not to cache callback output.","title":"Configuration Options"},{"location":"v4/pattern/callback-cache/#examples","text":"","title":"Examples"},{"location":"v4/pattern/callback-cache/#available-methods","text":"In addition to the methods defined in the PatternInterface and the StorageCapableInterface , this implementation provides the following methods. namespace Laminas\\Cache\\Pattern; use Laminas\\Cache\\Exception; class CallbackCache extends AbstractStorageCapablePattern { /** * Call the specified callback or get the result from cache * * @param callable $callback A valid callback * @param array $args Callback arguments * @return mixed Result * @throws Exception\\RuntimeException if invalid cached data * @throws \\Exception */ public function call(callable $callback, array $args = []): mixed; /** * Intercept method overloading; proxies to call() * * @param callable-string $function Function name to call * @param array $args Function arguments * @return mixed * @throws Exception\\RuntimeException * @throws \\Exception */ public function __call(string $function, array $args): mixed; /** * Generate a unique key in base of a key representing the callback part * and a key representing the arguments part. * * @param callable $callback A valid callback * @param array $args Callback arguments * @return non-empty-string * @throws Exception\\RuntimeException * @throws Exception\\InvalidArgumentException */ public function generateKey(callable $callback, array $args = []): string; }","title":"Available Methods"},{"location":"v4/pattern/capture-cache/","text":"CaptureCache The CaptureCache pattern is useful for generating static resources to return via HTTP request. When used in such a fashion, the web server needs to be configured to run a PHP script generating the requested resource so that subsequent requests for the same resource can be shipped without calling PHP again. This pattern comes with basic logic for managing generated resources. Quick Start For use with an Apache 404 handler extend the Apache configuration, e.g. .htdocs : ErrorDocument 404 /index.php And add the cache to the related application script, e.g. index.php : use Laminas\\Cache\\Pattern\\CaptureCache; use Laminas\\Cache\\Pattern\\PatternOptions; $capture = new CaptureCache( new PatternOptions([ 'public_dir' =&gt; __DIR__, ]) ); // Start capturing all output, excluding headers, and write to the public // directory: $capture-&gt;start(); // Don't forget to change the HTTP response code header('Status: 200', true, 200); // do stuff to dynamically generate output Configuration Options Option Data Type Default Value Description public_dir string none Location of the public web root directory in which to write output. index_filename string \"index.html\" The name of the index file if only a directory was requested. file_locking bool true Whether or not to lock output files when writing. file_permission int\\|false 0600 ( false on Windows) Default permissions for generated output files. dir_permission int\\|false 0700 ( false on Windows) Default permissions for generated output directories. umask int\\|false false Whether or not to umask generated output files / directories. Examples Scaling Images in the Web Root Using the following Apache 404 configuration: # .htdocs ErrorDocument 404 /index.php Use the following script: // index.php use Laminas\\Cache\\Pattern\\CaptureCache; use Laminas\\Cache\\Pattern\\PatternOptions; $capture = new CaptureCache( new PatternOptions([ 'public_dir' =&gt; __DIR__, ]) ); Available Methods In addition to the methods exposed in PatternInterface , this implementation exposes the following methods. namespace Laminas\\Cache\\Pattern; use Laminas\\Cache\\Exception; class CaptureCache extends AbstractPattern { /** * Starts capturing. */ public function start(string|null $pageId = null): void; /** * Write a page to the requested path. * * @throws Exception\\LogicException */ public function set(string $content, string|null $pageId = null): void; /** * Retrieve a generated page from the cache. * * @throws Exception\\LogicException * @throws Exception\\RuntimeException */ public function get(string|null $pageId = null): string|null; /** * Check if a cache exists for the given page. * * @throws Exception\\LogicException * @return bool */ public function has(string|null $pageId = null): bool; /** * Remove a page from the cache. * * @throws Exception\\LogicException * @throws Exception\\RuntimeException */ public function remove(string|null $pageId = null): bool; /** * Clear cached pages that match the specified glob pattern. * * @throws Exception\\LogicException */ public function clearByGlob(string $pattern = '**'): void; /** * Returns the generated file name. */ public function getFilename(string|null $pageId = null): string; }","title":"CaptureCache"},{"location":"v4/pattern/capture-cache/#capturecache","text":"The CaptureCache pattern is useful for generating static resources to return via HTTP request. When used in such a fashion, the web server needs to be configured to run a PHP script generating the requested resource so that subsequent requests for the same resource can be shipped without calling PHP again. This pattern comes with basic logic for managing generated resources.","title":"CaptureCache"},{"location":"v4/pattern/capture-cache/#quick-start","text":"For use with an Apache 404 handler extend the Apache configuration, e.g. .htdocs : ErrorDocument 404 /index.php And add the cache to the related application script, e.g. index.php : use Laminas\\Cache\\Pattern\\CaptureCache; use Laminas\\Cache\\Pattern\\PatternOptions; $capture = new CaptureCache( new PatternOptions([ 'public_dir' =&gt; __DIR__, ]) ); // Start capturing all output, excluding headers, and write to the public // directory: $capture-&gt;start(); // Don't forget to change the HTTP response code header('Status: 200', true, 200); // do stuff to dynamically generate output","title":"Quick Start"},{"location":"v4/pattern/capture-cache/#configuration-options","text":"Option Data Type Default Value Description public_dir string none Location of the public web root directory in which to write output. index_filename string \"index.html\" The name of the index file if only a directory was requested. file_locking bool true Whether or not to lock output files when writing. file_permission int\\|false 0600 ( false on Windows) Default permissions for generated output files. dir_permission int\\|false 0700 ( false on Windows) Default permissions for generated output directories. umask int\\|false false Whether or not to umask generated output files / directories.","title":"Configuration Options"},{"location":"v4/pattern/capture-cache/#examples","text":"","title":"Examples"},{"location":"v4/pattern/capture-cache/#available-methods","text":"In addition to the methods exposed in PatternInterface , this implementation exposes the following methods. namespace Laminas\\Cache\\Pattern; use Laminas\\Cache\\Exception; class CaptureCache extends AbstractPattern { /** * Starts capturing. */ public function start(string|null $pageId = null): void; /** * Write a page to the requested path. * * @throws Exception\\LogicException */ public function set(string $content, string|null $pageId = null): void; /** * Retrieve a generated page from the cache. * * @throws Exception\\LogicException * @throws Exception\\RuntimeException */ public function get(string|null $pageId = null): string|null; /** * Check if a cache exists for the given page. * * @throws Exception\\LogicException * @return bool */ public function has(string|null $pageId = null): bool; /** * Remove a page from the cache. * * @throws Exception\\LogicException * @throws Exception\\RuntimeException */ public function remove(string|null $pageId = null): bool; /** * Clear cached pages that match the specified glob pattern. * * @throws Exception\\LogicException */ public function clearByGlob(string $pattern = '**'): void; /** * Returns the generated file name. */ public function getFilename(string|null $pageId = null): string; }","title":"Available Methods"},{"location":"v4/pattern/intro/","text":"Introduction Cache patterns are configurable objects that solve known performance bottlenecks. Each should be used only in the specific situations they are designed to address. For example, you can use the CallbackCache or ObjectCache patterns to cache method and function calls; to cache output generation, the OutputCache pattern could assist. All cache patterns implement Laminas\\Cache\\Pattern\\PatternInterface , and most extend the abstract class Laminas\\Cache\\Pattern\\AbstractPattern , which provides common logic. Configuration is provided via the Laminas\\Cache\\Pattern\\PatternOptions class, which can be instantiated with an associative array of options passed to the constructor. To configure a pattern object, you can provide a Laminas\\Cache\\Pattern\\PatternOptions instance to the setOptions() method, or provide your options (either as an associative array or PatternOptions instance) to the second argument of the factory. It's also possible to use a single instance of Laminas\\Cache\\Pattern\\PatternOptions and pass it to multiple pattern objects. Quick Start Pattern objects can be created by instantiating one of the Laminas\\Cache\\Pattern\\*Cache classes. Standard Storage Adapter for Documentation A cache adapter needs a storage adapter. To be able to follow the examples in the documentation, the adapter for the filesystem or the BlackHole adapter can be used, for example. $storage = new Laminas\\Cache\\Storage\\Adapter\\Filesystem(); // or $storage = new Laminas\\Cache\\Storage\\Adapter\\BlackHole(); use Laminas\\Cache\\Pattern\\CallbackCache; use Laminas\\Cache\\Pattern\\PatternOptions; $callbackCache = new CallbackCache( $storage, new PatternOptions() ); Available Methods The following methods are implemented by every cache pattern. Please read documentation of specific patterns to get more information. namespace Laminas\\Cache\\Pattern; interface PatternInterface { /** * Get all pattern options */ public function getOptions(): PatternOptions; } There are cache patterns which depend on a storage. In this case, these adapters implement the StorageCapableInterface : namespace Laminas\\Cache\\Pattern; use Laminas\\Cache\\Storage\\StorageInterface; interface StorageCapableInterface extends PatternInterface { public function getStorage(): ?StorageInterface; }","title":"Introduction"},{"location":"v4/pattern/intro/#introduction","text":"Cache patterns are configurable objects that solve known performance bottlenecks. Each should be used only in the specific situations they are designed to address. For example, you can use the CallbackCache or ObjectCache patterns to cache method and function calls; to cache output generation, the OutputCache pattern could assist. All cache patterns implement Laminas\\Cache\\Pattern\\PatternInterface , and most extend the abstract class Laminas\\Cache\\Pattern\\AbstractPattern , which provides common logic. Configuration is provided via the Laminas\\Cache\\Pattern\\PatternOptions class, which can be instantiated with an associative array of options passed to the constructor. To configure a pattern object, you can provide a Laminas\\Cache\\Pattern\\PatternOptions instance to the setOptions() method, or provide your options (either as an associative array or PatternOptions instance) to the second argument of the factory. It's also possible to use a single instance of Laminas\\Cache\\Pattern\\PatternOptions and pass it to multiple pattern objects.","title":"Introduction"},{"location":"v4/pattern/intro/#quick-start","text":"Pattern objects can be created by instantiating one of the Laminas\\Cache\\Pattern\\*Cache classes.","title":"Quick Start"},{"location":"v4/pattern/intro/#available-methods","text":"The following methods are implemented by every cache pattern. Please read documentation of specific patterns to get more information. namespace Laminas\\Cache\\Pattern; interface PatternInterface { /** * Get all pattern options */ public function getOptions(): PatternOptions; } There are cache patterns which depend on a storage. In this case, these adapters implement the StorageCapableInterface : namespace Laminas\\Cache\\Pattern; use Laminas\\Cache\\Storage\\StorageInterface; interface StorageCapableInterface extends PatternInterface { public function getStorage(): ?StorageInterface; }","title":"Available Methods"},{"location":"v4/pattern/object-cache/","text":"ObjectCache The ObjectCache pattern is an extension to the CallbackCache pattern. It has the same methods, but instead caches output from any instance method calls or public properties. Quick Start use Laminas\\Cache\\Pattern\\ObjectCache; use Laminas\\Cache\\Pattern\\PatternOptions; use stdClass; $object = new stdClass(); $objectCache = new ObjectCache( $storage, new PatternOptions([ 'object' =&gt; $object, ]) ); Storage Adapter The $storage adapter can be any adapter which implements the StorageInterface . Check out the Pattern Quick Start -Section for a standard adapter which can be used here. Configuration Options Option Data Type Default Value Description storage string\\|array\\|Laminas\\Cache\\Storage\\StorageInterface none deprecated Adapter used for reading and writing cached data. object object none The object for which to cache method calls. object_key null\\|string Class name of object Hopefully unique! cache_output bool true Whether or not to cache method output. cache_by_default bool true Cache all method calls by default. object_cache_methods array [] List of methods to cache (if cache_by_default is disabled). object_non_cache_methods array [] List of methods to blacklist (if cache_by_default is enabled). object_cache_magic_properties bool false Whether or not to cache properties exposed by method overloading. Examples Caching a Filter use Laminas\\Cache\\Pattern\\ObjectCache; use Laminas\\Cache\\Pattern\\PatternOptions; $filter = new \\Laminas\\Filter\\RealPath(); $cachedFilter = new ObjectCache( $storage, new PatternOptions([ 'object' =&gt; $filter, 'object_key' =&gt; 'RealpathFilter', // The realpath filter doesn't output anything // so the output don't need to be caught and cached 'cache_output' =&gt; false, ]) ); $path = $cachedFilter-&gt;call(\"filter\", ['/www/var/path/../../mypath']); // OR $path = $cachedFilter-&gt;filter('/www/var/path/../../mypath'); Available Methods In addition to the methods defined in PatternInterface and the StorageCapableInterface , this implementation defines the following methods. namespace Laminas\\Cache\\Pattern; use Laminas\\Cache\\Exception; class ObjectCache extends CallbackCache { /** * Call and cache a class method * * @param non-empty-string $method Method name to call * @param array $args Method arguments * @return mixed * @throws Exception\\RuntimeException * @throws \\Exception */ public function call(string $method, array $args = []): mixed; /** * Method overloading: proxies to call(). * * @param non-empty-string $method Method name to call * @param array $args Method arguments * @return mixed * @throws Exception\\RuntimeException * @throws \\Exception */ public function __call(string $method, array $args): mixed; /** * Generate a unique key in base of a key representing the callback part * and a key representing the arguments part. * * @param non-empty-string $method The method * @param array $args Callback arguments * @return non-empty-string * @throws Exception\\RuntimeException */ public function generateKey(string $methodOrProperty, array $args = []): string; /** * Property overloading: write data to a named property. * * NOTE: * Magic properties will be cached too if the option cacheMagicProperties * is enabled and the property doesn't exist in real. If so it calls __set * and removes cached data of previous __get and __isset calls. * * @param non-empty-string $name * @see http://php.net/manual/language.oop5.overloading.php#language.oop5.overloading.members */ public function __set(string $name, mixed $value): void; /** * Property overloading: read data from a named property. * * NOTE: * Magic properties will be cached too if the option cacheMagicProperties * is enabled and the property doesn't exist in real. If so it calls __get. * * @param non-empty-string $name * @see http://php.net/manual/language.oop5.overloading.php#language.oop5.overloading.members */ public function __get($name): mixed; /** * Property overloading: check if a named property exists. * * NOTE: * Magic properties will be cached too if the option cacheMagicProperties * is enabled and the property doesn't exist in real. If so it calls __get. * * @param non-empty-string $name * @see http://php.net/manual/language.oop5.overloading.php#language.oop5.overloading.members */ public function __isset($name): bool; /** * Property overloading: unset a named property. * * NOTE: * Magic properties will be cached too if the option cacheMagicProperties * is enabled and the property doesn't exist in real. If so it removes * previous cached __isset and __get calls. * * @param non-empty-string $name * @see http://php.net/manual/language.oop5.overloading.php#language.oop5.overloading.members */ public function __unset(string $name): void; /** * Handle casting to string * * @see http://php.net/manual/language.oop5.magic.php#language.oop5.magic.tostring */ public function __toString(): string; /** * Intercept and cache invokable usage. * * @see http://php.net/manual/language.oop5.magic.php#language.oop5.magic.invoke */ public function __invoke(): mixed; }","title":"ObjectCache"},{"location":"v4/pattern/object-cache/#objectcache","text":"The ObjectCache pattern is an extension to the CallbackCache pattern. It has the same methods, but instead caches output from any instance method calls or public properties.","title":"ObjectCache"},{"location":"v4/pattern/object-cache/#quick-start","text":"use Laminas\\Cache\\Pattern\\ObjectCache; use Laminas\\Cache\\Pattern\\PatternOptions; use stdClass; $object = new stdClass(); $objectCache = new ObjectCache( $storage, new PatternOptions([ 'object' =&gt; $object, ]) );","title":"Quick Start"},{"location":"v4/pattern/object-cache/#configuration-options","text":"Option Data Type Default Value Description storage string\\|array\\|Laminas\\Cache\\Storage\\StorageInterface none deprecated Adapter used for reading and writing cached data. object object none The object for which to cache method calls. object_key null\\|string Class name of object Hopefully unique! cache_output bool true Whether or not to cache method output. cache_by_default bool true Cache all method calls by default. object_cache_methods array [] List of methods to cache (if cache_by_default is disabled). object_non_cache_methods array [] List of methods to blacklist (if cache_by_default is enabled). object_cache_magic_properties bool false Whether or not to cache properties exposed by method overloading.","title":"Configuration Options"},{"location":"v4/pattern/object-cache/#examples","text":"","title":"Examples"},{"location":"v4/pattern/object-cache/#available-methods","text":"In addition to the methods defined in PatternInterface and the StorageCapableInterface , this implementation defines the following methods. namespace Laminas\\Cache\\Pattern; use Laminas\\Cache\\Exception; class ObjectCache extends CallbackCache { /** * Call and cache a class method * * @param non-empty-string $method Method name to call * @param array $args Method arguments * @return mixed * @throws Exception\\RuntimeException * @throws \\Exception */ public function call(string $method, array $args = []): mixed; /** * Method overloading: proxies to call(). * * @param non-empty-string $method Method name to call * @param array $args Method arguments * @return mixed * @throws Exception\\RuntimeException * @throws \\Exception */ public function __call(string $method, array $args): mixed; /** * Generate a unique key in base of a key representing the callback part * and a key representing the arguments part. * * @param non-empty-string $method The method * @param array $args Callback arguments * @return non-empty-string * @throws Exception\\RuntimeException */ public function generateKey(string $methodOrProperty, array $args = []): string; /** * Property overloading: write data to a named property. * * NOTE: * Magic properties will be cached too if the option cacheMagicProperties * is enabled and the property doesn't exist in real. If so it calls __set * and removes cached data of previous __get and __isset calls. * * @param non-empty-string $name * @see http://php.net/manual/language.oop5.overloading.php#language.oop5.overloading.members */ public function __set(string $name, mixed $value): void; /** * Property overloading: read data from a named property. * * NOTE: * Magic properties will be cached too if the option cacheMagicProperties * is enabled and the property doesn't exist in real. If so it calls __get. * * @param non-empty-string $name * @see http://php.net/manual/language.oop5.overloading.php#language.oop5.overloading.members */ public function __get($name): mixed; /** * Property overloading: check if a named property exists. * * NOTE: * Magic properties will be cached too if the option cacheMagicProperties * is enabled and the property doesn't exist in real. If so it calls __get. * * @param non-empty-string $name * @see http://php.net/manual/language.oop5.overloading.php#language.oop5.overloading.members */ public function __isset($name): bool; /** * Property overloading: unset a named property. * * NOTE: * Magic properties will be cached too if the option cacheMagicProperties * is enabled and the property doesn't exist in real. If so it removes * previous cached __isset and __get calls. * * @param non-empty-string $name * @see http://php.net/manual/language.oop5.overloading.php#language.oop5.overloading.members */ public function __unset(string $name): void; /** * Handle casting to string * * @see http://php.net/manual/language.oop5.magic.php#language.oop5.magic.tostring */ public function __toString(): string; /** * Intercept and cache invokable usage. * * @see http://php.net/manual/language.oop5.magic.php#language.oop5.magic.invoke */ public function __invoke(): mixed; }","title":"Available Methods"},{"location":"v4/pattern/output-cache/","text":"OutputCache The OutputCache pattern caches output between calls to start() and end() . Quick Start use Laminas\\Cache\\Pattern\\OutputCache; use Laminas\\Cache\\Pattern\\PatternOptions; $outputCache = new OutputCache( $storage, new PatternOptions() ); Storage Adapter The $storage adapter can be any adapter which implements the StorageInterface . Check out the Pattern Quick Start -Section for a standard adapter which can be used here. Configuration Options Option Data Type Default Value Description storage string\\|array\\|Laminas\\Cache\\Storage\\StorageInterface none deprecated Adapter used for reading and writing cached data. Examples Caching a View Script use Laminas\\Cache\\Pattern\\OutputCache; use Laminas\\Cache\\Pattern\\PatternOptions; $outputCache = new OutputCache( $storage, new PatternOptions() ); $outputCache-&gt;start('mySimpleViewScript'); include '/path/to/view/script.phtml'; $outputCache-&gt;end(); Available Methods In addition to the methods defined in PatternInterface and StorageCapableInterface , this implementation defines the following methods. namespace Laminas\\Cache\\Pattern; use Laminas\\Cache\\Exception; class OutputCache extends AbstractStorageCapablePattern { /** * If there is a cached item with the given key, display its data, and * return true. Otherwise, start buffering output until end() is called, or * the script ends. * * @param non-empty-string $key * @throws Exception\\MissingKeyException if key is missing */ public function start(string $key): bool; /** * Stop buffering output, write buffered data to the cache using the key * provided to start(), and display the buffer. * * @throws Exception\\RuntimeException if output cache not started or buffering not active * @return bool TRUE on success, FALSE on failure writing to cache */ public function end(): bool; }","title":"OutputCache"},{"location":"v4/pattern/output-cache/#outputcache","text":"The OutputCache pattern caches output between calls to start() and end() .","title":"OutputCache"},{"location":"v4/pattern/output-cache/#quick-start","text":"use Laminas\\Cache\\Pattern\\OutputCache; use Laminas\\Cache\\Pattern\\PatternOptions; $outputCache = new OutputCache( $storage, new PatternOptions() );","title":"Quick Start"},{"location":"v4/pattern/output-cache/#configuration-options","text":"Option Data Type Default Value Description storage string\\|array\\|Laminas\\Cache\\Storage\\StorageInterface none deprecated Adapter used for reading and writing cached data.","title":"Configuration Options"},{"location":"v4/pattern/output-cache/#examples","text":"","title":"Examples"},{"location":"v4/pattern/output-cache/#available-methods","text":"In addition to the methods defined in PatternInterface and StorageCapableInterface , this implementation defines the following methods. namespace Laminas\\Cache\\Pattern; use Laminas\\Cache\\Exception; class OutputCache extends AbstractStorageCapablePattern { /** * If there is a cached item with the given key, display its data, and * return true. Otherwise, start buffering output until end() is called, or * the script ends. * * @param non-empty-string $key * @throws Exception\\MissingKeyException if key is missing */ public function start(string $key): bool; /** * Stop buffering output, write buffered data to the cache using the key * provided to start(), and display the buffer. * * @throws Exception\\RuntimeException if output cache not started or buffering not active * @return bool TRUE on success, FALSE on failure writing to cache */ public function end(): bool; }","title":"Available Methods"},{"location":"v4/storage/adapter/","text":"Adapters Storage adapters are wrappers for real storage resources such as memory or the filesystem, using the well known adapter pattern. They come with tons of methods to read, write, and modify stored items, and to get information about stored items and the storage. All adapters implement Laminas\\Cache\\Storage\\StorageInterface , and most extend Laminas\\Cache\\Storage\\Adapter\\AbstractAdapter , which provides a foundation of common logic. Configuration is handled by either Laminas\\Cache\\Storage\\Adapter\\AdapterOptions , or an adapter-specific options class if it exists. You may pass the options instance to the class at instantiation, via the setOptions() method, or, alternately, pass an associative array of options in either place (internally, these are then passed to an options class instance). Alternately, you can pass associative array to the Laminas\\Cache\\Service\\StorageAdapterFactoryInterface::create method. Quick Start Caching adapters can either be created from the provided Laminas\\Cache\\Service\\StorageAdapterFactoryInterface , or by instantiating one of the Laminas\\Cache\\Storage\\Adapter\\* classes. To make life easier, the Laminas\\Cache\\Service\\StorageAdapterFactoryInterface comes with a create() method to create an adapter and all requested plugins at once. use Laminas\\Cache\\Service\\StorageAdapterFactoryInterface; use Laminas\\Cache\\Service\\StoragePluginFactoryInterface; use Psr\\Container\\ContainerInterface; /** @var ContainerInterface $container */ $container = null; // can be any configured PSR-11 container /** @var StorageAdapterFactoryInterface $storageFactory */ $storageFactory = $container-&gt;get(StorageAdapterFactoryInterface::class); // Via factory: $cache = $storageFactory-&gt;create( 'apcu', ['ttl' =&gt; 3600], [ [ 'name' =&gt; 'exception_handler', 'options' =&gt; [ 'throw_exceptions' =&gt; false, ], ], ] ); // Via array configuration: $cache = $storageFactory-&gt;createFromArrayConfiguration([ 'adapter' =&gt; 'apcu', 'options' =&gt; ['ttl' =&gt; 3600], 'plugins' =&gt; [ [ 'name' =&gt; 'exception_handler', 'options' =&gt; [ 'throw_exceptions' =&gt; false, ], ], ], ]); // Alternately, create the adapter and plugin separately: $cache = $storageFactory-&gt;create('apcu', ['ttl' =&gt; 3600]); $pluginFactory = $container-&gt;get(StoragePluginFactoryInterface::class); $plugin = $pluginFactory-&gt;create('exception_handler', [ 'throw_exceptions' =&gt; false, ]); $cache-&gt;addPlugin($plugin); // Or do it completely manually: $cache = new Laminas\\Cache\\Storage\\Adapter\\Apcu(); $cache-&gt;getOptions()-&gt;setTtl(3600); $plugin = new Laminas\\Cache\\Storage\\Plugin\\ExceptionHandler(); $plugin-&gt;getOptions()-&gt;setThrowExceptions(false); $cache-&gt;addPlugin($plugin); Many Methods throw Exceptions Because many caching operations throw an exception on error, you need to catch them. You can do so manually, or you can use the plugin Laminas\\Cache\\Storage\\Plugin\\ExceptionHandler with throw_exceptions set to false to automatically catch them. You can also define an exception_callback to log exceptions. Basic Configuration Options The following configuration options are defined by Laminas\\Cache\\Storage\\Adapter\\AdapterOptions and are available for every supported adapter. Adapter-specific configuration options are described on adapter level below. Option Data Type Default Value Description ttl integer 0 Time to live namespace string \"laminascache\" The “namespace” in which cache items will live key_pattern null\\|string null Pattern against which to validate cache keys readable boolean true Enable/Disable reading data from cache writable boolean true Enable/Disable writing data to cache StorageInterface Laminas\\Cache\\Storage\\StorageInterface is the basic interface implemented by all storage adapters. namespace Laminas\\Cache\\Storage; use Laminas\\Cache\\Storage\\Adapter\\AdapterOptions; use Traversable; interface StorageInterface { public function setOptions(AdapterOptions|iterable $options): self; public function getOptions(): AdapterOptions; /** * @param non-empty-string $key * @throws \\Laminas\\Cache\\Exception\\ExceptionInterface */ public function getItem(string $key, bool|null &amp;$success = null, mixed &amp;$casToken = null): mixed; /** * @param non-empty-list&lt;non-empty-string&gt; $keys * @return array&lt;non-empty-string,mixed&gt; Associative array of keys and values * @throws \\Laminas\\Cache\\Exception\\ExceptionInterface */ public function getItems(array $keys); /** * Test if an item exists. * * @param non-empty-string $key * @throws \\Laminas\\Cache\\Exception\\ExceptionInterface */ public function hasItem(string $key): bool; /** * Test multiple items. * * @param non-empty-array&lt;non-empty-string&gt; $keys * @return list&lt;non-empty-string&gt; Array of found keys * @throws \\Laminas\\Cache\\Exception\\ExceptionInterface */ public function hasItems(array $keys): array; /** * Store an item. * * @param non-empty-string $key * @throws \\Laminas\\Cache\\Exception\\ExceptionInterface */ public function setItem(string $key, mixed $value): bool; /** * Store multiple items. * * @param non-empty-array&lt;non-empty-string,mixed&gt; $keyValuePairs * @return list&lt;non-empty-string&gt; Array of not stored keys * @throws \\Laminas\\Cache\\Exception\\ExceptionInterface */ public function setItems(array $keyValuePairs): array; /** * Add an item. * * @param non-empty-string $key * @throws \\Laminas\\Cache\\Exception\\ExceptionInterface */ public function addItem(string $key, mixed $value): bool; /** * Add multiple items. * * @param non-empty-array&lt;non-empty-string,mixed&gt; $keyValuePairs * @return list&lt;non-empty-string&gt; Array of not stored keys * @throws \\Laminas\\Cache\\Exception\\ExceptionInterface */ public function addItems(array $keyValuePairs): array; /** * Replace an existing item. * * @param non-empty-string $key * @throws \\Laminas\\Cache\\Exception\\ExceptionInterface */ public function replaceItem(string $key, mixed $value): bool; /** * Replace multiple existing items. * * @param non-empty-array&lt;non-empty-string,mixed&gt; $keyValuePairs * @return list&lt;non-empty-string&gt; Array of not stored keys * @throws \\Laminas\\Cache\\Exception\\ExceptionInterface */ public function replaceItems(array $keyValuePairs): array; /** * Set an item only if token matches * * It uses the token received from getItem() to check if the item has * changed before overwriting it. * * @param non-empty-string $key * @throws \\Laminas\\Cache\\Exception\\ExceptionInterface * @see getItem() * @see setItem() */ public function checkAndSetItem(mixed $token, string $key, mixed $value): bool; /** * Reset lifetime of an item * * @param non-empty-string $key * @throws \\Laminas\\Cache\\Exception\\ExceptionInterface */ public function touchItem(string $key): bool; /** * Reset lifetime of multiple items. * * @param non-empty-list&lt;non-empty-string&gt; $keys * @return list&lt;non-empty-string&gt; Array of not updated keys * @throws \\Laminas\\Cache\\Exception\\ExceptionInterface */ public function touchItems(array $keys): array; /** * Remove an item. * * @param non-empty-string $key * @throws \\Laminas\\Cache\\Exception\\ExceptionInterface */ public function removeItem(string $key): bool; /** * Remove multiple items. * * @param non-empty-array&lt;non-empty-string&gt; $keys * @return list&lt;non-empty-string&gt; Array of not removed keys * @throws \\Laminas\\Cache\\Exception\\ExceptionInterface */ public function removeItems(array $keys): array; public function getCapabilities(): Capabilities; } AvailableSpaceCapableInterface Laminas\\Cache\\Storage\\AvailableSpaceCapableInterface implements a method to allow retrieving the current available space remaining in storage. namespace Laminas\\Cache\\Storage; interface AvailableSpaceCapableInterface { /** * Get available space in bytes */ public function getAvailableSpace(): int; } TotalSpaceCapableInterface Laminas\\Cache\\Storage\\TotalSpaceCapableInterface implements a method to allow retrieving the total storage space. namespace Laminas\\Cache\\Storage; interface TotalSpaceCapableInterface { /** * Get total space in bytes */ public function getTotalSpace(): int; } ClearByNamespaceInterface Laminas\\Cache\\Storage\\ClearByNamespaceInterface implements a method to allow clearing all cached items within a given namespace. namespace Laminas\\Cache\\Storage; interface ClearByNamespaceInterface { /** * Remove items of given namespace * * @param non-empty-string $namespace */ public function clearByNamespace(string $namespace): bool; } ClearByPrefixInterface Laminas\\Cache\\Storage\\ClearByPrefixInterface implements a method to allow clearing all cached items that have a given prefix (within the currently configured namespace). namespace Laminas\\Cache\\Storage; interface ClearByPrefixInterface { /** * Remove items matching given prefix * * @param non-empty-string $prefix */ public function clearByPrefix(string $prefix): bool; } ClearExpiredInterface Laminas\\Cache\\Storage\\ClearExpiredInterface implements a method to allow clearing all expired items (within the current configured namespace). namespace Laminas\\Cache\\Storage; interface ClearExpiredInterface { /** * Remove expired items */ public function clearExpired(): bool; } FlushableInterface Laminas\\Cache\\Storage\\FlushableInterface implements a method for flushing the entire cache storage. namespace Laminas\\Cache\\Storage; interface FlushableInterface { /** * Flush the whole storage */ public function flush(): bool; } IterableInterface Laminas\\Cache\\Storage\\IterableInterface implements a method for retrieving an iterator of all items in storage. It extends IteratorAggregate , so it's possible to directly iterate over the storage implementations that implement this interface using foreach . namespace Laminas\\Cache\\Storage; use IteratorAggregate; /** * @template-covariant TKey * @template-covariant TValue * @template-extends IteratorAggregate&lt;TKey,TValue&gt; */ interface IterableInterface extends IteratorAggregate { public function getIterator(): IteratorInterface; } OptimizableInterface Laminas\\Cache\\Storage\\OptimizableInterface implements a method for running optimization processes on the storage adapter. namespace Laminas\\Cache\\Storage; interface OptimizableInterface { /** * Optimize the storage */ public function optimize(): bool; } TaggableInterface Laminas\\Cache\\Storage\\TaggableInterface implements methods for tagging items, and cleaning (expiring) items matching tags. namespace Laminas\\Cache\\Storage; interface TaggableInterface { /** * Set tags to an item by given key. * An empty array will remove all tags. * * @param non-empty-string $key * @param string[] $tags */ public function setTags(string $key, array $tags): bool; /** * Get tags of an item by given key * * @param non-empty-string $key * @return string[]|false */ public function getTags(string $key): array|false; /** * Remove items matching given tags. * * If $disjunction only one of the given tags must match * else all given tags must match. * * @param string[] $tags */ public function clearByTags(array $tags, bool $disjunction = false): bool; } APCu Adapter Laminas\\Cache\\Storage\\Adapter\\Apcu stores cache items in shared memory through the PHP extension APCu (Alternative PHP Cache). This adapter implements the following interfaces: Laminas\\Cache\\Storage\\StorageInterface Laminas\\Cache\\Storage\\AvailableSpaceCapableInterface Laminas\\Cache\\Storage\\ClearByNamespaceInterface Laminas\\Cache\\Storage\\ClearByPrefixInterface Laminas\\Cache\\Storage\\FlushableInterface Laminas\\Cache\\Storage\\IterableInterface Laminas\\Cache\\Storage\\TotalSpaceCapableInterface Capabilities Capability Value supportedDatatypes null , bool , int , float , string , array (serialized), object (serialized) ttlSupported true ttlPrecision 1 usesRequestTime value of apc.use_request_time INI value, disabled by default. maxKeyLength 5182 namespaceIsPrefix true Metadata The APCu adapter does provide a couple of metadatas, which can be fetched by by using either MetadataCapableInterface#getMetadata or MetadataCapableInterface#getMetadatas . It will return an object with the following properties (or null): Metadata Type Description internalKey string The internal key used to store the cache item lastAccessTime int The time the cache item was last accessed creationTime int The time the cache item was created lastModifiedTime int The time the cache item was last modified size int The size the cache item is consuming within the cache hits int The amount of times the item was requested and returned from the backend timeToLive int The overall time to live (in seconds) the cache item was persisted for Adapter Specific Options Name Data Type Default Value Description namespace_separator string \":\" A separator for the namespace and prefix. BlackHole Adapter Laminas\\Cache\\Storage\\Adapter\\BlackHole does not store any cache items. This adapter is useful to bypass caching behavior. This might be the case in development mode or unit testing. This adapter implements the following interfaces: Laminas\\Cache\\Storage\\StorageInterface Laminas\\Cache\\Storage\\AvailableSpaceCapableInterface Laminas\\Cache\\Storage\\ClearByNamespaceInterface Laminas\\Cache\\Storage\\ClearByPrefixInterface Laminas\\Cache\\Storage\\ClearExpiredInterface Laminas\\Cache\\Storage\\FlushableInterface Laminas\\Cache\\Storage\\IterableInterface Laminas\\Cache\\Storage\\OptimizableInterface Laminas\\Cache\\Storage\\TaggableInterface Laminas\\Cache\\Storage\\TotalSpaceCapableInterface Capabilities Capability Value supportedDatatypes null , bool , int , float , string , array , object ttlSupported true ttlPrecision 1 usesRequestTime false maxKeyLength unlimited as nothing will be cached anyways namespaceIsPrefix true Filesystem Adapter Laminas\\Cache\\Storage\\Adapter\\Filesystem stores cache items on the filesystem. This adapter implements the following interfaces: Laminas\\Cache\\Storage\\StorageInterface Laminas\\Cache\\Storage\\AvailableSpaceCapableInterface Laminas\\Cache\\Storage\\ClearByNamespaceInterface Laminas\\Cache\\Storage\\ClearByPrefixInterface Laminas\\Cache\\Storage\\ClearExpiredInterface Laminas\\Cache\\Storage\\FlushableInterface Laminas\\Cache\\Storage\\IterableInterface Laminas\\Cache\\Storage\\OptimizableInterface Laminas\\Cache\\Storage\\TaggableInterface Laminas\\Cache\\Storage\\TotalSpaceCapableInterface Capabilities Capability Value supportedDatatypes string , null =&gt; string , boolean =&gt; string , integer =&gt; string , double =&gt; string ttlSupported true ttlPrecision 1 usesRequestTime false maxKeyLength 249 (this is the maximum, but depending on the namespace being used, the length might be lower) namespaceIsPrefix true Metadata Metadata Type Description lastAccessTime int\\|null The time the cache item was last accessed creationTime int\\|null The time the cache item was created lastModifiedTime int\\|null The time the cache item was last modified filesize int\\|null The amount of bytes the cache item is consuming in the filesystem filespec string The absolute path to the cache file without suffix Adapter Specific Options Name Data Type Default Value Description namespace_separator string \":\" A separator for the namespace and prefix cache_dir string \"\" Directory to store cache files. clear_stat_cache boolean true Call clearstatcache() enabled? dir_level integer 1 Defines how much sub-directories should be created. dir_permission integer\\|false 0700 Set explicit permission on creating new directories. file_locking boolean true Lock files on writing. file_permission integer false 0600 Set explicit permission on creating new files. key_pattern string /^[a-z0-9_\\+\\-]*$/Di Validate key against pattern. no_atime boolean true Don’t get fileatime as atime on metadata. no_ctime boolean true Don’t get filectime as ctime on metadata. umask integer\\|false false Use umask to set file and directory permissions. unserializable_classes boolean\\|non-empty-list&lt;class-string&gt; true A list of classes which are allowed for unserialization when reading cache values. Available as of v3.0 of the adapter. Memcached Adapter Laminas\\Cache\\Storage\\Adapter\\Memcached stores cache items over the memcached protocol, using the PHP extension memcached , based on Libmemcached . This adapter implements the following interfaces: Laminas\\Cache\\Storage\\StorageInterface Laminas\\Cache\\Storage\\AvailableSpaceCapableInterface Laminas\\Cache\\Storage\\FlushableInterface Laminas\\Cache\\Storage\\TotalSpaceCapableInterface Capabilities Capability Value supportedDatatypes null , boolean , integer , double , string , array (serialized), object (serialized) ttlSupported true ttlPrecision 1 usesRequestTime false maxKeyLength 255 namespaceIsPrefix true Adapter Specific Options Name Data Type Default Value Description servers array [] List of servers in the format [] = [string host, integer port] lib_options array [] Associative array of Libmemcached options where the array key is the option name (without the prefix OPT_ ) or the constant value. The array value is the option value. Please read the memcached setOption() page for more information Redis Adapter Laminas\\Cache\\Storage\\Adapter\\Redis stores cache items over the Redis protocol using the PHP extension PhpRedis . This adapter implements the following interfaces: Laminas\\Cache\\Storage\\ClearByNamespaceInterface Laminas\\Cache\\Storage\\ClearByPrefixInterface Laminas\\Cache\\Storage\\FlushableInterface Laminas\\Cache\\Storage\\TotalSpaceCapableInterface Capabilities Capability Value supportedDatatypes string , array (serialized), object (serialized) ttlSupported true ttlPrecision 1 usesRequestTime false maxKeyLength 512000000 (in Redis v3+, 255 in older versions) namespaceIsPrefix true Metadata Metadata Type Description remainingTimeToLive int\\|null The amount of time (seconds) the cache item will remain in the cache. Will be null in case the cache item won't expire. Adapter Specific Options Name Data Type Default Value Description database integer 0 Set database identifier. lib_options array [] Associative array of Redis options where the array key is the option name. namespace_separator string \":\" A separator for the namespace and prefix. password string \"\" Set password. persistent_id string Set persistent id (name of the connection, leave blank to not use a persistent connection). resource_manager string \"\" Set the Redis resource manager to use server string\\|array \"\" See below. server can be described as any of the following: Uri /path/to/sock.sock Associative array: ['host' =&gt; &lt;host&gt;[, 'port' =&gt; &lt;port&gt;[, 'timeout' =&gt; &lt;timeout&gt;]]] List: [&lt;host&gt;[, &lt;port&gt;, [, &lt;timeout&gt;]]] RedisCluster Adapter Laminas\\Cache\\Storage\\Adapter\\RedisCluster stores cache items over the Redis cluster protocol using the PHP extension PhpRedis . This adapter implements the following interfaces: Laminas\\Cache\\Storage\\ClearByNamespaceInterface Laminas\\Cache\\Storage\\ClearByPrefixInterface Laminas\\Cache\\Storage\\FlushableInterface Capabilities Capability Value supportedDatatypes string , array (serialized), object (serialized) ttlSupported true ttlPrecision 1 usesRequestTime false maxKeyLength 512000000 (in Redis v3+, 255 in older versions) namespaceIsPrefix true Metadata Metadata Type Description remainingTimeToLive int\\|null The amount of time (seconds) the cache item will remain in the cache. Will be null in case the cache item won't expire. Adapter Specific Options Name Data Type Default Value Description lib_options array [] Associative array of Redis options where the array key is the options constant value (see RedisCluster::OPT_* constants for details). namespace_separator string \":\" A separator for the namespace and prefix. password string \"\" Password to authenticate with Redis server name string \"\" Name to determine configuration from php.ini ( MUST NOT be combined with seeds ) seeds array [] List of strings containing &lt;hostname&gt;:&lt;port&gt; ( MUST NOT be combined with name ) timeout float 1.0 Timeout for commands, see PhpRedis timeouts documentation for more background. read_timeout float 2.0 Read timeout for commands, see PhpRedis timeouts documentation for more background. persistent bool false Flag to specify whether to create a persistent connection or not version string \"\" The Redis server version. MUST be specified in a Semantic Versioning 2.0.0 format. This information is used to determine some features/capabilities without opening a connection to the server. Memory Adapter The Laminas\\Cache\\Storage\\Adapter\\Memory stores items in-memory in the current process only. This adapter implements the following interfaces: Laminas\\Cache\\Storage\\StorageInterface Laminas\\Cache\\Storage\\AvailableSpaceCapableInterface Laminas\\Cache\\Storage\\ClearByPrefixInterface Laminas\\Cache\\Storage\\ClearExpiredInterface Laminas\\Cache\\Storage\\FlushableInterface Laminas\\Cache\\Storage\\IterableInterface Laminas\\Cache\\Storage\\TaggableInterface Laminas\\Cache\\Storage\\TotalSpaceCapableInterface Capabilities Capability Value supportedDatatypes string , null , boolean , integer , double , array , object , resource ttlSupported true ttlPrecision 1 usesRequestTime false maxKeyLength 0 (unlimited) namespaceIsPrefix false Metadata Metadata Type Description lastModifiedTime float The time the cache item was last modified Adapter Specific Options Name Data Type Default Value Description max_items int 0 (unlimited) Limit of how many cache items are allowed to be stored. Available with v3.0 of the Memory adapter Max Items The adapter has the following behavior in regard to the max_items option: If the items persisted to the memory cache are exceeding the limit, a new item will be stored while the oldest item will be removed Current process only All stored items will be lost on termination of the script. For web-facing requests, this typically means the cache is volatile. ExtMongoDB Adapter Laminas\\Cache\\Storage\\Adapter\\ExtMongoDB stores cache items using the mongodb extension, and requires that the MongoDB PHP Client library is also installed. You can install the client library using the following: $ composer require mongodb/mongodb This adapter implements the following interfaces: Laminas\\Cache\\Storage\\FlushableInterface Capabilities Capability Value supportedDatatypes string , null , boolean , integer , double , array ttlSupported true ttlPrecision 1 usesRequestTime false maxKeyLength 255 namespaceIsPrefix true Metadata Metadata Type Description objectId string The primary key within the mongo collection. Adapter Specific Options Name Data Type Default Value Description lib_option array Associative array of options where the array key is the option name. namespace_separator string \":\" A separator for the namespace and prefix. Available keys for lib_option include: Key Default Description server mongodb://localhost:27017 The MongoDB server connection string (see the MongoDB\\Client docs ). database laminas Name of the database to use; MongoDB will create this database if it does not exist. collection cache Name of the collection to use; MongoDB will create this collection if it does not exist. connectionOptions ['fsync' =&gt; false, 'journal' =&gt; true] Associative array of URI options (such as authentication credentials or query string parameters) to pass to MongoDB\\\\Client (see the MongoDB\\Client docs ). driverOptions [] Associative array of driver options to pass to MongoDB\\\\Client (see the MongoDB\\Client docs ). Examples Basic Usage use Laminas\\Cache\\Service\\StorageAdapterFactoryInterface; use Psr\\Container\\ContainerInterface; /** @var ContainerInterface $container */ $container = null; // can be any configured PSR-11 container /** @var StorageAdapterFactoryInterface $storageFactory */ $storageFactory = $container-&gt;get(StorageAdapterFactoryInterface::class); $cache = $storageFactory-&gt;create( 'filesystem', [], [ // Don't throw exceptions on cache errors [ 'name' =&gt; 'exception_handler', 'options' =&gt; [ 'throw_exceptions' =&gt; false ], ], ] ); $key = 'unique-cache-key'; $result = $cache-&gt;getItem($key, $success); if (! $success) { $result = doExpensiveStuff(); $cache-&gt;setItem($key, $result); } Get multiple Rows from a Database use Laminas\\Cache\\Service\\StorageAdapterFactoryInterface; use Psr\\Container\\ContainerInterface; /** @var ContainerInterface $container */ $container = null; // can be any configured PSR-11 container /** @var StorageAdapterFactoryInterface $storageFactory */ $storageFactory = $container-&gt;get(StorageAdapterFactoryInterface::class); // Instantiate the cache instance using a namespace for the same type of items $cache = $storageFactory-&gt;create( 'filesystem', // With a namespace, we can indicate the same type of items, // so we can simply use the database id as the cache key [ 'namespace' =&gt; 'dbtable', ], [ // Don't throw exceptions on cache errors [ 'name' =&gt; 'exception_handler', 'options' =&gt; [ 'throw_exceptions' =&gt; false, ], ], // We store database rows on filesystem so we need to serialize them [ 'name' =&gt; 'Serializer', ], ] ); // Load two rows from cache if possible $ids = [1, 2]; $results = $cache-&gt;getItems($ids); if (count($results) &lt; count($ids)) { // Load rows from db if loading from cache failed $missingIds = array_diff($ids, array_keys($results)); $missingResults = []; $query = 'SELECT * FROM dbtable WHERE id IN (' . implode(',', $missingIds) . ')'; foreach ($pdo-&gt;query($query, PDO::FETCH_ASSOC) as $row) { $missingResults[ $row['id'] ] = $row; } // Update cache items of the loaded rows from db $cache-&gt;setItems($missingResults); // merge results from cache and db $results = array_merge($results, $missingResults); }","title":"Adapters"},{"location":"v4/storage/adapter/#adapters","text":"Storage adapters are wrappers for real storage resources such as memory or the filesystem, using the well known adapter pattern. They come with tons of methods to read, write, and modify stored items, and to get information about stored items and the storage. All adapters implement Laminas\\Cache\\Storage\\StorageInterface , and most extend Laminas\\Cache\\Storage\\Adapter\\AbstractAdapter , which provides a foundation of common logic. Configuration is handled by either Laminas\\Cache\\Storage\\Adapter\\AdapterOptions , or an adapter-specific options class if it exists. You may pass the options instance to the class at instantiation, via the setOptions() method, or, alternately, pass an associative array of options in either place (internally, these are then passed to an options class instance). Alternately, you can pass associative array to the Laminas\\Cache\\Service\\StorageAdapterFactoryInterface::create method.","title":"Adapters"},{"location":"v4/storage/adapter/#quick-start","text":"Caching adapters can either be created from the provided Laminas\\Cache\\Service\\StorageAdapterFactoryInterface , or by instantiating one of the Laminas\\Cache\\Storage\\Adapter\\* classes. To make life easier, the Laminas\\Cache\\Service\\StorageAdapterFactoryInterface comes with a create() method to create an adapter and all requested plugins at once. use Laminas\\Cache\\Service\\StorageAdapterFactoryInterface; use Laminas\\Cache\\Service\\StoragePluginFactoryInterface; use Psr\\Container\\ContainerInterface; /** @var ContainerInterface $container */ $container = null; // can be any configured PSR-11 container /** @var StorageAdapterFactoryInterface $storageFactory */ $storageFactory = $container-&gt;get(StorageAdapterFactoryInterface::class); // Via factory: $cache = $storageFactory-&gt;create( 'apcu', ['ttl' =&gt; 3600], [ [ 'name' =&gt; 'exception_handler', 'options' =&gt; [ 'throw_exceptions' =&gt; false, ], ], ] ); // Via array configuration: $cache = $storageFactory-&gt;createFromArrayConfiguration([ 'adapter' =&gt; 'apcu', 'options' =&gt; ['ttl' =&gt; 3600], 'plugins' =&gt; [ [ 'name' =&gt; 'exception_handler', 'options' =&gt; [ 'throw_exceptions' =&gt; false, ], ], ], ]); // Alternately, create the adapter and plugin separately: $cache = $storageFactory-&gt;create('apcu', ['ttl' =&gt; 3600]); $pluginFactory = $container-&gt;get(StoragePluginFactoryInterface::class); $plugin = $pluginFactory-&gt;create('exception_handler', [ 'throw_exceptions' =&gt; false, ]); $cache-&gt;addPlugin($plugin); // Or do it completely manually: $cache = new Laminas\\Cache\\Storage\\Adapter\\Apcu(); $cache-&gt;getOptions()-&gt;setTtl(3600); $plugin = new Laminas\\Cache\\Storage\\Plugin\\ExceptionHandler(); $plugin-&gt;getOptions()-&gt;setThrowExceptions(false); $cache-&gt;addPlugin($plugin);","title":"Quick Start"},{"location":"v4/storage/adapter/#basic-configuration-options","text":"The following configuration options are defined by Laminas\\Cache\\Storage\\Adapter\\AdapterOptions and are available for every supported adapter. Adapter-specific configuration options are described on adapter level below. Option Data Type Default Value Description ttl integer 0 Time to live namespace string \"laminascache\" The “namespace” in which cache items will live key_pattern null\\|string null Pattern against which to validate cache keys readable boolean true Enable/Disable reading data from cache writable boolean true Enable/Disable writing data to cache","title":"Basic Configuration Options"},{"location":"v4/storage/adapter/#storageinterface","text":"Laminas\\Cache\\Storage\\StorageInterface is the basic interface implemented by all storage adapters. namespace Laminas\\Cache\\Storage; use Laminas\\Cache\\Storage\\Adapter\\AdapterOptions; use Traversable; interface StorageInterface { public function setOptions(AdapterOptions|iterable $options): self; public function getOptions(): AdapterOptions; /** * @param non-empty-string $key * @throws \\Laminas\\Cache\\Exception\\ExceptionInterface */ public function getItem(string $key, bool|null &amp;$success = null, mixed &amp;$casToken = null): mixed; /** * @param non-empty-list&lt;non-empty-string&gt; $keys * @return array&lt;non-empty-string,mixed&gt; Associative array of keys and values * @throws \\Laminas\\Cache\\Exception\\ExceptionInterface */ public function getItems(array $keys); /** * Test if an item exists. * * @param non-empty-string $key * @throws \\Laminas\\Cache\\Exception\\ExceptionInterface */ public function hasItem(string $key): bool; /** * Test multiple items. * * @param non-empty-array&lt;non-empty-string&gt; $keys * @return list&lt;non-empty-string&gt; Array of found keys * @throws \\Laminas\\Cache\\Exception\\ExceptionInterface */ public function hasItems(array $keys): array; /** * Store an item. * * @param non-empty-string $key * @throws \\Laminas\\Cache\\Exception\\ExceptionInterface */ public function setItem(string $key, mixed $value): bool; /** * Store multiple items. * * @param non-empty-array&lt;non-empty-string,mixed&gt; $keyValuePairs * @return list&lt;non-empty-string&gt; Array of not stored keys * @throws \\Laminas\\Cache\\Exception\\ExceptionInterface */ public function setItems(array $keyValuePairs): array; /** * Add an item. * * @param non-empty-string $key * @throws \\Laminas\\Cache\\Exception\\ExceptionInterface */ public function addItem(string $key, mixed $value): bool; /** * Add multiple items. * * @param non-empty-array&lt;non-empty-string,mixed&gt; $keyValuePairs * @return list&lt;non-empty-string&gt; Array of not stored keys * @throws \\Laminas\\Cache\\Exception\\ExceptionInterface */ public function addItems(array $keyValuePairs): array; /** * Replace an existing item. * * @param non-empty-string $key * @throws \\Laminas\\Cache\\Exception\\ExceptionInterface */ public function replaceItem(string $key, mixed $value): bool; /** * Replace multiple existing items. * * @param non-empty-array&lt;non-empty-string,mixed&gt; $keyValuePairs * @return list&lt;non-empty-string&gt; Array of not stored keys * @throws \\Laminas\\Cache\\Exception\\ExceptionInterface */ public function replaceItems(array $keyValuePairs): array; /** * Set an item only if token matches * * It uses the token received from getItem() to check if the item has * changed before overwriting it. * * @param non-empty-string $key * @throws \\Laminas\\Cache\\Exception\\ExceptionInterface * @see getItem() * @see setItem() */ public function checkAndSetItem(mixed $token, string $key, mixed $value): bool; /** * Reset lifetime of an item * * @param non-empty-string $key * @throws \\Laminas\\Cache\\Exception\\ExceptionInterface */ public function touchItem(string $key): bool; /** * Reset lifetime of multiple items. * * @param non-empty-list&lt;non-empty-string&gt; $keys * @return list&lt;non-empty-string&gt; Array of not updated keys * @throws \\Laminas\\Cache\\Exception\\ExceptionInterface */ public function touchItems(array $keys): array; /** * Remove an item. * * @param non-empty-string $key * @throws \\Laminas\\Cache\\Exception\\ExceptionInterface */ public function removeItem(string $key): bool; /** * Remove multiple items. * * @param non-empty-array&lt;non-empty-string&gt; $keys * @return list&lt;non-empty-string&gt; Array of not removed keys * @throws \\Laminas\\Cache\\Exception\\ExceptionInterface */ public function removeItems(array $keys): array; public function getCapabilities(): Capabilities; }","title":"StorageInterface"},{"location":"v4/storage/adapter/#availablespacecapableinterface","text":"Laminas\\Cache\\Storage\\AvailableSpaceCapableInterface implements a method to allow retrieving the current available space remaining in storage. namespace Laminas\\Cache\\Storage; interface AvailableSpaceCapableInterface { /** * Get available space in bytes */ public function getAvailableSpace(): int; }","title":"AvailableSpaceCapableInterface"},{"location":"v4/storage/adapter/#totalspacecapableinterface","text":"Laminas\\Cache\\Storage\\TotalSpaceCapableInterface implements a method to allow retrieving the total storage space. namespace Laminas\\Cache\\Storage; interface TotalSpaceCapableInterface { /** * Get total space in bytes */ public function getTotalSpace(): int; }","title":"TotalSpaceCapableInterface"},{"location":"v4/storage/adapter/#clearbynamespaceinterface","text":"Laminas\\Cache\\Storage\\ClearByNamespaceInterface implements a method to allow clearing all cached items within a given namespace. namespace Laminas\\Cache\\Storage; interface ClearByNamespaceInterface { /** * Remove items of given namespace * * @param non-empty-string $namespace */ public function clearByNamespace(string $namespace): bool; }","title":"ClearByNamespaceInterface"},{"location":"v4/storage/adapter/#clearbyprefixinterface","text":"Laminas\\Cache\\Storage\\ClearByPrefixInterface implements a method to allow clearing all cached items that have a given prefix (within the currently configured namespace). namespace Laminas\\Cache\\Storage; interface ClearByPrefixInterface { /** * Remove items matching given prefix * * @param non-empty-string $prefix */ public function clearByPrefix(string $prefix): bool; }","title":"ClearByPrefixInterface"},{"location":"v4/storage/adapter/#clearexpiredinterface","text":"Laminas\\Cache\\Storage\\ClearExpiredInterface implements a method to allow clearing all expired items (within the current configured namespace). namespace Laminas\\Cache\\Storage; interface ClearExpiredInterface { /** * Remove expired items */ public function clearExpired(): bool; }","title":"ClearExpiredInterface"},{"location":"v4/storage/adapter/#flushableinterface","text":"Laminas\\Cache\\Storage\\FlushableInterface implements a method for flushing the entire cache storage. namespace Laminas\\Cache\\Storage; interface FlushableInterface { /** * Flush the whole storage */ public function flush(): bool; }","title":"FlushableInterface"},{"location":"v4/storage/adapter/#iterableinterface","text":"Laminas\\Cache\\Storage\\IterableInterface implements a method for retrieving an iterator of all items in storage. It extends IteratorAggregate , so it's possible to directly iterate over the storage implementations that implement this interface using foreach . namespace Laminas\\Cache\\Storage; use IteratorAggregate; /** * @template-covariant TKey * @template-covariant TValue * @template-extends IteratorAggregate&lt;TKey,TValue&gt; */ interface IterableInterface extends IteratorAggregate { public function getIterator(): IteratorInterface; }","title":"IterableInterface"},{"location":"v4/storage/adapter/#optimizableinterface","text":"Laminas\\Cache\\Storage\\OptimizableInterface implements a method for running optimization processes on the storage adapter. namespace Laminas\\Cache\\Storage; interface OptimizableInterface { /** * Optimize the storage */ public function optimize(): bool; }","title":"OptimizableInterface"},{"location":"v4/storage/adapter/#taggableinterface","text":"Laminas\\Cache\\Storage\\TaggableInterface implements methods for tagging items, and cleaning (expiring) items matching tags. namespace Laminas\\Cache\\Storage; interface TaggableInterface { /** * Set tags to an item by given key. * An empty array will remove all tags. * * @param non-empty-string $key * @param string[] $tags */ public function setTags(string $key, array $tags): bool; /** * Get tags of an item by given key * * @param non-empty-string $key * @return string[]|false */ public function getTags(string $key): array|false; /** * Remove items matching given tags. * * If $disjunction only one of the given tags must match * else all given tags must match. * * @param string[] $tags */ public function clearByTags(array $tags, bool $disjunction = false): bool; }","title":"TaggableInterface"},{"location":"v4/storage/adapter/#apcu-adapter","text":"Laminas\\Cache\\Storage\\Adapter\\Apcu stores cache items in shared memory through the PHP extension APCu (Alternative PHP Cache). This adapter implements the following interfaces: Laminas\\Cache\\Storage\\StorageInterface Laminas\\Cache\\Storage\\AvailableSpaceCapableInterface Laminas\\Cache\\Storage\\ClearByNamespaceInterface Laminas\\Cache\\Storage\\ClearByPrefixInterface Laminas\\Cache\\Storage\\FlushableInterface Laminas\\Cache\\Storage\\IterableInterface Laminas\\Cache\\Storage\\TotalSpaceCapableInterface","title":"APCu Adapter"},{"location":"v4/storage/adapter/#blackhole-adapter","text":"Laminas\\Cache\\Storage\\Adapter\\BlackHole does not store any cache items. This adapter is useful to bypass caching behavior. This might be the case in development mode or unit testing. This adapter implements the following interfaces: Laminas\\Cache\\Storage\\StorageInterface Laminas\\Cache\\Storage\\AvailableSpaceCapableInterface Laminas\\Cache\\Storage\\ClearByNamespaceInterface Laminas\\Cache\\Storage\\ClearByPrefixInterface Laminas\\Cache\\Storage\\ClearExpiredInterface Laminas\\Cache\\Storage\\FlushableInterface Laminas\\Cache\\Storage\\IterableInterface Laminas\\Cache\\Storage\\OptimizableInterface Laminas\\Cache\\Storage\\TaggableInterface Laminas\\Cache\\Storage\\TotalSpaceCapableInterface","title":"BlackHole Adapter"},{"location":"v4/storage/adapter/#filesystem-adapter","text":"Laminas\\Cache\\Storage\\Adapter\\Filesystem stores cache items on the filesystem. This adapter implements the following interfaces: Laminas\\Cache\\Storage\\StorageInterface Laminas\\Cache\\Storage\\AvailableSpaceCapableInterface Laminas\\Cache\\Storage\\ClearByNamespaceInterface Laminas\\Cache\\Storage\\ClearByPrefixInterface Laminas\\Cache\\Storage\\ClearExpiredInterface Laminas\\Cache\\Storage\\FlushableInterface Laminas\\Cache\\Storage\\IterableInterface Laminas\\Cache\\Storage\\OptimizableInterface Laminas\\Cache\\Storage\\TaggableInterface Laminas\\Cache\\Storage\\TotalSpaceCapableInterface","title":"Filesystem Adapter"},{"location":"v4/storage/adapter/#memcached-adapter","text":"Laminas\\Cache\\Storage\\Adapter\\Memcached stores cache items over the memcached protocol, using the PHP extension memcached , based on Libmemcached . This adapter implements the following interfaces: Laminas\\Cache\\Storage\\StorageInterface Laminas\\Cache\\Storage\\AvailableSpaceCapableInterface Laminas\\Cache\\Storage\\FlushableInterface Laminas\\Cache\\Storage\\TotalSpaceCapableInterface","title":"Memcached Adapter"},{"location":"v4/storage/adapter/#redis-adapter","text":"Laminas\\Cache\\Storage\\Adapter\\Redis stores cache items over the Redis protocol using the PHP extension PhpRedis . This adapter implements the following interfaces: Laminas\\Cache\\Storage\\ClearByNamespaceInterface Laminas\\Cache\\Storage\\ClearByPrefixInterface Laminas\\Cache\\Storage\\FlushableInterface Laminas\\Cache\\Storage\\TotalSpaceCapableInterface","title":"Redis Adapter"},{"location":"v4/storage/adapter/#rediscluster-adapter","text":"Laminas\\Cache\\Storage\\Adapter\\RedisCluster stores cache items over the Redis cluster protocol using the PHP extension PhpRedis . This adapter implements the following interfaces: Laminas\\Cache\\Storage\\ClearByNamespaceInterface Laminas\\Cache\\Storage\\ClearByPrefixInterface Laminas\\Cache\\Storage\\FlushableInterface","title":"RedisCluster Adapter"},{"location":"v4/storage/adapter/#memory-adapter","text":"The Laminas\\Cache\\Storage\\Adapter\\Memory stores items in-memory in the current process only. This adapter implements the following interfaces: Laminas\\Cache\\Storage\\StorageInterface Laminas\\Cache\\Storage\\AvailableSpaceCapableInterface Laminas\\Cache\\Storage\\ClearByPrefixInterface Laminas\\Cache\\Storage\\ClearExpiredInterface Laminas\\Cache\\Storage\\FlushableInterface Laminas\\Cache\\Storage\\IterableInterface Laminas\\Cache\\Storage\\TaggableInterface Laminas\\Cache\\Storage\\TotalSpaceCapableInterface","title":"Memory Adapter"},{"location":"v4/storage/adapter/#extmongodb-adapter","text":"Laminas\\Cache\\Storage\\Adapter\\ExtMongoDB stores cache items using the mongodb extension, and requires that the MongoDB PHP Client library is also installed. You can install the client library using the following: $ composer require mongodb/mongodb This adapter implements the following interfaces: Laminas\\Cache\\Storage\\FlushableInterface","title":"ExtMongoDB Adapter"},{"location":"v4/storage/adapter/#examples","text":"","title":"Examples"},{"location":"v4/storage/capabilities/","text":"Storage Capabilities Storage capabilities describe how a storage adapter works, and which features it supports. To get capabilities of a storage adapter, you can use the method getCapabilities() , but only the storage adapter and its plugins have permissions to change them. Because capabilities are mutable, you can subscribe to the \"change\" event to get notifications; see the examples for details. If you are writing your own plugin or adapter, you can also change capabilities because you have access to the marker object and can create your own marker to instantiate a new instance of Laminas\\Cache\\Storage\\Capabilities . Available Methods namespace Laminas\\Cache\\Storage; use ArrayObject; use stdClass; use Laminas\\Cache\\Exception; use Laminas\\EventManager\\EventsCapableInterface; final class Capabilities { /** * @param int&lt;-1,max&gt; $maxKeyLength * @param SupportedDataTypesArrayShape $supportedDataTypes */ public function __construct( /** * Maximum supported key length for the cache backend */ public readonly int $maxKeyLength, /** * Whether the cache backend supports TTL */ public readonly bool $ttlSupported, public readonly bool $namespaceIsPrefix, /** * Contains the supported data types. * Depending on the cache backend in use, the type remains as is, is converted to a different type or is not * supported at all. */ public readonly array $supportedDataTypes, public readonly int|float $ttlPrecision, public readonly bool $usesRequestTime, ) { } } Examples Get Storage Capabilities and do specific Stuff based on them use Laminas\\Cache\\Service\\StorageAdapterFactoryInterface; use Psr\\Container\\ContainerInterface; /** @var ContainerInterface $container */ $container = null; // can be any configured PSR-11 container /** @var StorageAdapterFactoryInterface $storageFactory */ $storageFactory = $container-&gt;get(StorageAdapterFactoryInterface::class); $cache = $storageFactory-&gt;create('filesystem'); $supportedDataTypes = $cache-&gt;getCapabilities()-&gt;supportedDataTypes; // now you can run specific stuff in base of supported feature if ($supportedDataTypes['object']) { $cache-&gt;set($key, $object); } else { $cache-&gt;set($key, serialize($object)); }","title":"Capabilities"},{"location":"v4/storage/capabilities/#storage-capabilities","text":"Storage capabilities describe how a storage adapter works, and which features it supports. To get capabilities of a storage adapter, you can use the method getCapabilities() , but only the storage adapter and its plugins have permissions to change them. Because capabilities are mutable, you can subscribe to the \"change\" event to get notifications; see the examples for details. If you are writing your own plugin or adapter, you can also change capabilities because you have access to the marker object and can create your own marker to instantiate a new instance of Laminas\\Cache\\Storage\\Capabilities .","title":"Storage Capabilities"},{"location":"v4/storage/capabilities/#available-methods","text":"namespace Laminas\\Cache\\Storage; use ArrayObject; use stdClass; use Laminas\\Cache\\Exception; use Laminas\\EventManager\\EventsCapableInterface; final class Capabilities { /** * @param int&lt;-1,max&gt; $maxKeyLength * @param SupportedDataTypesArrayShape $supportedDataTypes */ public function __construct( /** * Maximum supported key length for the cache backend */ public readonly int $maxKeyLength, /** * Whether the cache backend supports TTL */ public readonly bool $ttlSupported, public readonly bool $namespaceIsPrefix, /** * Contains the supported data types. * Depending on the cache backend in use, the type remains as is, is converted to a different type or is not * supported at all. */ public readonly array $supportedDataTypes, public readonly int|float $ttlPrecision, public readonly bool $usesRequestTime, ) { } }","title":"Available Methods"},{"location":"v4/storage/capabilities/#examples","text":"","title":"Examples"},{"location":"v4/storage/plugin/","text":"Plugins Cache storage plugins are objects that provide additional functionality to or influence behavior of a storage adapter. The plugins listen to events the adapter triggers, and can: change the arguments provided to the method triggering the event (via *.post events) skip and directly return a result (by calling stopPropagation ) change the result (by calling setResult on the provided Laminas\\Cache\\Storage\\PostEvent ) catch exceptions (by reacting to Laminas\\Cache\\Storage\\ExceptionEvent ) Quick Start Storage plugins can either be created from Laminas\\Cache\\Service\\StoragePluginFactoryInterface::create() , or by instantiating one of the Laminas\\Cache\\Storage\\Plugin\\* classes. To make life easier, Laminas\\Cache\\Service\\StoragePluginFactoryInterface::create() can create both the requested adapter and all specified plugins at once. use Laminas\\Cache\\Service\\StoragePluginFactoryInterface; use Psr\\Container\\ContainerInterface; use Laminas\\Cache\\Service\\StorageAdapterFactoryInterface; /** @var ContainerInterface $container */ $container = null; // can be any configured PSR-11 container $storageFactory = $container-&gt;get(StorageAdapterFactoryInterface::class); // All at once: $cache = $storageFactory-&gt;create( 'filesystem', [], [ ['name' =&gt; 'serializer'], ] ); // Alternately, via discrete factory methods: $cache = $storageFactory-&gt;create('filesystem'); $pluginFactory = $container-&gt;get(StoragePluginFactoryInterface::class); $plugin = $pluginFactory-&gt;create('serializer'); $cache-&gt;addPlugin($plugin); // Or manually: $cache = new Laminas\\Cache\\Storage\\Adapter\\Filesystem(); $plugin = new Laminas\\Cache\\Storage\\Plugin\\Serializer(); $cache-&gt;addPlugin($plugin); The ClearExpiredByFactor Plugin Laminas\\Cache\\Storage\\Plugin\\ClearExpiredByFactor calls the storage method clearExpired() randomly (by factor) after every call of setItem() , setItems() , addItem() , and addItems() . Plugin specific Options Name Data Type Default Value Description clearing_factor integer 0 The automatic clearing factor. Adapter must implement ClearExpiredInterface The storage adapter must implement Laminas\\Cache\\Storage\\ClearExpiredInterface to work with this plugin. The ExceptionHandler Plugin Laminas\\Cache\\Storage\\Plugin\\ExceptionHandler catches all exceptions thrown on reading from or writing to the cache, and sends the exception to a defined callback function. You may also configure the plugin to re-throw exceptions. Plugin specific Options Name Data Type Default Value Description exception_callback callable\\|null null Callback to invoke on exception; receives the exception as the sole argument. throw_exceptions boolean true Re-throw caught exceptions. The IgnoreUserAbort Plugin Laminas\\Cache\\Storage\\Plugin\\IgnoreUserAbort ignores user-invoked script termination when, allowing cache write operations to complete first. Plugin specific Options Name Data Type Default Value Description exit_on_abort boolean true Terminate script execution on user abort. The OptimizeByFactor Plugin Laminas\\Cache\\Storage\\Plugin\\OptimizeByFactor calls the storage method optimize() randomly (by factor) after removing items from the cache. Plugin specific Options Name Data Type Default Value Description optimizing_factor integer 0 The automatic optimization factor. Adapter must implement OptimizableInterface The storage adapter must implement Laminas\\Cache\\Storage\\OptimizableInterface to work with this plugin. The Serializer Plugin Laminas\\Cache\\Storage\\Plugin\\Serializer will serialize data when writing to cache, and deserialize when reading. This allows storing datatypes not supported by the underlying storage adapter. Plugin specific Options Name Data Type Default Value Description serializer null\\|string\\|Laminas\\Serializer\\Adapter\\AdapterInterface null The serializer to use; see below. serializer_options array [] Array of options to use when instantiating the specified serializer. The serializer value has two special cases: When null , the default serializer is used (JSON). When a string , the value will be pulled via Laminas\\Serializer\\AdapterPluginManager , with the provided serializer_options . Available Methods The following methods are available to all Laminas\\Cache\\Storage\\Plugin\\PluginInterface implementations: namespace Laminas\\Cache\\Storage\\Plugin; use Laminas\\EventManager\\EventManagerInterface; use Laminas\\EventManager\\ListenerAggregateInterface; interface PluginInterface extends ListenerAggregateInterface { /** * Set options */ public function setOptions(PluginOptions $options): self; /** * Get options */ public function getOptions(): PluginOptions; /** * Attach listeners; inherited from ListenerAggregateInterface. */ public function attach(EventManagerInterface $events, int $priority = 1): void; /** * Detach listeners; inherited from ListenerAggregateInterface. */ public function detach(EventManagerInterface $events): void; } Examples Basic Plugin Implementation use Laminas\\Cache\\Storage\\Event; use Laminas\\Cache\\Storage\\Plugin\\AbstractPlugin; use Laminas\\EventManager\\EventManagerInterface; class MyPlugin extends AbstractPlugin { protected $handles = []; /** * Attach to all events this plugin is interested in. */ public function attach(EventManagerInterface $events, int $priority = 1): void { $this-&gt;handles[] = $events-&gt;attach('getItem.pre', array($this, 'onGetItemPre'), $priority); $this-&gt;handles[] = $events-&gt;attach('getItem.post', array($this, 'onGetItemPost'), $priority); } /** * Detach all handlers this plugin previously attached. */ public function detach(EventManagerInterface $events): void { foreach ($this-&gt;handles as $handle) { $events-&gt;detach($handle); } $this-&gt;handles = []; } public function onGetItemPre(Event $event): void { $params = $event-&gt;getParams(); echo sprintf(\"Method 'getItem' with key '%s' started\\n\", $params['key']); } public function onGetItemPost(Event $event): void { $params = $event-&gt;getParams(); echo sprintf(\"Method 'getItem' with key '%s' finished\\n\", $params['key']); } } // After defining this plugin, we can instantiate and add it to an adapter // instance: $plugin = new MyPlugin(); $cache-&gt;addPlugin($plugin); // Now when calling getItem(), our plugin should print the expected output: $cache-&gt;getItem('cache-key'); // Method 'getItem' with key 'cache-key' started // Method 'getItem' with key 'cache-key' finished","title":"Plugins"},{"location":"v4/storage/plugin/#plugins","text":"Cache storage plugins are objects that provide additional functionality to or influence behavior of a storage adapter. The plugins listen to events the adapter triggers, and can: change the arguments provided to the method triggering the event (via *.post events) skip and directly return a result (by calling stopPropagation ) change the result (by calling setResult on the provided Laminas\\Cache\\Storage\\PostEvent ) catch exceptions (by reacting to Laminas\\Cache\\Storage\\ExceptionEvent )","title":"Plugins"},{"location":"v4/storage/plugin/#quick-start","text":"Storage plugins can either be created from Laminas\\Cache\\Service\\StoragePluginFactoryInterface::create() , or by instantiating one of the Laminas\\Cache\\Storage\\Plugin\\* classes. To make life easier, Laminas\\Cache\\Service\\StoragePluginFactoryInterface::create() can create both the requested adapter and all specified plugins at once. use Laminas\\Cache\\Service\\StoragePluginFactoryInterface; use Psr\\Container\\ContainerInterface; use Laminas\\Cache\\Service\\StorageAdapterFactoryInterface; /** @var ContainerInterface $container */ $container = null; // can be any configured PSR-11 container $storageFactory = $container-&gt;get(StorageAdapterFactoryInterface::class); // All at once: $cache = $storageFactory-&gt;create( 'filesystem', [], [ ['name' =&gt; 'serializer'], ] ); // Alternately, via discrete factory methods: $cache = $storageFactory-&gt;create('filesystem'); $pluginFactory = $container-&gt;get(StoragePluginFactoryInterface::class); $plugin = $pluginFactory-&gt;create('serializer'); $cache-&gt;addPlugin($plugin); // Or manually: $cache = new Laminas\\Cache\\Storage\\Adapter\\Filesystem(); $plugin = new Laminas\\Cache\\Storage\\Plugin\\Serializer(); $cache-&gt;addPlugin($plugin);","title":"Quick Start"},{"location":"v4/storage/plugin/#the-clearexpiredbyfactor-plugin","text":"Laminas\\Cache\\Storage\\Plugin\\ClearExpiredByFactor calls the storage method clearExpired() randomly (by factor) after every call of setItem() , setItems() , addItem() , and addItems() .","title":"The ClearExpiredByFactor Plugin"},{"location":"v4/storage/plugin/#the-exceptionhandler-plugin","text":"Laminas\\Cache\\Storage\\Plugin\\ExceptionHandler catches all exceptions thrown on reading from or writing to the cache, and sends the exception to a defined callback function. You may also configure the plugin to re-throw exceptions.","title":"The ExceptionHandler Plugin"},{"location":"v4/storage/plugin/#the-ignoreuserabort-plugin","text":"Laminas\\Cache\\Storage\\Plugin\\IgnoreUserAbort ignores user-invoked script termination when, allowing cache write operations to complete first.","title":"The IgnoreUserAbort Plugin"},{"location":"v4/storage/plugin/#the-optimizebyfactor-plugin","text":"Laminas\\Cache\\Storage\\Plugin\\OptimizeByFactor calls the storage method optimize() randomly (by factor) after removing items from the cache.","title":"The OptimizeByFactor Plugin"},{"location":"v4/storage/plugin/#the-serializer-plugin","text":"Laminas\\Cache\\Storage\\Plugin\\Serializer will serialize data when writing to cache, and deserialize when reading. This allows storing datatypes not supported by the underlying storage adapter.","title":"The Serializer Plugin"},{"location":"v4/storage/plugin/#available-methods","text":"The following methods are available to all Laminas\\Cache\\Storage\\Plugin\\PluginInterface implementations: namespace Laminas\\Cache\\Storage\\Plugin; use Laminas\\EventManager\\EventManagerInterface; use Laminas\\EventManager\\ListenerAggregateInterface; interface PluginInterface extends ListenerAggregateInterface { /** * Set options */ public function setOptions(PluginOptions $options): self; /** * Get options */ public function getOptions(): PluginOptions; /** * Attach listeners; inherited from ListenerAggregateInterface. */ public function attach(EventManagerInterface $events, int $priority = 1): void; /** * Detach listeners; inherited from ListenerAggregateInterface. */ public function detach(EventManagerInterface $events): void; }","title":"Available Methods"},{"location":"v4/storage/plugin/#examples","text":"","title":"Examples"}]}